// @ts-nocheck
// This file is auto-generated by esbuild
// Do not edit directly - edit source files in src/server/
// Bundled from: src/api/server.ts
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/server/kv_store.ts
var kv_store_exports = {};
__export(kv_store_exports, {
  del: () => del,
  get: () => get,
  getByPrefix: () => getByPrefix,
  mdel: () => mdel,
  mget: () => mget,
  mset: () => mset,
  set: () => set
});
import { createClient } from "@supabase/supabase-js";
var client, set, get, del, mset, mget, mdel, getByPrefix;
var init_kv_store = __esm({
  "src/server/kv_store.ts"() {
    "use strict";
    client = () => createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    set = async (key, value) => {
      const supabase4 = client();
      const { error } = await supabase4.from("kv_store_7f0d90fb").upsert({
        key,
        value
      });
      if (error) {
        throw new Error(error.message);
      }
    };
    get = async (key) => {
      try {
        const supabase4 = client();
        if (!supabase4) {
          throw new Error("Failed to initialize Supabase client - check SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY");
        }
        const { data, error } = await supabase4.from("kv_store_7f0d90fb").select("value").eq("key", key).maybeSingle();
        if (error) {
          throw new Error(`KV Store get error for key "${key}": ${error.message}`);
        }
        return data?.value;
      } catch (error) {
        console.error(`[KV Store] get("${key}") error:`, error);
        throw error;
      }
    };
    del = async (key) => {
      const supabase4 = client();
      const { error } = await supabase4.from("kv_store_7f0d90fb").delete().eq("key", key);
      if (error) {
        throw new Error(error.message);
      }
    };
    mset = async (keys, values) => {
      const supabase4 = client();
      const { error } = await supabase4.from("kv_store_7f0d90fb").upsert(keys.map((k, i) => ({ key: k, value: values[i] })));
      if (error) {
        throw new Error(error.message);
      }
    };
    mget = async (keys) => {
      const supabase4 = client();
      const { data, error } = await supabase4.from("kv_store_7f0d90fb").select("value").in("key", keys);
      if (error) {
        throw new Error(error.message);
      }
      return data?.map((d) => d.value) ?? [];
    };
    mdel = async (keys) => {
      const supabase4 = client();
      const { error } = await supabase4.from("kv_store_7f0d90fb").delete().in("key", keys);
      if (error) {
        throw new Error(error.message);
      }
    };
    getByPrefix = async (prefix) => {
      try {
        const supabase4 = client();
        if (!supabase4) {
          throw new Error("Failed to initialize Supabase client - check SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY");
        }
        const { data, error } = await supabase4.from("kv_store_7f0d90fb").select("key, value").like("key", prefix + "%");
        if (error) {
          throw new Error(`KV Store getByPrefix error for prefix "${prefix}": ${error.message}`);
        }
        return data?.map((d) => d.key) ?? [];
      } catch (error) {
        console.error(`[KV Store] getByPrefix("${prefix}") error:`, error);
        throw error;
      }
    };
  }
});

// src/server/authHelpers.ts
var authHelpers_exports = {};
__export(authHelpers_exports, {
  ENHANCED_ROLE_DEFINITIONS: () => ENHANCED_ROLE_DEFINITIONS,
  ROLE_HIERARCHY: () => ROLE_HIERARCHY,
  adminMiddleware: () => adminMiddleware,
  authMiddleware: () => authMiddleware,
  checkAuthPermissions: () => checkAuthPermissions,
  getDefaultRole: () => getDefaultRole,
  getSuperadminEmails: () => getSuperadminEmails,
  hasPermission: () => hasPermission,
  hasRoleLevel: () => hasRoleLevel,
  isSuperAdminUser: () => isSuperAdminUser,
  isTeifiUser: () => isTeifiUser,
  supabase: () => supabase
});
import { createClient as createClient2 } from "@supabase/supabase-js";
async function getSuperadminEmails() {
  try {
    const cacheKey = "system:superadmins:cache";
    let cached;
    try {
      cached = await get(cacheKey);
    } catch (cacheError) {
    }
    if (cached && typeof cached === "object" && "emails" in cached && "timestamp" in cached) {
      const cacheAge = Date.now() - new Date(cached.timestamp).getTime();
      const CACHE_TTL = 5 * 60 * 1e3;
      if (cacheAge < CACHE_TTL) {
        return cached.emails;
      }
    }
    let superadmins;
    try {
      superadmins = await get("superadmin:emails");
    } catch (kvError) {
      const fallbackEmails = getFallbackSuperadmins();
      if (fallbackEmails.length > 0) {
        try {
          await set("superadmin:emails", fallbackEmails);
          console.log("[Auth] Auto-initialized superadmin list from fallback:", fallbackEmails.length, "emails");
        } catch (initError) {
          console.warn("[Auth] Failed to auto-initialize superadmin list:", initError);
        }
      }
      return fallbackEmails;
    }
    if (!superadmins || !Array.isArray(superadmins)) {
      console.warn("[Auth] No superadmin list in KV (invalid data), using fallback");
      return getFallbackSuperadmins();
    }
    try {
      await set(cacheKey, {
        emails: superadmins,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        ttl: 5 * 60 * 1e3
      });
    } catch (setCacheError) {
    }
    return superadmins;
  } catch (error) {
    console.error("[Auth] Error fetching superadmin list:", error);
    return getFallbackSuperadmins();
  }
}
function getFallbackSuperadmins() {
  const fallback = process.env.SUPERADMIN_EMAILS_FALLBACK;
  if (fallback) {
    return fallback.split(",").map((email) => email.trim().toLowerCase());
  }
  console.error("[Auth] CRITICAL: No superadmin list in KV store and no fallback configured");
  return [];
}
async function getDefaultRole(email) {
  if (await isSuperAdminUser(email)) return "superadmin";
  if (email.includes("@teifi.com")) return DEFAULT_ROLES["@teifi.com"];
  if (email.includes("@teifi.ca")) return DEFAULT_ROLES["@teifi.ca"];
  return DEFAULT_ROLES.default;
}
function hasPermission(userRole, permission, isSuperAdmin = false) {
  if (isSuperAdmin || userRole === "superadmin") return true;
  const roleDefinition = ENHANCED_ROLE_DEFINITIONS[userRole];
  return roleDefinition?.permissions.includes(permission) || false;
}
function hasRoleLevel(userRole, requiredRole) {
  if (userRole === "superadmin") return true;
  const userLevel = ROLE_HIERARCHY[userRole] || 0;
  const requiredLevel = ROLE_HIERARCHY[requiredRole] || 0;
  return userLevel >= requiredLevel;
}
async function isSuperAdminUser(email) {
  const normalizedEmail = email.toLowerCase().trim();
  const superadmins = await getSuperadminEmails();
  return superadmins.includes(normalizedEmail);
}
function isTeifiUser(email) {
  return TEIFI_DOMAINS.some((domain) => email.includes(domain));
}
async function checkAuthPermissions(accessToken, requiredPermission, requiredRole) {
  try {
    const { data: { user }, error } = await supabase.auth.getUser(accessToken);
    if (!user || error) {
      return {
        authorized: false,
        user: null,
        userPermissions: null,
        role: "viewer",
        error: error?.message || "Authentication failed",
        isSuperAdmin: false
      };
    }
    const userEmail = (user.email || "").toLowerCase().trim();
    let [userObj, defaultRole, isSuperAdminByEmail] = await Promise.all([
      get(`user:${user.id}`),
      getDefaultRole(userEmail),
      isSuperAdminUser(userEmail)
    ]);
    const isTeifi = isTeifiUser(userEmail);
    if (!userObj) {
      const name = user.user_metadata?.name || user.user_metadata?.full_name || userEmail.split("@")[0];
      userObj = {
        id: user.id,
        email: userEmail,
        role: defaultRole,
        status: "active",
        // All users auto-active
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        metadata: { name }
      };
      await set(`user:${user.id}`, userObj);
      await set(`user:${user.id}:customers`, []);
      console.log(
        `[Auth] Created ${defaultRole} user: ${userEmail} (${isSuperAdminByEmail ? "superadmin" : isTeifi ? "Teifi admin" : "customer user"})`
      );
    } else {
      if (isSuperAdminByEmail && userObj.role !== "superadmin") {
        console.log(
          `[Auth] Correcting role for superadmin ${userEmail}: ${userObj.role} -> superadmin`
        );
        userObj.role = "superadmin";
        userObj.status = "active";
        userObj.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
        await set(`user:${user.id}`, userObj);
      }
      if (userObj.status === "pending") {
        console.log(
          `[Auth] Auto-activating user ${userEmail}: pending -> active`
        );
        userObj.status = "active";
        userObj.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
        await set(`user:${user.id}`, userObj);
        console.log(`[Auth] User ${userEmail} activated successfully (role: ${defaultRole})`);
      }
    }
    const userRole = isSuperAdminByEmail ? "superadmin" : userObj.role;
    const isSuperAdmin = userRole === "superadmin" || isSuperAdminByEmail;
    if (userObj.status !== "active") {
      console.error(
        `[Auth] Authentication failed for ${userEmail}: Status=${userObj.status}, Role=${userRole}, IsTeifi=${isTeifi}, IsSuperAdmin=${isSuperAdmin}`
      );
      return {
        authorized: false,
        user,
        userPermissions: userObj,
        role: userRole,
        error: `Account status: ${userObj.status}. Please contact an administrator.`,
        isSuperAdmin
      };
    }
    console.log(`[Auth] Authentication successful for ${userEmail}: Role=${userRole}, Status=${userObj.status}`);
    if (requiredPermission && !hasPermission(userRole, requiredPermission, isSuperAdmin)) {
      return {
        authorized: false,
        user,
        userPermissions: userObj,
        role: userRole,
        error: `Missing required permission: ${requiredPermission}`,
        isSuperAdmin
      };
    }
    if (requiredRole && !hasRoleLevel(userRole, requiredRole)) {
      return {
        authorized: false,
        user,
        userPermissions: userObj,
        role: userRole,
        error: `Insufficient role level. Required: ${requiredRole}, Current: ${userRole}`,
        isSuperAdmin
      };
    }
    return {
      authorized: true,
      user,
      userPermissions: userObj,
      role: userRole,
      isSuperAdmin,
      error: null
    };
  } catch (error) {
    console.error("[Auth] Authentication error:", error);
    return {
      authorized: false,
      user: null,
      userPermissions: null,
      role: "viewer",
      error: "Authentication failed",
      isSuperAdmin: false
    };
  }
}
async function authMiddleware(c, next) {
  const cachedAuth = c.get("_authCheck");
  if (cachedAuth) {
    c.set("user", cachedAuth.user);
    c.set("userPermissions", cachedAuth.userPermissions);
    c.set("role", cachedAuth.role);
    c.set("isSuperAdmin", cachedAuth.isSuperAdmin);
    await next();
    return;
  }
  const authHeader = c.req.header("Authorization");
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return c.json(
      { success: false, error: "Missing or invalid authorization header" },
      { status: 401 }
    );
  }
  const accessToken = authHeader.split(" ")[1];
  const authCheck = await checkAuthPermissions(accessToken);
  if (!authCheck.authorized) {
    return c.json(
      { success: false, error: authCheck.error || "Unauthorized" },
      { status: 401 }
    );
  }
  c.set("_authCheck", authCheck);
  c.set("user", authCheck.user);
  c.set("userPermissions", authCheck.userPermissions);
  c.set("role", authCheck.role);
  c.set("isSuperAdmin", authCheck.isSuperAdmin);
  await next();
}
async function adminMiddleware(c, next) {
  const authHeader = c.req.header("Authorization");
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return c.json(
      { success: false, error: "Missing or invalid authorization header" },
      { status: 401 }
    );
  }
  const accessToken = authHeader.split(" ")[1];
  const authCheck = await checkAuthPermissions(accessToken, "manage_users");
  if (!authCheck.authorized) {
    return c.json(
      { success: false, error: authCheck.error || "Admin access required" },
      { status: 403 }
    );
  }
  c.set("user", authCheck.user);
  c.set("userPermissions", authCheck.userPermissions);
  c.set("role", authCheck.role);
  c.set("isSuperAdmin", authCheck.isSuperAdmin);
  await next();
}
var supabase, ROLE_HIERARCHY, TEIFI_DOMAINS, DEFAULT_ROLES, ENHANCED_ROLE_DEFINITIONS;
var init_authHelpers = __esm({
  "src/server/authHelpers.ts"() {
    "use strict";
    init_kv_store();
    supabase = createClient2(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    ROLE_HIERARCHY = {
      superadmin: 100,
      admin: 80,
      client_manager: 60,
      client_user: 40,
      tester: 30,
      viewer: 10
    };
    TEIFI_DOMAINS = ["@teifi.com", "@teifi.ca"];
    DEFAULT_ROLES = {
      "@teifi.com": "admin",
      "@teifi.ca": "admin",
      default: "viewer"
    };
    ENHANCED_ROLE_DEFINITIONS = {
      superadmin: {
        name: "Super Administrator",
        role: "superadmin",
        description: "Complete system access, manage all customers and global settings",
        permissions: [
          "view_issues",
          "create_issues",
          "edit_issues",
          "delete_issues",
          "view_project_status",
          "manage_users",
          "manage_permissions",
          "access_linear_test",
          "view_analytics",
          "export_data",
          "manage_system",
          "manage_customers",
          "manage_teams",
          "view_admin",
          "access_all_customers",
          "manage_security"
        ]
      },
      admin: {
        name: "Administrator",
        role: "admin",
        description: "Manage users and customers within assigned scope",
        permissions: [
          "view_issues",
          "create_issues",
          "edit_issues",
          "delete_issues",
          "view_project_status",
          "manage_users",
          "manage_permissions",
          "access_linear_test",
          "view_analytics",
          "export_data",
          "manage_customers",
          "manage_teams",
          "view_admin"
        ]
      },
      client_manager: {
        name: "Client Manager",
        role: "client_manager",
        description: "Manage team members and view analytics",
        permissions: [
          "view_issues",
          "create_issues",
          "edit_issues",
          "view_project_status",
          "manage_permissions",
          "view_analytics"
        ]
      },
      client_user: {
        name: "Client User",
        role: "client_user",
        description: "Create and manage own issues",
        permissions: [
          "view_issues",
          "create_issues",
          "edit_issues",
          "view_project_status"
        ]
      },
      tester: {
        name: "Tester",
        role: "tester",
        description: "Test features and report bugs",
        permissions: [
          "view_issues",
          "create_issues",
          "view_project_status"
        ]
      },
      viewer: {
        name: "Viewer",
        role: "viewer",
        description: "View-only access to assigned projects",
        permissions: ["view_issues", "view_project_status"]
      }
    };
  }
});

// src/server/services/linearTeamService.ts
var linearTeamService_exports = {};
__export(linearTeamService_exports, {
  LinearTeamService: () => LinearTeamService
});
import { createClient as createClient3 } from "@supabase/supabase-js";
var supabase2, LinearTeamService;
var init_linearTeamService = __esm({
  "src/server/services/linearTeamService.ts"() {
    "use strict";
    supabase2 = createClient3(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    LinearTeamService = class {
      config;
      baseUrl = "https://api.linear.app/graphql";
      constructor(customApiKey) {
        this.config = {
          apiKey: customApiKey || process.env.LINEAR_API_KEY || "",
          teamId: process.env.LINEAR_TEAM_ID || "",
          workspaceId: process.env.LINEAR_WORKSPACE_ID || ""
        };
      }
      async testConnection() {
        console.log("Testing Linear connection...");
        console.log("API Key present:", !!this.config.apiKey);
        console.log(
          "API Key prefix:",
          this.config.apiKey?.substring(0, 10) + "..."
        );
        if (!this.config.apiKey) {
          return {
            success: false,
            message: "Linear API key not configured. Please set LINEAR_API_KEY environment variable."
          };
        }
        if (!this.config.apiKey.startsWith("lin_api_")) {
          return {
            success: false,
            message: 'Invalid Linear API key format. API key should start with "lin_api_"'
          };
        }
        const query = `
      query {
        viewer {
          id
          name
          email
        }
        organization {
          id
          name
        }
      }
    `;
        try {
          const result = await this.makeGraphQLRequest(query);
          if (result.data?.viewer) {
            return {
              success: true,
              message: "Linear API connection successful",
              data: {
                user: result.data.viewer,
                organization: result.data.organization,
                apiKeyPrefix: this.config.apiKey.substring(0, 10) + "..."
              }
            };
          }
          return {
            success: false,
            message: "Linear API returned unexpected response",
            data: result
          };
        } catch (error) {
          return {
            success: false,
            message: `Linear API connection failed: ${error instanceof Error ? error.message : "Unknown error"}`,
            data: { error: error.toString() }
          };
        }
      }
      async makeGraphQLRequest(query, variables = {}, options = {}) {
        if (!this.config.apiKey) {
          throw new Error("Linear API key not configured");
        }
        const queryNameMatch = query.match(/(?:query|mutation)\s+(\w+)/);
        const queryName = queryNameMatch ? queryNameMatch[1] : "UnknownQuery";
        console.log(`[Linear TeamService] Executing ${queryName}`);
        console.log(`[Linear TeamService] Variables:`, JSON.stringify(variables, null, 2));
        Object.entries(variables).forEach(([key, value]) => {
          const type = typeof value;
          const isUuid = typeof value === "string" && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value);
          console.log(`[Linear TeamService] Variable ${key}: ${type}${isUuid ? " (UUID)" : ""} = ${value}`);
        });
        const controller = new AbortController();
        const timeoutId = setTimeout(
          () => controller.abort(),
          15e3
        );
        try {
          console.log(
            "Making Linear GraphQL request with API key:",
            this.config.apiKey?.substring(0, 8) + "..."
          );
          const response = await fetch(this.baseUrl, {
            method: "POST",
            headers: {
              Authorization: this.config.apiKey,
              "Content-Type": "application/json",
              "public-file-urls-expire-in": "3600"
              // 1 hour signed URLs for attachments
            },
            body: JSON.stringify({ query, variables }),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            let errorMessage = `Linear API HTTP error: ${response.status} ${response.statusText}`;
            try {
              const errorBody = await response.text();
              console.error(
                `[Linear TeamService] HTTP Error for ${queryName}:`,
                errorBody
              );
              errorMessage += ` - ${errorBody}`;
            } catch (e) {
              console.error(
                "Could not read error response body:",
                e
              );
            }
            throw new Error(errorMessage);
          }
          const result = await response.json();
          if (result.errors) {
            console.error(`[Linear TeamService] GraphQL Errors for ${queryName}:`, result.errors);
            console.error(`[Linear TeamService] Failed Query: ${queryName}`);
            console.error(`[Linear TeamService] Failed Variables:`, JSON.stringify(variables, null, 2));
            console.error(`[Linear TeamService] Query Text:`, query);
            const errorMessage = result.errors[0]?.message || "Unknown GraphQL error";
            if (errorMessage.includes("Variable") && errorMessage.includes("type") && errorMessage.includes("expecting")) {
              console.error(`[Linear TeamService] TYPE MISMATCH ERROR in ${queryName}:`);
              console.error(`[Linear TeamService] Error: ${errorMessage}`);
              throw new Error(`Linear GraphQL Type Error in ${queryName}: ${errorMessage}`);
            }
            const teamNotFoundError = result.errors.find(
              (error) => error.message?.includes("Entity not found: Team") || error.extensions?.userPresentableMessage?.includes(
                "Could not find referenced Team"
              )
            );
            if (teamNotFoundError) {
              console.log(
                "Team not found error detected:",
                teamNotFoundError
              );
              if (options.allowTeamNotFound) {
                return {
                  data: null,
                  teamNotFound: true,
                  errors: result.errors
                };
              }
              throw new Error(
                `Team not found: ${teamNotFoundError.extensions?.userPresentableMessage || teamNotFoundError.message}`
              );
            }
            const authError = result.errors.find(
              (error) => error.message?.includes("authentication") || error.message?.includes("Unauthorized") || error.message?.includes("Invalid token") || error.extensions?.code === "UNAUTHENTICATED"
            );
            if (authError) {
              console.error(
                "Linear authentication error:",
                authError
              );
              throw new Error(
                "Linear API authentication failed. Please check your API key."
              );
            }
            const firstError = result.errors[0];
            throw new Error(
              `Linear API error in ${queryName}: ${firstError.message} (Code: ${firstError.extensions?.code || "Unknown"})`
            );
          }
          console.log(`[Linear TeamService] Successfully executed ${queryName}`);
          return result;
        } catch (error) {
          if (error instanceof Error && error.name === "AbortError") {
            throw new Error("Linear API request timed out");
          }
          throw error;
        }
      }
      /**
       *Sync team hierarchy from Linear to KV Store
       * Fetches all teams with full details and stores in hierarchical structure
       */
      async syncTeamHierarchy() {
        if (!this.config.apiKey) {
          return {
            success: false,
            message: "Linear API key not configured"
          };
        }
        console.log("[LinearTeamService] Starting team hierarchy sync...");
        const query = `
      query GetTeamsWithHierarchy($after: String) {
        teams(first: 20, after: $after) {
          nodes {
            id
            name
            key
            description
            color
            icon
            createdAt
            updatedAt
            parent {
              id
              name
              key
            }
            organization {
              id
              name
            }
            states(first: 20) {
              nodes {
                id
                name
                type
                color
                position
              }
            }
            labels(first: 20) {
              nodes {
                id
                name
                color
                description
              }
            }
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    `;
        try {
          let allTeams = [];
          let after = void 0;
          let pageCount = 0;
          while (true) {
            pageCount++;
            console.log(`[Sync] Fetching teams page ${pageCount}...`);
            const result = await this.makeGraphQLRequest(query, { after });
            if (result.data?.teams?.nodes) {
              const teams = result.data.teams.nodes;
              allTeams = allTeams.concat(teams);
              console.log(`[Sync] Page ${pageCount}: ${teams.length} teams (total: ${allTeams.length})`);
              const pageInfo = result.data.teams.pageInfo;
              if (!pageInfo.hasNextPage) {
                console.log(`[Sync] Complete! Total teams: ${allTeams.length}`);
                break;
              }
              after = pageInfo.endCursor;
            } else {
              break;
            }
          }
          if (allTeams.length === 0) {
            console.warn("\uFE0F [Sync] No teams found in Linear workspace");
            return {
              success: true,
              message: "No teams found in Linear workspace",
              data: {
                teamsCount: 0,
                teams: []
              }
            };
          }
          console.log(`[Sync] Building team hierarchy...`);
          const syncedAt = (/* @__PURE__ */ new Date()).toISOString();
          console.log("[Sync] Cleaning up old team entries...");
          const { data: oldTeamKeys } = await supabase2.from("kv_store_7f0d90fb").select("key").like("key", "linear_teams:%").neq("key", "linear_teams:all");
          if (oldTeamKeys && oldTeamKeys.length > 0) {
            console.log(`[Sync] Found ${oldTeamKeys.length} existing team entries`);
            await supabase2.from("kv_store_7f0d90fb").delete().like("key", "linear_teams:%").neq("key", "linear_teams:all");
            console.log(`[Sync] Deleted ${oldTeamKeys.length} old team entries`);
          }
          console.log("[Sync] Storing new team entries...");
          for (const team of allTeams) {
            const teamData = {
              ...team,
              parent_id: team.parent?.id || null,
              parent_name: team.parent?.name || null,
              parent_key: team.parent?.key || null,
              syncedAt,
              source: "linear_api"
            };
            await supabase2.from("kv_store_7f0d90fb").upsert({
              key: `linear_teams:${team.id}`,
              value: teamData
              // Direct object, no stringify
            });
          }
          console.log(`[Sync] Stored ${allTeams.length} new team entries`);
          const buildHierarchy = (teams) => {
            const teamMap = new Map(teams.map((t) => [t.id, { ...t, children: [], level: 0, childCount: 0 }]));
            const rootTeams = [];
            for (const team of teams) {
              const teamNode = teamMap.get(team.id);
              if (!teamNode) continue;
              if (team.parent?.id && teamMap.has(team.parent.id)) {
                const parentNode = teamMap.get(team.parent.id);
                if (parentNode) {
                  parentNode.children.push(teamNode);
                  teamNode.level = parentNode.level + 1;
                }
              } else {
                rootTeams.push(teamNode);
              }
            }
            const calculateDescendants = (node) => {
              if (node.children.length === 0) {
                node.childCount = 0;
                node.totalDescendants = 0;
                return 0;
              }
              let total = node.children.length;
              for (const child of node.children) {
                total += calculateDescendants(child);
              }
              node.childCount = node.children.length;
              node.totalDescendants = total;
              return total;
            };
            for (const root of rootTeams) {
              calculateDescendants(root);
            }
            return rootTeams;
          };
          const hierarchy = buildHierarchy(allTeams);
          console.log(`[Sync] Built hierarchy: ${hierarchy.length} root teams, ${allTeams.length} total teams`);
          const teamList = allTeams.map((t) => ({
            id: t.id,
            name: t.name,
            key: t.key,
            description: t.description,
            color: t.color,
            icon: t.icon,
            parent_id: t.parent?.id || null,
            parent_name: t.parent?.name || null
          }));
          await supabase2.from("kv_store_7f0d90fb").upsert({
            key: "linear_teams:all",
            value: {
              teams: teamList,
              hierarchy,
              rootTeamsCount: hierarchy.length,
              totalTeamsCount: teamList.length,
              count: teamList.length,
              syncedAt
            }
            // Direct object, no stringify
          });
          if (allTeams[0]?.organization) {
            await supabase2.from("kv_store_7f0d90fb").upsert({
              key: "linear:organization",
              value: {
                ...allTeams[0].organization,
                teamsCount: allTeams.length,
                syncedAt
              }
              // Direct object, no stringify
            });
          }
          console.log("[Sync] Team hierarchy successfully synced to KV");
          console.log(`[Sync] Hierarchy stats: ${hierarchy.length} roots, ${allTeams.length} total teams`);
          console.log("[Sync] Validating customer-team mappings...");
          const validTeamIds = new Set(allTeams.map((t) => t.id));
          const { data: customerMappings } = await supabase2.from("kv_store_7f0d90fb").select("key, value").like("key", "customer_teams:%");
          let orphanedCount = 0;
          const orphanedMappings = [];
          if (customerMappings && customerMappings.length > 0) {
            console.log(`[Sync] Checking ${customerMappings.length} customer mappings...`);
            for (const mapping of customerMappings) {
              const customerId = mapping.key.replace("customer_teams:", "");
              const teamIds = Array.isArray(mapping.value) ? mapping.value : [];
              const orphaned = teamIds.filter((teamId) => !validTeamIds.has(teamId));
              if (orphaned.length > 0) {
                orphanedCount += orphaned.length;
                orphanedMappings.push({
                  customerId,
                  teamIds: orphaned
                });
                console.log(`[Sync] Customer ${customerId} has ${orphaned.length} orphaned team assignments:`, orphaned);
              }
            }
          }
          if (orphanedCount > 0) {
            console.log(`[Sync] WARNING: Found ${orphanedCount} orphaned team assignments across ${orphanedMappings.length} customers`);
            console.log("[Sync] These teams were deleted in Linear but still assigned to customers");
            console.log("[Sync] Use /admin/cleanup-orphaned-mappings endpoint to clean up");
          } else {
            console.log("[Sync] All customer-team mappings are valid");
          }
          return {
            success: true,
            message: `Successfully synced ${allTeams.length} teams (${hierarchy.length} root teams)`,
            data: {
              teamsCount: allTeams.length,
              rootTeamsCount: hierarchy.length,
              teams: teamList,
              hierarchy,
              syncedAt,
              orphanedMappings: orphanedMappings.length > 0 ? {
                count: orphanedCount,
                customers: orphanedMappings.length,
                details: orphanedMappings
              } : null
            }
          };
        } catch (error) {
          console.error("[Sync] Team hierarchy sync error:", error);
          return {
            success: false,
            message: `Sync failed: ${error instanceof Error ? error.message : "Unknown error"}`
          };
        }
      }
      async listTeams() {
        if (!this.config.apiKey) {
          return {
            success: false,
            message: "Linear API key not configured"
          };
        }
        const query = `
      query GetTeamsPaginated($after: String) {
        teams(first: 250, after: $after) {
          nodes {
            id
            name
            key  
            description
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    `;
        try {
          console.log("Starting Linear teams query with pagination...");
          let allTeams = [];
          let after = void 0;
          let pageCount = 0;
          while (true) {
            pageCount++;
            console.log(`[Pagination] Fetching teams page ${pageCount}`);
            const result = await this.makeGraphQLRequest(query, { after });
            if (result.data?.teams?.nodes) {
              const teams = result.data.teams.nodes;
              allTeams = allTeams.concat(teams);
              console.log(`[Pagination] Page ${pageCount}: Retrieved ${teams.length} teams (total: ${allTeams.length})`);
              const pageInfo = result.data.teams.pageInfo;
              if (!pageInfo.hasNextPage) {
                console.log(`[Pagination] Complete! Total teams fetched: ${allTeams.length} across ${pageCount} page(s)`);
                break;
              }
              after = pageInfo.endCursor;
            } else {
              break;
            }
          }
          if (allTeams.length > 0) {
            console.log(`Found ${allTeams.length} teams in Linear workspace`);
            return {
              success: true,
              teams: allTeams,
              message: "Teams fetched successfully"
            };
          }
          return {
            success: false,
            message: "No teams found in Linear workspace"
          };
        } catch (error) {
          console.error("Linear listTeams error:", error);
          return {
            success: false,
            message: `Failed to fetch teams: ${error instanceof Error ? error.message : "Unknown error"}`
          };
        }
      }
      isValidTeamId(teamId) {
        if (!teamId || typeof teamId !== "string") {
          return false;
        }
        const trimmed = teamId.trim();
        if (trimmed.length === 0) {
          return false;
        }
        return /^[a-zA-Z0-9\-_]{2,50}$/.test(trimmed);
      }
      async getTeamById(teamId) {
        if (!this.isValidTeamId(teamId)) {
          console.log(`Invalid team ID format: ${teamId}`);
          return null;
        }
        const query = `
      query GetTeam($teamId: String!) {
  team(id: $teamId) {
    id
    name
    key
    description
    members {
      nodes {
        name
        email
        avatarUrl
      }
    }
    states {
      nodes {
        id
        name
        type
        color
        position
      }
    }
    labels {
      nodes {
        id
        name
        color
        description
      }
    }
    createdAt
    updatedAt
  }
}
    `;
        try {
          const result = await this.makeGraphQLRequest(
            query,
            { teamId },
            { allowTeamNotFound: true }
          );
          if (result.teamNotFound) {
            console.log(
              `Team ${teamId} not found in Linear workspace`
            );
            return null;
          }
          if (result.data?.team) {
            console.log(`Fetched team: ${result.data.team.name}`);
            return result.data.team;
          }
          return null;
        } catch (error) {
          console.error("Failed to fetch team by ID:", error);
          if (error instanceof Error && error.message.includes("Entity not found: Team")) {
            console.log(
              `Team ${teamId} does not exist in Linear workspace`
            );
            return null;
          }
          return null;
        }
      }
      async getTeamLabels(teamId) {
        if (!this.isValidTeamId(teamId)) {
          console.log(
            `Invalid team ID format for labels: ${teamId}`
          );
          return [];
        }
        const query = `
      query GetTeamLabels($teamId: String!) {
        team(id: $teamId) {
          id
          name
          labels {
            nodes {
              id
              name
              color
              description
              createdAt
            }
          }
        }
      }
    `;
        try {
          const result = await this.makeGraphQLRequest(
            query,
            { teamId },
            { allowTeamNotFound: true }
          );
          if (result.teamNotFound) {
            console.log(
              `Team ${teamId} not found when fetching labels`
            );
            return [];
          }
          if (result.data?.team?.labels?.nodes) {
            console.log(
              `Fetched ${result.data.team.labels.nodes.length} labels for team: ${result.data.team.name}`
            );
            return result.data.team.labels.nodes;
          }
          return [];
        } catch (error) {
          console.error("Failed to fetch team labels:", error);
          if (error instanceof Error && error.message.includes("Entity not found: Team")) {
            console.log(
              `Team ${teamId} does not exist when fetching labels`
            );
            return [];
          }
          return [];
        }
      }
      async authenticateUser(accessToken) {
        if (!accessToken) {
          throw new Error("Authorization token required");
        }
        const {
          data: { user },
          error
        } = await supabase2.auth.getUser(accessToken);
        if (error || !user) {
          throw new Error("Invalid or expired token");
        }
        return {
          user,
          userEmail: user.email || "unknown"
        };
      }
      async getTeamsWithHierarchy() {
        if (!this.config.apiKey) {
          throw new Error("Linear API key not configured");
        }
        const query = `
      query GetTeamsPaginated($after: String) {
        teams(first: 250, after: $after) {
          nodes {
            id
            name
            key
            description
            parent { id name }
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    `;
        let after = null;
        let allTeams = [];
        let page = 1;
        try {
          console.log("Fetching Linear teams with pagination...");
          while (true) {
            console.log(
              `\uFE0F  Fetching page ${page} (after: ${after || "none"})`
            );
            const result = await this.makeGraphQLRequest(query, {
              after
            });
            if (!result.data?.teams?.nodes) {
              console.warn("\uFE0F No team nodes in Linear response.");
              break;
            }
            const { nodes, pageInfo } = result.data.teams;
            allTeams.push(...nodes);
            console.log(
              `Page ${page}: fetched ${nodes.length} teams (total ${allTeams.length})`
            );
            if (!pageInfo?.hasNextPage) {
              console.log("All teams fetched from Linear.");
              break;
            }
            after = pageInfo.endCursor;
            page++;
            await new Promise((r) => setTimeout(r, 150));
          }
          const withParent = allTeams.filter((t) => t.parent).length;
          const rootTeams = allTeams.filter((t) => !t.parent).length;
          console.log("Linear Team Stats:", {
            total: allTeams.length,
            rootTeams,
            withParent
          });
          return allTeams;
        } catch (error) {
          console.error(
            "Failed to fetch teams with hierarchy:",
            error
          );
          throw error;
        }
      }
      buildHierarchyFromParents(rawTeams) {
        console.log(
          "Building hierarchy from parent relationships..."
        );
        console.log(`Processing ${rawTeams.length} teams`);
        const teamsMap = new Map(
          rawTeams.map((t) => [
            t.id,
            {
              id: t.id,
              name: t.name,
              key: t.key || t.id,
              description: t.description || "",
              parent: t.parent,
              children: [],
              level: 0,
              childCount: 0,
              totalDescendants: 0
            }
          ])
        );
        console.log(`Created teams map with ${teamsMap.size} entries`);
        for (const team of rawTeams) {
          if (team.parent?.id && teamsMap.has(team.parent.id)) {
            const parentTeam = teamsMap.get(team.parent.id);
            const childTeam = teamsMap.get(team.id);
            if (parentTeam && childTeam) {
              parentTeam.children.push(childTeam);
              console.log(
                `  \u21B3 Attached "${childTeam.name}" to parent "${parentTeam.name}"`
              );
            }
          }
        }
        const calculateMetrics = (team, level) => {
          team.level = level;
          team.childCount = team.children.length;
          let totalDescendants = team.children.length;
          for (const child of team.children) {
            totalDescendants += calculateMetrics(child, level + 1);
          }
          team.totalDescendants = totalDescendants;
          return totalDescendants;
        };
        const roots = rawTeams.filter((t) => !t.parent || !t.parent.id).map((t) => teamsMap.get(t.id)).filter(Boolean);
        console.log(`Found ${roots.length} root teams`);
        for (const root of roots) {
          calculateMetrics(root, 0);
          console.log(
            ` Root: "${root.name}" [${root.key}] - ${root.childCount} direct children, ${root.totalDescendants} total descendants`
          );
        }
        roots.sort((a, b) => a.name.localeCompare(b.name));
        console.log(
          `Built hierarchy: ${roots.length} root teams with full tree structure`
        );
        return roots;
      }
      buildHierarchyFromNested(rawTeams) {
        console.log(
          "\uFE0F buildHierarchyFromNested is deprecated, using buildHierarchyFromParents instead"
        );
        return this.buildHierarchyFromParents(rawTeams);
      }
      countAllTeams(teams) {
        return teams.reduce((count, team) => {
          return count + 1 + this.countAllTeams(team.children || []);
        }, 0);
      }
      async validateTeam(teamId) {
        const startTime = Date.now();
        const result = {
          success: false,
          message: "",
          team: null,
          error: null,
          details: [],
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          responseTime: 0
        };
        try {
          if (!teamId || typeof teamId !== "string" || teamId.trim() === "") {
            result.error = "Team ID is required and must be a non-empty string";
            result.details = [
              "Provide a valid team ID (not empty, null, or whitespace)",
              "Team ID should be a string format",
              "Check if the team ID was passed correctly"
            ];
            return result;
          }
          if (!this.isValidTeamId(teamId)) {
            result.error = "Invalid team ID format";
            result.details = [
              "Team ID must be 2-50 characters with alphanumeric, hyphens, or underscores only",
              'Examples: "a1", "team-backend-dev", "eng_platform_123"',
              "Copy team ID directly from Linear interface",
              `Provided: "${teamId}" (${teamId.length} chars)`
            ];
            return result;
          }
          if (!this.config.apiKey) {
            result.error = "Linear API key not configured";
            result.details = [
              "Set LINEAR_API_KEY environment variable",
              "Generate API key from Linear Settings \u2192 API",
              "Ensure API key has team read permissions"
            ];
            return result;
          }
          const query = `
        query ValidateTeam($teamId: ID!) {
          team(id: $teamId) {
            id
            name
            key
            description
            createdAt
            updatedAt
          }
        }
      `;
          console.log(`Validating team ID: ${teamId}`);
          const apiResult = await this.makeGraphQLRequest(
            query,
            { teamId },
            { allowTeamNotFound: true }
          );
          if (apiResult.teamNotFound) {
            result.error = "Team not found in workspace";
            result.details = [
              "Contact Linear admin if team should exist"
            ];
            return result;
          }
          if (apiResult.data?.team) {
            result.success = true;
            result.message = `Team found: ${apiResult.data.team.name} (${apiResult.data.team.key})`;
            result.team = apiResult.data.team;
            result.details = [
              "Team validation successful",
              "Team exists and is accessible"
            ];
            return result;
          }
          result.error = "Unexpected response from Linear API";
          result.details = ["Try again in a few moments"];
          return result;
        } catch (error) {
          console.error("Team validation error:", error);
          if (error instanceof Error) {
            if (error.message.includes("Entity not found: Team")) {
              result.error = "Team entity not found";
              result.details = [
                "Verify API key has sufficient permissions"
              ];
            } else if (error.message.includes("Unauthorized")) {
              result.error = "API authentication failed";
              result.details = [
                "Invalid or expired Linear API key"
              ];
            } else if (error.message.includes("timeout")) {
              result.error = "Linear API request timeout";
              result.details = ["Try again in a few moments"];
            } else {
              result.error = error.message;
              result.details = ["Check server logs for details"];
            }
          }
          return result;
        } finally {
          result.responseTime = Date.now() - startTime;
        }
      }
      async getSingleTeam(teamId) {
        if (!this.isValidTeamId(teamId)) {
          console.log(`Invalid team ID format: ${teamId}`);
          return null;
        }
        const query = `
      query GetSingleTeam($teamId: ID!) {
        team(id: $teamId) {
          id
          name
          key
          description
          parent {
            id
            name
            key
          }
          members {
            nodes {
              id
              name
              email
              avatarUrl
            }
          }
          states {
            nodes {
              id
              name
              type
              color
              position
            }
          }
          labels {
            nodes {
              id
              name
              color
              description
            }
          }
          createdAt
          updatedAt
        }
      }
    `;
        try {
          const result = await this.makeGraphQLRequest(
            query,
            { teamId },
            { allowTeamNotFound: true }
          );
          if (result.teamNotFound) {
            console.log(
              `Team ${teamId} not found in Linear workspace`
            );
            return null;
          }
          if (result.data?.team) {
            console.log(
              `Fetched single team: ${result.data.team.name} (${result.data.team.key})`
            );
            return result.data.team;
          }
          return null;
        } catch (error) {
          console.error("Failed to fetch single team:", error);
          return null;
        }
      }
      async getTeamsBatch(teamIds, includeDetails = false) {
        if (!teamIds || teamIds.length === 0) {
          return [];
        }
        const BATCH_SIZE = 10;
        const batches = [];
        for (let i = 0; i < teamIds.length; i += BATCH_SIZE) {
          batches.push(teamIds.slice(i, i + BATCH_SIZE));
        }
        console.log(
          `Processing ${teamIds.length} teams in ${batches.length} batches`
        );
        const results = [];
        for (const batch of batches) {
          const batchResults = await Promise.all(
            batch.map(async (teamId) => {
              try {
                if (includeDetails) {
                  return await this.getSingleTeam(teamId);
                } else {
                  const query = `
                query GetTeamBasic($teamId: String!) {
                  team(id: $teamId) {
                    id
                    name
                    key
                    description
                    parent {
                      id
                      name
                      key
                    }
                  }
                }
              `;
                  const result = await this.makeGraphQLRequest(
                    query,
                    { teamId }
                  );
                  return result.data?.team || null;
                }
              } catch (error) {
                console.warn(
                  `Failed to fetch team ${teamId}:`,
                  error.message
                );
                return null;
              }
            })
          );
          results.push(...batchResults.filter(Boolean));
          if (batches.length > 1) {
            await new Promise(
              (resolve) => setTimeout(resolve, 100)
            );
          }
        }
        console.log(
          `Successfully fetched ${results.length}/${teamIds.length} teams`
        );
        return results;
      }
      async getProcessedTeamsHierarchy(page = 1, pageSize = 50) {
        const rawTeams = await this.getTeamsWithHierarchy();
        if (!rawTeams || rawTeams.length === 0) {
          throw new Error(
            "No teams data available from Linear API"
          );
        }
        const hierarchy = this.buildHierarchyFromNested(rawTeams);
        const totalTeams = this.countAllTeams(hierarchy);
        const startIndex = (page - 1) * pageSize;
        const endIndex = startIndex + pageSize;
        const paginatedHierarchy = hierarchy.slice(
          startIndex,
          endIndex
        );
        const response = {
          totalTeams,
          rootTeams: hierarchy.length,
          currentPage: page,
          pageSize,
          totalPages: Math.ceil(hierarchy.length / pageSize),
          hierarchy: paginatedHierarchy,
          hasMore: endIndex < hierarchy.length
        };
        console.log("Paginated team hierarchy response:", {
          totalTeams: response.totalTeams,
          rootTeams: response.rootTeams,
          currentPage: response.currentPage,
          totalPages: response.totalPages,
          returnedRootTeams: paginatedHierarchy.length
        });
        return response;
      }
      buildTeamHierarchyResponse(rawTeams) {
        const hierarchy = this.buildHierarchyFromNested(rawTeams);
        const totalTeams = this.countAllTeams(hierarchy);
        const response = {
          totalTeams,
          rootTeams: hierarchy.length,
          hierarchy
        };
        console.log("Team hierarchy response:", {
          totalTeams: response.totalTeams,
          rootTeams: response.rootTeams,
          rootTeamNames: response.hierarchy.map(
            (t) => `${t.name} [${t.key}] (${t.totalDescendants} descendants)`
          )
        });
        return response;
      }
      async determineTeamAssignment(feature, customerContext) {
        console.log(
          `Determining team assignment for feature: ${feature}`,
          customerContext
        );
        const rawTeams = await this.getTeamsWithHierarchy();
        if (feature.toLowerCase().includes("inventory")) {
          const inventoryTeam = rawTeams.find(
            (team) => team.name.toLowerCase().includes("inventory") || team.key.toLowerCase().includes("inv")
          );
          if (inventoryTeam) {
            console.log(
              `Assigned to inventory team: ${inventoryTeam.name}`
            );
            return inventoryTeam.id;
          }
        }
        if (rawTeams.length > 0) {
          console.log(`Default assignment to: ${rawTeams[0].name}`);
          return rawTeams[0].id;
        }
        throw new Error("No teams available for assignment");
      }
      async autoAssignEpicOwner(epic) {
        console.log(`Auto-assigning epic owner for: ${epic}`);
        try {
          const rawTeams = await this.getTeamsWithHierarchy();
          if (rawTeams.length > 0) {
            console.log(
              `Epic ${epic} assignment logic not yet implemented`
            );
            return void 0;
          }
          return void 0;
        } catch (error) {
          console.error("Error in autoAssignEpicOwner:", error);
          return void 0;
        }
      }
      /**
       * Sync all teams from Linear to KV store
       * This should be called once initially and then on-demand by superadmin
       */
      async syncTeamsToKV() {
        console.log("Starting Linear teams sync to KV store...");
        try {
          const kv = await Promise.resolve().then(() => (init_kv_store(), kv_store_exports));
          console.log("Fetching all teams from Linear API...");
          const rawTeams = await this.getTeamsWithHierarchy();
          if (!rawTeams || rawTeams.length === 0) {
            throw new Error("No teams found in Linear workspace");
          }
          console.log(`Fetched ${rawTeams.length} teams from Linear`);
          const teamIds = [];
          const syncStartTime = Date.now();
          for (const team of rawTeams) {
            const teamData = {
              id: team.id,
              name: team.name,
              key: team.key,
              description: team.description || null,
              parent: team.parent || null,
              createdAt: team.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
              updatedAt: team.updatedAt || (/* @__PURE__ */ new Date()).toISOString(),
              syncedAt: (/* @__PURE__ */ new Date()).toISOString()
            };
            await kv.set(`linear_teams:${team.id}`, teamData);
            teamIds.push(team.id);
            console.log(` Synced team: ${team.name} [${team.key}]`);
          }
          await kv.set("linear_teams:all", teamIds);
          const syncMetadata = {
            lastSync: (/* @__PURE__ */ new Date()).toISOString(),
            teamCount: rawTeams.length,
            syncDuration: Date.now() - syncStartTime,
            source: "Linear API"
          };
          await kv.set("linear_teams:metadata", syncMetadata);
          console.log(`Successfully synced ${rawTeams.length} teams to KV store`);
          console.log(`Sync duration: ${syncMetadata.syncDuration}ms`);
          return {
            success: true,
            teamCount: rawTeams.length,
            syncMetadata,
            teams: rawTeams
          };
        } catch (error) {
          console.error("Failed to sync teams to KV:", error);
          throw error;
        }
      }
      /**
       * Get all teams from KV store
       */
      async getTeamsFromKV() {
        console.log("Fetching teams from KV store...");
        try {
          const kv = await Promise.resolve().then(() => (init_kv_store(), kv_store_exports));
          const teamIds = await kv.get("linear_teams:all");
          if (!teamIds || !Array.isArray(teamIds)) {
            console.warn("\uFE0F No teams found in KV store. Need to sync from Linear first.");
            return {
              success: false,
              message: "No teams synced yet. Please sync from Linear first.",
              teams: [],
              metadata: null
            };
          }
          console.log(`Found ${teamIds.length} team IDs in KV store`);
          const teams = [];
          for (const teamId of teamIds) {
            const teamData = await kv.get(`linear_teams:${teamId}`);
            if (teamData) {
              teams.push(teamData);
            }
          }
          const metadata = await kv.get("linear_teams:metadata");
          console.log(`Retrieved ${teams.length} teams from KV store`);
          if (metadata) {
            console.log(`\u2139\uFE0F  Last sync: ${metadata.lastSync}`);
          }
          return {
            success: true,
            teams,
            metadata
          };
        } catch (error) {
          console.error("Failed to get teams from KV:", error);
          throw error;
        }
      }
      /**
       * Get teams hierarchy from KV store
       */
      async getTeamsHierarchyFromKV() {
        console.log("Building teams hierarchy from KV store...");
        const kvResult = await this.getTeamsFromKV();
        if (!kvResult.success || !kvResult.teams || kvResult.teams.length === 0) {
          return {
            success: false,
            message: kvResult.message || "No teams available",
            hierarchy: [],
            totalTeams: 0,
            rootTeams: 0,
            metadata: null
          };
        }
        const hierarchy = this.buildHierarchyFromParents(kvResult.teams);
        const totalTeams = this.countAllTeams(hierarchy);
        console.log(`Built hierarchy: ${hierarchy.length} root teams, ${totalTeams} total teams`);
        return {
          success: true,
          hierarchy,
          totalTeams,
          rootTeams: hierarchy.length,
          metadata: kvResult.metadata
        };
      }
      /**
       * Get single team from KV store by ID
       */
      async getTeamFromKV(teamId) {
        console.log(`Fetching team ${teamId} from KV store...`);
        try {
          const kv = await Promise.resolve().then(() => (init_kv_store(), kv_store_exports));
          const teamData = await kv.get(`linear_teams:${teamId}`);
          if (teamData) {
            console.log(`Found team in KV: ${teamData.name} [${teamData.key}]`);
            return teamData;
          }
          console.warn(`\uFE0F Team ${teamId} not found in KV store`);
          return null;
        } catch (error) {
          console.error(`Failed to get team ${teamId} from KV:`, error);
          return null;
        }
      }
    };
  }
});

// src/api/server.ts
import { handle } from "@hono/node-server/vercel";

// src/server/index.ts
import "dotenv/config";
import { Hono as Hono9 } from "hono";
import { cors } from "hono/cors";
import { logger } from "hono/logger";
import { serve } from "@hono/node-server";

// src/server/routes/systemRoutes.ts
init_authHelpers();
init_authHelpers();
import { Hono } from "hono";

// src/server/services/migrationService.ts
init_kv_store();
var MigrationService = class {
  /**
   * Run full migration from old schema to new schema
   */
  async migrateToV2() {
    try {
      console.log("[Migration] Starting v2.0 schema migration...");
      const report = {
        users_migrated: 0,
        customer_memberships_created: 0,
        team_assignments_created: 0,
        indexes_created: 0,
        errors: []
      };
      console.log("[Migration] Step 1: Migrating user permissions...");
      const userResult = await this.migrateUserPermissions();
      report.users_migrated = userResult.count;
      report.customer_memberships_created = userResult.memberships;
      if (userResult.errors) report.errors.push(...userResult.errors);
      console.log("[Migration] Step 2: Building customer member indexes...");
      const indexResult = await this.buildCustomerMemberIndexes();
      report.indexes_created = indexResult.count;
      if (indexResult.errors) report.errors.push(...indexResult.errors);
      console.log("[Migration] Step 3: Creating team-customer mappings...");
      const teamResult = await this.createTeamCustomerMappings();
      report.team_assignments_created = teamResult.count;
      if (teamResult.errors) report.errors.push(...teamResult.errors);
      console.log("[Migration] Migration completed!");
      console.log("[Migration] Report:", report);
      return {
        success: true,
        report
      };
    } catch (error) {
      console.error("[Migration] Migration failed:", error);
      return {
        success: false,
        report: {},
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Migrate user_permissions:* pattern
   * OLD: { user_id, customer_id (embedded), role, status }
   * NEW: { user_id, role (global), status } + separate user_customer:* mappings
   */
  async migrateUserPermissions() {
    const errors = [];
    let usersProcessed = 0;
    let membershipsCreated = 0;
    try {
      const userKeys = await getByPrefix("user_permissions:");
      console.log(`[Migration] Found ${userKeys.length} user permission keys`);
      for (const userKey of userKeys) {
        try {
          const user = await get(userKey);
          if (!user) continue;
          const userId = userKey.replace("user_permissions:", "");
          if (user.customer_id && user.customer_id !== "global") {
            console.log(`[Migration] Migrating user ${user.email}: ${user.customer_id}`);
            const membership = {
              user_id: userId,
              customer_id: user.customer_id,
              role: user.role,
              status: user.status || "active",
              created_at: user.created_at || (/* @__PURE__ */ new Date()).toISOString(),
              updated_at: (/* @__PURE__ */ new Date()).toISOString(),
              assigned_by: user.created_by || "system-migration"
            };
            await set(`user_customer:${userId}:${user.customer_id}`, membership);
            membershipsCreated++;
            const cleanUser = { ...user };
            delete cleanUser.customer_id;
            const isTeifiEmployee = user.email?.includes("@teifi.com") || user.email?.includes("@teifi.ca");
            if (!isTeifiEmployee) {
              delete cleanUser.role;
            }
            await set(userKey, cleanUser);
            console.log(`[Migration] Migrated user ${user.email}`);
          }
          usersProcessed++;
        } catch (userError) {
          const errorMsg = `Error migrating user ${userKey}: ${userError}`;
          console.error(`[Migration] ${errorMsg}`);
          errors.push(errorMsg);
        }
      }
      console.log(`[Migration] Processed ${usersProcessed} users, created ${membershipsCreated} memberships`);
      return { count: usersProcessed, memberships: membershipsCreated, errors };
    } catch (error) {
      console.error("[Migration] User permissions migration failed:", error);
      return { count: usersProcessed, memberships: membershipsCreated, errors: [String(error)] };
    }
  }
  /**
   * Build customer member indexes for fast queries
   * Creates: customer_members:{customerId} = [userId1, userId2, ...]
   */
  async buildCustomerMemberIndexes() {
    const errors = [];
    let indexesCreated = 0;
    try {
      const membershipKeys = await getByPrefix("user_customer:");
      console.log(`[Migration] Found ${membershipKeys.length} user-customer mappings`);
      const customerMembers = /* @__PURE__ */ new Map();
      for (const key of membershipKeys) {
        try {
          const membership = await get(key);
          if (!membership || !membership.customer_id) continue;
          const userId = key.split(":")[1];
          const customerId = membership.customer_id;
          if (!customerMembers.has(customerId)) {
            customerMembers.set(customerId, []);
          }
          const members = customerMembers.get(customerId);
          if (!members.includes(userId)) {
            members.push(userId);
          }
        } catch (keyError) {
          const errorMsg = `Error processing ${key}: ${keyError}`;
          console.error(`[Migration] ${errorMsg}`);
          errors.push(errorMsg);
        }
      }
      for (const [customerId, userIds] of customerMembers.entries()) {
        try {
          await set(`customer_members:${customerId}`, userIds);
          indexesCreated++;
          console.log(`[Migration] Created index for customer ${customerId}: ${userIds.length} members`);
        } catch (indexError) {
          const errorMsg = `Error creating index for ${customerId}: ${indexError}`;
          console.error(`[Migration] ${errorMsg}`);
          errors.push(errorMsg);
        }
      }
      console.log(`[Migration] Created ${indexesCreated} customer member indexes`);
      return { count: indexesCreated, errors };
    } catch (error) {
      console.error("[Migration] Index building failed:", error);
      return { count: indexesCreated, errors: [String(error)] };
    }
  }
  /**
   * Create team-customer reverse mappings
   * Creates: team_customer:{teamId} = customerId
   */
  async createTeamCustomerMappings() {
    const errors = [];
    let mappingsCreated = 0;
    try {
      const customerKeys = await getByPrefix("customer:");
      console.log(`[Migration] Found ${customerKeys.length} customer keys`);
      for (const customerKey of customerKeys) {
        try {
          const customerId = customerKey.replace("customer:", "");
          if (customerId.includes(":")) continue;
          const assignedTeams = await get(`customer:${customerId}:assigned_teams`);
          if (!Array.isArray(assignedTeams) || assignedTeams.length === 0) continue;
          const customer = await get(customerKey);
          if (!customer) continue;
          console.log(`[Migration] Processing customer ${customer.name}: ${assignedTeams.length} teams`);
          for (const teamId of assignedTeams) {
            try {
              await set(`team_customer:${teamId}`, customerId);
              const team = await get(`linear_teams:${teamId}`);
              await set(`customer_teams:${customerId}:${teamId}`, {
                customer_id: customerId,
                team_id: teamId,
                team_name: team?.name || "Unknown Team",
                assigned_at: (/* @__PURE__ */ new Date()).toISOString(),
                assigned_by: "system-migration"
              });
              mappingsCreated++;
              console.log(`[Migration] Mapped team ${teamId} -> customer ${customerId}`);
            } catch (teamError) {
              const errorMsg = `Error mapping team ${teamId}: ${teamError}`;
              console.error(`[Migration] ${errorMsg}`);
              errors.push(errorMsg);
            }
          }
        } catch (customerError) {
          const errorMsg = `Error processing customer ${customerKey}: ${customerError}`;
          console.error(`[Migration] ${errorMsg}`);
          errors.push(errorMsg);
        }
      }
      console.log(`[Migration] Created ${mappingsCreated} team-customer mappings`);
      return { count: mappingsCreated, errors };
    } catch (error) {
      console.error("[Migration] Team mapping creation failed:", error);
      return { count: mappingsCreated, errors: [String(error)] };
    }
  }
  /**
   * Validate schema consistency
   */
  async validateSchema() {
    const issues = [];
    try {
      console.log("[Migration] Validating schema consistency...");
      const membershipKeys = await getByPrefix("user_customer:");
      for (const key of membershipKeys) {
        const userId = key.split(":")[1];
        const user = await get(`user_permissions:${userId}`);
        if (!user) {
          issues.push(`Orphaned membership: ${key} - user not found`);
        }
      }
      const indexKeys = await getByPrefix("customer_members:");
      for (const key of indexKeys) {
        const customerId = key.replace("customer_members:", "");
        const customer = await get(`customer:${customerId}`);
        if (!customer) {
          issues.push(`Orphaned index: ${key} - customer not found`);
        }
      }
      const teamCustomerKeys = await getByPrefix("team_customer:");
      for (const key of teamCustomerKeys) {
        const teamId = key.replace("team_customer:", "");
        const customerId = await get(key);
        const team = await get(`linear_teams:${teamId}`);
        if (!team) {
          issues.push(`Invalid team mapping: ${key} - team not found`);
        }
        const customer = await get(`customer:${customerId}`);
        if (!customer) {
          issues.push(`Invalid team mapping: ${key} - customer not found`);
        }
      }
      const valid = issues.length === 0;
      console.log(valid ? "[Migration] Schema validation passed" : `\uFE0F [Migration] Found ${issues.length} issues`);
      return { valid, issues };
    } catch (error) {
      console.error("[Migration] Schema validation failed:", error);
      return { valid: false, issues: [String(error)] };
    }
  }
  /**
   * Get migration status
   */
  async getMigrationStatus() {
    try {
      const userKeys = await getByPrefix("user_permissions:");
      let oldStyleUsers = 0;
      for (const key of userKeys) {
        const user = await get(key);
        if (user?.customer_id && user.customer_id !== "global") {
          oldStyleUsers++;
        }
      }
      const membershipKeys = await getByPrefix("user_customer:");
      const indexKeys = await getByPrefix("customer_members:");
      const teamMappingKeys = await getByPrefix("team_customer:");
      return {
        old_style_users: oldStyleUsers,
        new_style_memberships: membershipKeys.length,
        customer_indexes: indexKeys.length,
        team_mappings: teamMappingKeys.length,
        migration_needed: oldStyleUsers > 0,
        migration_complete: oldStyleUsers === 0 && membershipKeys.length > 0
      };
    } catch (error) {
      console.error("[Migration] Status check failed:", error);
      return { error: String(error) };
    }
  }
};
var migrationService = new MigrationService();

// src/server/routes/systemRoutes.ts
init_kv_store();
var systemRoutes = new Hono();
systemRoutes.post("/auth/user-login", async (c) => {
  try {
    const authHeader = c.req.header("Authorization");
    const accessToken = authHeader?.split(" ")[1];
    if (!accessToken) {
      console.error("[Auth] Missing authorization header");
      return c.json(
        { success: false, error: "No access token provided" },
        { status: 401 }
      );
    }
    const authCheck = await checkAuthPermissions(accessToken);
    if (!authCheck.authorized || !authCheck.user) {
      console.error("[Auth] Authentication failed:", authCheck.error);
      return c.json(
        { success: false, error: authCheck.error || "Authentication failed" },
        { status: 401 }
      );
    }
    const { user, userPermissions, role, isSuperAdmin } = authCheck;
    const email = user.email || "";
    const name = user.user_metadata?.name || user.user_metadata?.full_name || email.split("@")[0];
    const avatar_url = user.user_metadata?.avatar_url || null;
    const userId = user.id;
    let userData = await get(`user:${userId}`);
    const isNewUser = !userData;
    if (userData) {
      userData.name = name;
      userData.avatar_url = avatar_url;
      userData.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
      userData.lastLoginAt = (/* @__PURE__ */ new Date()).toISOString();
      await set(`user:${userId}`, userData);
    } else {
      userData = {
        id: userId,
        email: email.toLowerCase(),
        name,
        avatar_url,
        role,
        // From authHelpers default role logic
        status: "active",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        lastLoginAt: (/* @__PURE__ */ new Date()).toISOString(),
        metadata: { name }
      };
      await set(`user:${userId}`, userData);
      await set(`user:${userId}:customers`, []);
    }
    const finalRole = userData.role;
    const roleDefinition = ENHANCED_ROLE_DEFINITIONS[finalRole];
    const permissions = roleDefinition?.permissions || [];
    return c.json({
      success: true,
      data: {
        user: {
          id: userId,
          email: email.toLowerCase(),
          name,
          avatar_url,
          role: finalRole,
          status: userData.status || "active"
        },
        permission: {
          role: finalRole,
          status: userData.status || "active",
          customer_id: null
          // Schema V2.0: customers handled via user:{id}:customers
        },
        permissions
      },
      message: isNewUser ? "Welcome! Access granted." : "Welcome back!"
    });
  } catch (error) {
    console.error("[Auth] Login error:", error);
    return c.json(
      {
        success: false,
        error: "Authentication failed",
        message: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
});
systemRoutes.get("/health", async (c) => {
  try {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    let kvAvailable = true;
    try {
      await get("_health_check_ping");
      kvAvailable = true;
    } catch (e) {
      kvAvailable = false;
    }
    return c.json({
      success: true,
      message: "Server is healthy",
      timestamp,
      version: "2.1.0",
      environment: "production",
      services: {
        server: "operational",
        kv_store: kvAvailable ? "operational" : "degraded",
        endpoints: {
          auth: "available",
          admin: "available",
          teams: "available",
          issues: "available"
        }
      }
    });
  } catch (error) {
    console.error("[System] Health check failed:", error);
    return c.json(
      {
        success: false,
        message: "Health check failed",
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      },
      { status: 503 }
    );
  }
});
systemRoutes.get("/status", async (c) => {
  return c.json({
    success: true,
    status: "online",
    version: "2.0.0",
    schema: "v2.0",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    endpoints: {
      auth: "available",
      admin: "available",
      teams: "available",
      issues: "available"
    }
  });
});
systemRoutes.get("/debug/kv/:key", async (c) => {
  try {
    const encodedKey = c.req.param("key");
    const key = decodeURIComponent(encodedKey);
    const value = await get(key);
    if (!value) {
      return c.json({
        success: false,
        error: "Key not found"
      }, { status: 404 });
    }
    return c.json({
      success: true,
      key,
      value,
      type: Array.isArray(value) ? "array" : typeof value
    });
  } catch (error) {
    console.error("[Debug] Get KV key error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get KV key"
      },
      { status: 500 }
    );
  }
});
systemRoutes.put("/debug/kv/:key", async (c) => {
  try {
    const encodedKey = c.req.param("key");
    const key = decodeURIComponent(encodedKey);
    const { value } = await c.req.json();
    await set(key, value);
    return c.json({
      success: true,
      key,
      message: "Key updated successfully"
    });
  } catch (error) {
    console.error("[Debug] Update KV key error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to update KV key"
      },
      { status: 500 }
    );
  }
});
systemRoutes.delete("/debug/kv/:key", async (c) => {
  try {
    const encodedKey = c.req.param("key");
    const key = decodeURIComponent(encodedKey);
    await del(key);
    return c.json({
      success: true,
      key,
      message: "Key deleted successfully"
    });
  } catch (error) {
    console.error("[Debug] Delete KV key error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to delete KV key"
      },
      { status: 500 }
    );
  }
});
systemRoutes.get("/debug/kv-all", async (c) => {
  try {
    const prefixes = ["user:", "customer:", "team:", "linear_", "user_permissions:", "admin_"];
    const allKeys = [];
    for (const prefix of prefixes) {
      const keys = await getByPrefix(prefix);
      if (Array.isArray(keys)) {
        allKeys.push(...keys.map((k) => typeof k === "string" ? k : k.key || "").filter(Boolean));
      }
    }
    const uniqueKeys = [...new Set(allKeys)];
    return c.json({
      success: true,
      keys: uniqueKeys,
      count: uniqueKeys.length
    });
  } catch (error) {
    console.error("[Debug] Get all keys error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get all keys"
      },
      { status: 500 }
    );
  }
});
systemRoutes.get("/debug/kv-check", async (c) => {
  try {
    const key = c.req.query("key") || "linear_teams:all";
    const rawValue = await get(key);
    let parsed = rawValue;
    let valueType = typeof rawValue;
    let parseError = null;
    if (typeof rawValue === "string") {
      try {
        parsed = JSON.parse(rawValue);
      } catch (err) {
        parseError = err instanceof Error ? err.message : "Parse error";
        console.error("[Debug] Failed to parse:", err);
      }
    }
    return c.json({
      success: true,
      key,
      exists: !!rawValue,
      rawType: valueType,
      rawPreview: typeof rawValue === "string" ? rawValue.substring(0, 200) + "..." : rawValue,
      parsed: parsed ? {
        type: typeof parsed,
        hasTeams: !!parsed?.teams,
        teamsCount: parsed?.teams?.length || 0,
        teamsPreview: parsed?.teams?.slice(0, 2) || [],
        hasHierarchy: !!parsed?.hierarchy,
        hierarchyCount: parsed?.hierarchy?.length || 0,
        keys: parsed ? Object.keys(parsed) : []
      } : null,
      parseError
    });
  } catch (error) {
    console.error("[Debug] KV check error:", error);
    return c.json({
      success: false,
      error: error instanceof Error ? error.message : "Unknown error"
    }, { status: 500 });
  }
});
systemRoutes.post("/migrate/schema-v2", async (c) => {
  try {
    const authHeader = c.req.header("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return c.json(
        { success: false, error: "Missing authorization header" },
        { status: 401 }
      );
    }
    const accessToken = authHeader.split(" ")[1];
    const { data: { user }, error } = await supabase.auth.getUser(accessToken);
    if (!user || error) {
      return c.json(
        { success: false, error: "Authentication failed" },
        { status: 401 }
      );
    }
    const { isSuperAdminUser: isSuperAdminUser2 } = await Promise.resolve().then(() => (init_authHelpers(), authHelpers_exports));
    const isSuperAdmin = await isSuperAdminUser2(user.email || "");
    if (!isSuperAdmin) {
      return c.json(
        { success: false, error: "Superadmin access required" },
        { status: 403 }
      );
    }
    const result = await migrationService.migrateToSchemaV2();
    if (!result.success) {
      return c.json(
        { success: false, error: result.error },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      message: "Schema v2 migration completed successfully",
      data: result.data
    });
  } catch (error) {
    console.error("[Migration] Migration failed:", error);
    return c.json(
      { success: false, error: "Migration failed" },
      { status: 500 }
    );
  }
});
systemRoutes.get("/migrate/status", async (c) => {
  try {
    const authHeader = c.req.header("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return c.json(
        { success: false, error: "Missing authorization header" },
        { status: 401 }
      );
    }
    const accessToken = authHeader.split(" ")[1];
    const { data: { user }, error } = await supabase.auth.getUser(accessToken);
    if (!user || error) {
      return c.json(
        { success: false, error: "Authentication failed" },
        { status: 401 }
      );
    }
    const migrationStatus = await get("migration_status");
    return c.json({
      success: true,
      data: {
        current_schema: "v2.0",
        migration_completed: true,
        last_migration: migrationStatus || null
      }
    });
  } catch (error) {
    console.error("[Migration] Get status failed:", error);
    return c.json(
      { success: false, error: "Failed to get migration status" },
      { status: 500 }
    );
  }
});
systemRoutes.get("/diagnostics", async (c) => {
  try {
    const authHeader = c.req.header("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return c.json(
        { success: false, error: "Missing authorization header" },
        { status: 401 }
      );
    }
    const accessToken = authHeader.split(" ")[1];
    const authCheck = await checkAuthPermissions(accessToken);
    if (!authCheck.authorized || !authCheck.user) {
      return c.json(
        { success: false, error: "Authentication failed" },
        { status: 401 }
      );
    }
    const { role } = authCheck;
    if (role !== "admin" && role !== "superadmin") {
      return c.json(
        { success: false, error: "Admin access required" },
        { status: 403 }
      );
    }
    const usersCount = await getByPrefix("user:");
    const customersCount = await getByPrefix("customer:");
    const teamsCount = await getByPrefix("team:");
    return c.json({
      success: true,
      data: {
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        kv_storage: {
          users: usersCount.length,
          customers: customersCount.length,
          teams: teamsCount.length
        },
        database: {
          connected: true
        },
        schema_version: "v2.0"
      }
    });
  } catch (error) {
    console.error("[System] Diagnostics failed:", error);
    return c.json(
      { success: false, error: "Failed to get diagnostics" },
      { status: 500 }
    );
  }
});

// src/server/routes/adminRoutes.ts
init_kv_store();
init_authHelpers();
import { Hono as Hono2 } from "hono";

// src/server/methods/userMethodsV2.ts
init_kv_store();
var UserMethodsV2 = class {
  /**
   * Schema v2.0: Get all users with customer memberships
   * OPTIMIZED: Parallel loading with batch queries
   */
  static async getAllUsers(supabase4) {
    try {
      console.log("[UserMethods.v2] Fetching all users (OPTIMIZED)...");
      const startTime = Date.now();
      const { data: authUsers, error: authError } = await supabase4.auth.admin.listUsers();
      if (authError) {
        console.error(
          "[UserMethods.v2] Auth users fetch failed:",
          authError
        );
        return {
          success: false,
          error: `Failed to fetch auth users: ${authError.message}`
        };
      }
      console.log(
        `[UserMethods.v2] Found ${authUsers.users?.length || 0} users in Supabase Auth`
      );
      const superadminEmails = await get("superadmin:emails") || [];
      console.log(`[UserMethods.v2] Loaded ${superadminEmails.length} superadmin emails`);
      const userIds = (authUsers.users || []).map((u) => u.id);
      console.log(`[UserMethods.v2] Batch fetching ${userIds.length} user objects...`);
      const [userObjects, customerLists] = await Promise.all([
        // Fetch all user objects in parallel
        Promise.all(
          userIds.map(async (userId) => {
            try {
              const userObj = await get(`user:${userId}`);
              return { userId, userObj };
            } catch (err) {
              console.warn(`[UserMethods.v2] Failed to fetch user:${userId}:`, err);
              return { userId, userObj: null };
            }
          })
        ),
        // Fetch all customer lists in parallel
        Promise.all(
          userIds.map(async (userId) => {
            try {
              const customerIds = await get(`user:${userId}:customers`) || [];
              return { userId, customerIds };
            } catch (err) {
              console.warn(`[UserMethods.v2] Failed to fetch user:${userId}:customers:`, err);
              return { userId, customerIds: [] };
            }
          })
        )
      ]);
      const userObjMap = new Map(userObjects.map(({ userId, userObj }) => [userId, userObj]));
      const customerListMap = new Map(customerLists.map(({ userId, customerIds }) => [userId, customerIds]));
      console.log(`[UserMethods.v2] Batch fetch complete. Processing users...`);
      const allCustomerIds = /* @__PURE__ */ new Set();
      customerLists.forEach(({ customerIds }) => {
        customerIds.forEach((id) => allCustomerIds.add(id));
      });
      console.log(`[UserMethods.v2] Batch fetching ${allCustomerIds.size} unique customers...`);
      const customerDataList = await Promise.all(
        Array.from(allCustomerIds).map(async (customerId) => {
          try {
            const customer = await get(`customer:${customerId}`);
            return { customerId, customer };
          } catch (err) {
            console.warn(`[UserMethods.v2] Failed to fetch customer:${customerId}:`, err);
            return { customerId, customer: null };
          }
        })
      );
      const customerDataMap = new Map(
        customerDataList.map(({ customerId, customer }) => [customerId, customer])
      );
      console.log(`[UserMethods.v2] Customer data loaded. Building user list...`);
      const users = [];
      for (const authUser of authUsers.users || []) {
        try {
          const userId = authUser.id;
          const email = authUser.email || "";
          let userObj = userObjMap.get(userId);
          const isSuperAdmin = superadminEmails.includes(email.toLowerCase());
          const isTeifiUser2 = email.includes("@teifi.com") || email.includes("@teifi.ca");
          if (!userObj) {
            const defaultRole = isSuperAdmin ? "superadmin" : isTeifiUser2 ? "admin" : "viewer";
            const defaultStatus = "active";
            userObj = {
              id: userId,
              email,
              role: defaultRole,
              status: defaultStatus,
              createdAt: authUser.created_at,
              updatedAt: authUser.created_at,
              metadata: {
                name: authUser.user_metadata?.name || email.split("@")[0] || "User"
              }
            };
            await set(`user:${userId}`, userObj);
            await set(`user:${userId}:customers`, []);
          }
          if (isSuperAdmin && userObj.role !== "superadmin") {
            userObj.role = "superadmin";
            await set(`user:${userId}`, userObj);
          }
          const customerIds = customerListMap.get(userId) || [];
          const memberships = await Promise.all(
            customerIds.map(async (customerId) => {
              try {
                const membership = await get(
                  `customer:${customerId}:member:${userId}`
                );
                return { customerId, membership };
              } catch (err) {
                console.warn(
                  `[UserMethods.v2] Failed to fetch membership for user:${userId}, customer:${customerId}:`,
                  err
                );
                return { customerId, membership: null };
              }
            })
          );
          const membershipMap = new Map(
            memberships.map(({ customerId, membership }) => [customerId, membership])
          );
          const customers = [];
          for (const customerId of customerIds) {
            const customer = customerDataMap.get(customerId);
            if (customer) {
              const membership = membershipMap.get(customerId);
              customers.push({
                id: customer.id,
                name: customer.name,
                status: customer.status,
                assignedAt: membership?.assignedAt || membership?.assigned_at
                // Schema V2.0: camelCase with backward compat
              });
            }
          }
          users.push({
            id: userId,
            email,
            name: userObj.metadata?.name || email.split("@")[0] || "User",
            role: userObj.role,
            status: userObj.status,
            createdAt: authUser.created_at,
            // Schema V2.0: camelCase
            updatedAt: userObj.updatedAt || userObj.updated_at || authUser.created_at,
            // Schema V2.0: camelCase with backward compat
            lastSignInAt: authUser.last_sign_in_at,
            // Schema V2.0: camelCase
            customers,
            // Schema v2.0: Array of customers
            customerCount: customers.length
            // Schema V2.0: camelCase
          });
        } catch (userError) {
          console.warn(
            `[UserMethods.v2] Error processing user ${authUser.id}:`,
            userError
          );
        }
      }
      console.log(
        `[UserMethods.v2] Processed ${users.length} users with customer memberships in ${Date.now() - startTime}ms`
      );
      return {
        success: true,
        data: {
          users,
          count: users.length
        }
      };
    } catch (error) {
      console.error(
        "[UserMethods.v2] Get all users error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error occurred"
      };
    }
  }
  /**
   * Schema v2.0: Get single user by ID
   */
  static async getUserById(userId, supabase4) {
    try {
      console.log(`[UserMethods.v2] Fetching user: ${userId}`);
      const { data: authUser, error: authError } = await supabase4.auth.admin.getUserById(userId);
      if (authError || !authUser.user) {
        console.error(
          "[UserMethods.v2] User not found in auth:",
          authError
        );
        return {
          success: false,
          error: "User not found"
        };
      }
      const email = authUser.user.email || "";
      let userObj = await get(`user:${userId}`);
      const superadminEmails = await get("superadmin:emails") || [];
      const isSuperAdmin = superadminEmails.includes(
        email.toLowerCase()
      );
      const isTeifiUser2 = email.includes("@teifi.com") || email.includes("@teifi.ca");
      const defaultRole = isSuperAdmin ? "superadmin" : isTeifiUser2 ? "admin" : "viewer";
      const defaultStatus = isSuperAdmin || isTeifiUser2 ? "active" : "pending";
      if (!userObj) {
        userObj = {
          id: userId,
          email,
          role: defaultRole,
          status: defaultStatus,
          createdAt: authUser.user.created_at,
          // Schema V2.0: camelCase
          updatedAt: authUser.user.created_at,
          // Schema V2.0: camelCase
          metadata: {
            name: authUser.user.user_metadata?.name || email.split("@")[0] || "User"
          }
        };
        await set(`user:${userId}`, userObj);
        await set(`user:${userId}:customers`, []);
      }
      if (isSuperAdmin) {
        userObj.role = "superadmin";
        await set(`user:${userId}`, userObj);
      }
      const customerIds = await get(`user:${userId}:customers`) || [];
      const customers = [];
      for (const customerId of customerIds) {
        const customer = await get(`customer:${customerId}`);
        if (customer) {
          const membership = await get(
            `customer:${customerId}:member:${userId}`
          );
          customers.push({
            id: customer.id,
            name: customer.name,
            status: customer.status,
            assignedAt: membership?.assignedAt || membership?.assigned_at
            // Schema V2.0: camelCase with backward compat
          });
        }
      }
      const user = {
        id: userId,
        email,
        name: userObj.metadata?.name || email.split("@")[0] || "User",
        role: userObj.role,
        status: userObj.status,
        createdAt: authUser.user.created_at,
        // Schema V2.0: camelCase
        updatedAt: userObj.updatedAt || userObj.updated_at || authUser.user.created_at,
        // Schema V2.0: camelCase with backward compat
        lastSignInAt: authUser.user.last_sign_in_at,
        // Schema V2.0: camelCase
        customers,
        customerCount: customers.length
        // Schema V2.0: camelCase
      };
      console.log(
        `[UserMethods.v2] Retrieved user with ${customers.length} customers`
      );
      return {
        success: true,
        data: { user }
      };
    } catch (error) {
      console.error(
        "[UserMethods.v2] Get user by ID error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch user"
      };
    }
  }
  /**
   * Schema v2.0: Create new user
   */
  static async createUser(userData, supabase4, createdBy) {
    try {
      console.log(
        `[UserMethods.v2] Creating user: ${userData.email}`
      );
      if (!userData.email || !userData.email.trim()) {
        return {
          success: false,
          error: "Email is required"
        };
      }
      const email = userData.email.trim().toLowerCase();
      const { data: authData, error: authError } = await supabase4.auth.admin.createUser({
        email,
        password: userData.password,
        user_metadata: {
          name: userData.name || email.split("@")[0]
        },
        email_confirm: true
        // Auto-confirm since no email server configured
      });
      if (authError || !authData.user) {
        console.error(
          "[UserMethods.v2] Failed to create user in auth:",
          authError
        );
        return {
          success: false,
          error: authError?.message || "Failed to create user in authentication system"
        };
      }
      const userId = authData.user.id;
      const userRole = userData.role || "viewer";
      const userObj = {
        id: userId,
        email,
        role: userRole,
        status: userData.status || "active",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        // Schema V2.0: camelCase
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        // Schema V2.0: camelCase
        createdBy,
        // Schema V2.0: camelCase
        metadata: {
          name: userData.name || email.split("@")[0]
        }
      };
      await set(`user:${userId}`, userObj);
      const customerIds = userData.customers || [];
      await set(`user:${userId}:customers`, customerIds);
      if (customerIds.length > 0) {
        console.log(`[UserMethods.v2] Assigning user to ${customerIds.length} customers`);
        for (const customerId of customerIds) {
          const currentMembers = await get(`customer:${customerId}:members`) || [];
          if (!currentMembers.includes(userId)) {
            currentMembers.push(userId);
            await set(`customer:${customerId}:members`, currentMembers);
            await set(`customer:${customerId}:member:${userId}`, {
              userId,
              customerId,
              assignedAt: (/* @__PURE__ */ new Date()).toISOString(),
              assignedBy: createdBy,
              role: userRole
            });
            console.log(`  \u2192 Assigned to customer: ${customerId}`);
          }
        }
      }
      if (userRole === "superadmin") {
        const currentSuperadmins = await get("superadmin:emails") || [];
        if (!currentSuperadmins.includes(email)) {
          console.log(`  \u2192 Adding ${email} to superadmin list`);
          currentSuperadmins.push(email);
          await set("superadmin:emails", currentSuperadmins);
        }
      }
      console.log(
        `[UserMethods.v2] User created successfully: ${userId}`
      );
      return {
        success: true,
        data: {
          user: {
            id: userId,
            email,
            name: userObj.metadata.name,
            role: userObj.role,
            status: userObj.status,
            customers: customerIds,
            customerCount: customerIds.length
          }
        }
      };
    } catch (error) {
      console.error(
        "[UserMethods.v2] Create user error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to create user"
      };
    }
  }
  /**
   * Schema v2.0: Update user (role, status, metadata)
   * FIXED: Now updates Supabase Auth metadata so role persists on login
   */
  static async updateUser(userId, updates, updatedBy, supabase4) {
    try {
      console.log(
        `[UserMethods.v2] Updating user: ${userId}`,
        updates
      );
      let userObj = await get(`user:${userId}`);
      if (!userObj) {
        return {
          success: false,
          error: "User not found"
        };
      }
      const authUpdates = {};
      if (updates.name) {
        userObj.metadata = userObj.metadata || {};
        userObj.metadata.name = updates.name.trim();
        authUpdates.user_metadata = {
          name: updates.name.trim()
        };
      }
      const oldRole = userObj.role;
      if (updates.role) {
        console.log(
          `  \u2192 Role change: ${userObj.role} \u2192 ${updates.role}`
        );
        userObj.role = updates.role;
        authUpdates.user_metadata = authUpdates.user_metadata || {};
        authUpdates.user_metadata.role = updates.role;
      }
      if (updates.status) {
        console.log(
          `  \u2192 Status change: ${userObj.status} \u2192 ${updates.status}`
        );
        userObj.status = updates.status;
      }
      userObj.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
      userObj.updatedBy = updatedBy;
      await set(`user:${userId}`, userObj);
      if (updates.role && oldRole !== updates.role) {
        const currentSuperadmins = await get("superadmin:emails") || [];
        const userEmail = userObj.email?.toLowerCase().trim();
        if (updates.role === "superadmin" && !currentSuperadmins.includes(userEmail)) {
          console.log(
            `  \u2192 Adding ${userEmail} to superadmin list`
          );
          currentSuperadmins.push(userEmail);
          await set("superadmin:emails", currentSuperadmins);
        } else if (updates.role !== "superadmin" && oldRole === "superadmin" && currentSuperadmins.includes(userEmail)) {
          console.log(
            `  \u2192 Removing ${userEmail} from superadmin list`
          );
          const updatedList = currentSuperadmins.filter(
            (email) => email !== userEmail
          );
          await set("superadmin:emails", updatedList);
        }
      }
      if (supabase4 && Object.keys(authUpdates).length > 0) {
        console.log(
          `  \u2192 Updating Supabase Auth metadata:`,
          authUpdates
        );
        const { error: authError } = await supabase4.auth.admin.updateUserById(
          userId,
          authUpdates
        );
        if (authError) {
          console.error(
            `[UserMethods.v2] Failed to update Supabase Auth:`,
            authError
          );
        } else {
          console.log(
            `[UserMethods.v2] Supabase Auth metadata updated`
          );
        }
      }
      console.log(`[UserMethods.v2] User updated: ${userId}`);
      return {
        success: true,
        data: {
          message: "User updated successfully",
          user: userObj
        }
      };
    } catch (error) {
      console.error(
        "[UserMethods.v2] Update user error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to update user"
      };
    }
  }
  /**
   * Schema v2.0: Delete user and cleanup all memberships
   */
  static async deleteUser(userId, supabase4) {
    try {
      console.log(
        `\uFE0F [UserMethods.v2] Deleting user: ${userId}`
      );
      const customerIds = await get(`user:${userId}:customers`) || [];
      for (const customerId of customerIds) {
        const members = await get(`customer:${customerId}:members`) || [];
        const updatedMembers = members.filter(
          (id) => id !== userId
        );
        await set(
          `customer:${customerId}:members`,
          updatedMembers
        );
        await del(`customer:${customerId}:member:${userId}`);
        console.log(` Removed from customer: ${customerId}`);
      }
      const userObj = await get(`user:${userId}`);
      const userEmail = userObj?.email?.toLowerCase().trim();
      const { error: deleteError } = await supabase4.auth.admin.deleteUser(userId);
      if (deleteError) {
        console.warn(
          "\uFE0F [UserMethods.v2] Failed to delete from auth (may already be deleted):",
          deleteError
        );
      }
      await del(`user:${userId}`);
      await del(`user:${userId}:customers`);
      if (userObj?.role === "superadmin" && userEmail) {
        const currentSuperadmins = await get("superadmin:emails") || [];
        if (currentSuperadmins.includes(userEmail)) {
          console.log(
            `  \u2192 Removing ${userEmail} from superadmin list`
          );
          const updatedList = currentSuperadmins.filter(
            (email) => email !== userEmail
          );
          await set("superadmin:emails", updatedList);
        }
      }
      console.log(
        `[UserMethods.v2] User ${userId} deleted successfully`
      );
      return {
        success: true,
        data: {
          message: "User deleted successfully",
          removed_from_customers: customerIds.length
        }
      };
    } catch (error) {
      console.error(
        "[UserMethods.v2] Delete user error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to delete user"
      };
    }
  }
  /**
   * Schema v2.0: Assign user to customer
   */
  static async assignUserToCustomer(userId, customerId, assignedBy) {
    try {
      console.log(
        `[UserMethods.v2] Assigning user ${userId} to customer ${customerId}`
      );
      const userObj = await get(`user:${userId}`);
      if (!userObj) {
        return {
          success: false,
          error: "User not found"
        };
      }
      const customer = await get(`customer:${customerId}`);
      if (!customer) {
        return {
          success: false,
          error: "Customer not found"
        };
      }
      const userCustomers = await get(`user:${userId}:customers`) || [];
      if (!userCustomers.includes(customerId)) {
        userCustomers.push(customerId);
        await set(`user:${userId}:customers`, userCustomers);
      }
      const customerMembers = await get(`customer:${customerId}:members`) || [];
      if (!customerMembers.includes(userId)) {
        customerMembers.push(userId);
        await set(
          `customer:${customerId}:members`,
          customerMembers
        );
      }
      const membership = {
        userId,
        customerId,
        assignedAt: (/* @__PURE__ */ new Date()).toISOString(),
        assignedBy
      };
      await set(
        `customer:${customerId}:member:${userId}`,
        membership
      );
      console.log(
        `[UserMethods.v2] User assigned to customer successfully`
      );
      return {
        success: true,
        data: {
          message: "User assigned to customer successfully",
          membership
        }
      };
    } catch (error) {
      console.error(
        "[UserMethods.v2] Assign user to customer error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to assign user to customer"
      };
    }
  }
  /**
   * Schema V2.0: Remove user from customer
   * FIXED: Now includes team membership cleanup
   */
  static async removeUserFromCustomer(userId, customerId, removedBy) {
    try {
      console.log(
        `[UserMethods.v2] Removing user ${userId} from customer ${customerId}`
      );
      const teamIds = await get(`customer:${customerId}:teams`) || [];
      let teamsCleanedCount = 0;
      console.log(
        ` Cleaning up ${teamIds.length} potential team memberships`
      );
      for (const teamId of teamIds) {
        const teamMembersKey = `customer:${customerId}:team:${teamId}:members`;
        const teamMembers = await get(teamMembersKey) || [];
        if (teamMembers.includes(userId)) {
          const updatedMembers = teamMembers.filter(
            (id) => id !== userId
          );
          await set(teamMembersKey, updatedMembers);
          teamsCleanedCount++;
          console.log(`   Removed from team: ${teamId}`);
        }
      }
      console.log(
        ` Cleaned up ${teamsCleanedCount} team memberships`
      );
      const userCustomers = await get(`user:${userId}:customers`) || [];
      const updatedUserCustomers = userCustomers.filter(
        (id) => id !== customerId
      );
      await set(
        `user:${userId}:customers`,
        updatedUserCustomers
      );
      const customerMembers = await get(`customer:${customerId}:members`) || [];
      const updatedCustomerMembers = customerMembers.filter(
        (id) => id !== userId
      );
      await set(
        `customer:${customerId}:members`,
        updatedCustomerMembers
      );
      await del(`customer:${customerId}:member:${userId}`);
      console.log(
        `[UserMethods.v2] User removed from customer successfully (${teamsCleanedCount} teams cleaned)`
      );
      return {
        success: true,
        data: {
          message: "User removed from customer successfully",
          teamsCleanedUp: teamsCleanedCount
        }
      };
    } catch (error) {
      console.error(
        "[UserMethods.v2] Remove user from customer error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to remove user from customer"
      };
    }
  }
  /**
   * Schema V2.0: Sync customer assignments for user
   * Handles adding new customers and removing old ones
   * Also cleans up team memberships when removing customer
   */
  static async syncCustomerAssignments(userId, newCustomerIds, syncedBy) {
    try {
      console.log(
        `[UserMethods.v2] Syncing customer assignments for user: ${userId}`
      );
      console.log(`  New customer IDs:`, newCustomerIds);
      const currentCustomerIds = await get(`user:${userId}:customers`) || [];
      console.log(
        `  Current customer IDs:`,
        currentCustomerIds
      );
      const customersToAdd = newCustomerIds.filter(
        (id) => !currentCustomerIds.includes(id)
      );
      const customersToRemove = currentCustomerIds.filter(
        (id) => !newCustomerIds.includes(id)
      );
      console.log(` Adding customers:`, customersToAdd);
      console.log(` Removing customers:`, customersToRemove);
      let addedCount = 0;
      let removedCount = 0;
      let teamsCleanedCount = 0;
      for (const customerId of customersToAdd) {
        const result = await this.assignUserToCustomer(
          userId,
          customerId,
          syncedBy
        );
        if (result.success) {
          addedCount++;
        } else {
          console.warn(
            `\uFE0F Failed to add customer ${customerId}:`,
            result.error
          );
        }
      }
      for (const customerId of customersToRemove) {
        const teamIds = await get(`customer:${customerId}:teams`) || [];
        console.log(
          ` Cleaning up ${teamIds.length} team memberships for customer ${customerId}`
        );
        for (const teamId of teamIds) {
          const teamMembersKey = `customer:${customerId}:team:${teamId}:members`;
          const teamMembers = await get(teamMembersKey) || [];
          if (teamMembers.includes(userId)) {
            const updatedMembers = teamMembers.filter(
              (id) => id !== userId
            );
            await set(teamMembersKey, updatedMembers);
            teamsCleanedCount++;
            console.log(`   Removed from team: ${teamId}`);
          }
        }
        const result = await this.removeUserFromCustomer(
          userId,
          customerId,
          syncedBy
        );
        if (result.success) {
          removedCount++;
        } else {
          console.warn(
            `\uFE0F Failed to remove customer ${customerId}:`,
            result.error
          );
        }
      }
      console.log(`[UserMethods.v2] Customer sync complete:`);
      console.log(` Added: ${addedCount} customers`);
      console.log(` Removed: ${removedCount} customers`);
      console.log(
        ` Cleaned up: ${teamsCleanedCount} team memberships`
      );
      return {
        success: true,
        data: {
          added: addedCount,
          removed: removedCount,
          teamsCleanedUp: teamsCleanedCount,
          finalCustomers: newCustomerIds
        }
      };
    } catch (error) {
      console.error(
        "[UserMethods.v2] Sync customer assignments error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to sync customer assignments"
      };
    }
  }
  /**
   * Schema v2.0: Get user's customers
   */
  static async getUserCustomers(userId) {
    try {
      console.log(
        `[UserMethods.v2] Getting customers for user: ${userId}`
      );
      const customerIds = await get(`user:${userId}:customers`) || [];
      const customers = [];
      for (const customerId of customerIds) {
        const customer = await get(`customer:${customerId}`);
        if (customer) {
          const membership = await get(
            `customer:${customerId}:member:${userId}`
          );
          customers.push({
            ...customer,
            membership
          });
        }
      }
      console.log(
        `[UserMethods.v2] Found ${customers.length} customers for user`
      );
      return {
        success: true,
        data: {
          customers,
          count: customers.length
        }
      };
    } catch (error) {
      console.error(
        "[UserMethods.v2] Get user customers error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get user customers"
      };
    }
  }
};

// src/server/methods/customerMethodsV2.ts
init_kv_store();
var CustomerMethodsV2 = class {
  /**
   *Schema v2.0: Get all customers with stats
   */
  async getAllCustomers() {
    try {
      console.log(
        "[CustomerMethodsV2] Fetching all customers..."
      );
      const customerKeys = await getByPrefix("customer:");
      console.log(
        `[CustomerMethodsV2] Found ${customerKeys.length} customer keys`
      );
      const customers = [];
      const processedIds = /* @__PURE__ */ new Set();
      for (const key of customerKeys) {
        try {
          const customerId = key.replace("customer:", "");
          if (customerId.includes(":")) {
            continue;
          }
          if (processedIds.has(customerId)) {
            continue;
          }
          processedIds.add(customerId);
          const customer = await get(key);
          if (!customer || !customer.id) {
            console.warn(
              `\uFE0F [CustomerMethodsV2] Invalid customer at ${key}`
            );
            continue;
          }
          const memberIds = await get(`customer:${customerId}:members`) || [];
          const teamIds = await get(`customer:${customerId}:teams`) || [];
          customers.push({
            id: customer.id,
            name: customer.name,
            description: customer.description || "",
            contactEmail: customer.contactEmail || customer.contact_email,
            google_domain: customer.google_domain,
            project: customer.project,
            epic: customer.epic,
            environment: customer.environment || "UAT",
            status: customer.status || "active",
            createdAt: customer.createdAt || customer.created_at || (/* @__PURE__ */ new Date()).toISOString(),
            //Schema V2.0: camelCase
            updatedAt: customer.updatedAt || customer.updated_at || (/* @__PURE__ */ new Date()).toISOString(),
            //Schema V2.0: camelCase
            usersCount: memberIds.length,
            //Schema V2.0: camelCase
            teamsCount: teamIds.length
            //Schema V2.0: camelCase
          });
        } catch (error) {
          console.warn(
            `\uFE0F [CustomerMethodsV2] Error processing customer ${key}:`,
            error
          );
        }
      }
      console.log(
        `[CustomerMethodsV2] Processed ${customers.length} customers`
      );
      return {
        success: true,
        data: {
          customers,
          count: customers.length
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Get all customers error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch customers"
      };
    }
  }
  /**
   *Schema v2.0: Get customer by ID with full details
   */
  async getCustomerById(customerId) {
    try {
      console.log(
        `[CustomerMethodsV2] Fetching customer: ${customerId}`
      );
      const customer = await get(`customer:${customerId}`);
      if (!customer) {
        return {
          success: false,
          error: "Customer not found"
        };
      }
      const memberIds = await get(`customer:${customerId}:members`) || [];
      const members = [];
      for (const userId of memberIds) {
        const membership = await get(
          `customer:${customerId}:member:${userId}`
        );
        const userObj = await get(`user:${userId}`);
        if (userObj && membership) {
          members.push({
            userId,
            //Schema V2.0: camelCase
            email: userObj.email,
            name: userObj.metadata?.name || userObj.email.split("@")[0],
            role: userObj.role,
            status: userObj.status,
            assignedAt: membership.assignedAt || membership.assigned_at,
            //Schema V2.0: camelCase with backward compat
            assignedBy: membership.assignedBy || membership.assigned_by
            //Schema V2.0: camelCase with backward compat
          });
        }
      }
      const teamIds = await get(`customer:${customerId}:teams`) || [];
      const teams = [];
      for (const teamId of teamIds) {
        const team = await get(`linear_teams:${teamId}`);
        if (team) {
          teams.push({
            id: teamId,
            name: team.name,
            key: team.key,
            description: team.description
          });
        }
      }
      return {
        success: true,
        data: {
          customer: {
            ...customer,
            members,
            teams,
            usersCount: members.length,
            //Schema V2.0: camelCase
            teamsCount: teams.length
            //Schema V2.0: camelCase
          }
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Get customer error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch customer"
      };
    }
  }
  /**
   *Schema v2.0: Create new customer
   */
  async createCustomer(customerData, createdBy) {
    try {
      console.log(
        `[CustomerMethodsV2] Creating customer: ${customerData.name}`
      );
      if (!customerData.name || !customerData.name.trim()) {
        return {
          success: false,
          error: "Customer name is required"
        };
      }
      const customerId = crypto.randomUUID();
      const customer = {
        id: customerId,
        name: customerData.name.trim(),
        description: customerData.description?.trim() || "",
        contactEmail: customerData.contactEmail?.trim() || null,
        google_domain: customerData.google_domain?.trim() || null,
        project: customerData.project?.trim() || null,
        epic: customerData.epic?.trim() || null,
        environment: customerData.environment || "UAT",
        status: customerData.status || "active",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        //Schema V2.0: camelCase
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        //Schema V2.0: camelCase
        createdBy
        //Schema V2.0: camelCase
      };
      await set(`customer:${customerId}`, customer);
      await set(`customer:${customerId}:members`, []);
      await set(`customer:${customerId}:teams`, []);
      console.log(
        `[CustomerMethodsV2] Customer created: ${customerId}`
      );
      return {
        success: true,
        data: {
          customer: {
            ...customer,
            usersCount: 0,
            //Schema V2.0: camelCase
            teamsCount: 0
            //Schema V2.0: camelCase
          }
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Create customer error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to create customer"
      };
    }
  }
  /**
   *Schema v2.0: Update customer
   */
  async updateCustomer(customerId, updates, updatedBy) {
    try {
      console.log(
        `[CustomerMethodsV2] Updating customer: ${customerId}`
      );
      const customer = await get(`customer:${customerId}`);
      if (!customer) {
        return {
          success: false,
          error: "Customer not found"
        };
      }
      const updatedCustomer = {
        ...customer,
        ...Object.fromEntries(
          Object.entries(updates).filter(
            ([_, v]) => v !== void 0
          )
        ),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        //Schema V2.0: camelCase
        updatedBy
        //Schema V2.0: camelCase
      };
      await set(`customer:${customerId}`, updatedCustomer);
      console.log(
        `[CustomerMethodsV2] Customer updated: ${customerId}`
      );
      return {
        success: true,
        data: {
          customer: updatedCustomer,
          message: "Customer updated successfully"
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Update customer error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to update customer"
      };
    }
  }
  /**
   *Schema v2.0: Delete customer and cleanup all relationships
   */
  async deleteCustomer(customerId) {
    try {
      console.log(
        `[CustomerMethodsV2] Deleting customer: ${customerId}`
      );
      const memberIds = await get(`customer:${customerId}:members`) || [];
      for (const userId of memberIds) {
        const userCustomers = await get(`user:${userId}:customers`) || [];
        const updatedUserCustomers = userCustomers.filter(
          (id) => id !== customerId
        );
        await set(
          `user:${userId}:customers`,
          updatedUserCustomers
        );
        await del(`customer:${customerId}:member:${userId}`);
        console.log(` Removed from user: ${userId}`);
      }
      await del(`customer:${customerId}`);
      await del(`customer:${customerId}:members`);
      await del(`customer:${customerId}:teams`);
      console.log(
        `[CustomerMethodsV2] Customer deleted: ${customerId}`
      );
      return {
        success: true,
        data: {
          message: "Customer deleted successfully",
          removedMembers: memberIds.length
          //Schema V2.0: camelCase
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Delete customer error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to delete customer"
      };
    }
  }
  /**
   *Schema v2.0: Get customer members
   */
  async getCustomerMembers(customerId) {
    try {
      console.log(
        `[CustomerMethodsV2] Getting members for customer: ${customerId}`
      );
      const customer = await get(`customer:${customerId}`);
      if (!customer) {
        return {
          success: false,
          error: "Customer not found"
        };
      }
      const memberIds = await get(`customer:${customerId}:members`) || [];
      const members = [];
      for (const userId of memberIds) {
        const userObj = await get(`user:${userId}`);
        const membership = await get(
          `customer:${customerId}:member:${userId}`
        );
        if (userObj) {
          members.push({
            userId,
            //Schema V2.0: camelCase
            email: userObj.email,
            name: userObj.metadata?.name || userObj.email.split("@")[0],
            role: userObj.role,
            status: userObj.status,
            assignedAt: membership?.assignedAt || userObj.createdAt,
            //Schema V2.0: camelCase
            assignedBy: membership?.assignedBy
            //Schema V2.0: camelCase
          });
        }
      }
      console.log(
        `[CustomerMethodsV2] Found ${members.length} members`
      );
      return {
        success: true,
        data: {
          members,
          count: members.length
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Get customer members error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch customer members"
      };
    }
  }
  /**
   *Schema v2.0: Get customer teams with mapping from Linear cache
   */
  async getCustomerTeams(customerId) {
    try {
      console.log(
        `[CustomerMethodsV2] Getting teams for customer: ${customerId}`
      );
      const customer = await get(`customer:${customerId}`);
      if (!customer) {
        return {
          success: false,
          error: "Customer not found"
        };
      }
      const teamIds = await get(`customer:${customerId}:teams`) || [];
      console.log(
        `[CustomerMethodsV2] Customer team IDs:`,
        teamIds
      );
      const linearCache = await get("linear_teams:all");
      console.log(
        `[CustomerMethodsV2] Linear cache loaded:`,
        linearCache ? "YES" : "NO"
      );
      const teams = [];
      if (linearCache && linearCache.teams && Array.isArray(linearCache.teams)) {
        console.log(
          `[CustomerMethodsV2] Found ${linearCache.teams.length} teams in Linear cache`
        );
        const teamMap = /* @__PURE__ */ new Map();
        const flattenTeams = (teamList) => {
          for (const team of teamList) {
            teamMap.set(team.id, team);
            if (team.children && team.children.length > 0) {
              flattenTeams(team.children);
            }
          }
        };
        flattenTeams(linearCache.teams);
        console.log(
          `[CustomerMethodsV2] Built team map with ${teamMap.size} entries`
        );
        for (const teamId of teamIds) {
          const team = teamMap.get(teamId);
          if (team) {
            console.log(
              `[CustomerMethodsV2] Mapped team ${teamId}: ${team.name} (${team.key})`
            );
            teams.push({
              id: team.id,
              name: team.name,
              key: team.key,
              description: team.description || `${team.name} team`,
              state: "active",
              color: team.color,
              icon: team.icon,
              parentId: team.parent?.id,
              //Schema V2.0: camelCase
              parentName: team.parent?.name,
              //Schema V2.0: camelCase
              parentKey: team.parent?.key
              //Schema V2.0: camelCase
            });
          } else {
            console.warn(
              `\uFE0F [CustomerMethodsV2] Team ${teamId} not found in Linear cache - using fallback`
            );
            teams.push({
              id: teamId,
              name: `Team ${teamId.substring(0, 8)}`,
              key: teamId.substring(0, 8),
              description: "Team not synced from Linear. Please sync teams.",
              state: "unknown"
            });
          }
        }
      } else {
        console.warn(
          `\uFE0F [CustomerMethodsV2] No Linear cache found - using fallback names`
        );
        for (const teamId of teamIds) {
          teams.push({
            id: teamId,
            name: `Team ${teamId.substring(0, 8)}`,
            key: teamId.substring(0, 8),
            description: "Linear cache not available. Please sync teams in Admin \u2192 Teams \u2192 Linear Sync.",
            state: "unknown"
          });
        }
      }
      console.log(
        `[CustomerMethodsV2] Returning ${teams.length} teams:`,
        teams.map((t) => ({
          id: t.id,
          name: t.name,
          key: t.key
        }))
      );
      return {
        success: true,
        data: {
          teams,
          count: teams.length
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Get customer teams error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch customer teams"
      };
    }
  }
  /**
   *Schema v2.0: Assign team to customer
   *
   *FIX: Validates team existence with 3-tier fallback:
   * 1. Try individual team cache (linear_teams:${teamId})
   * 2. Try hierarchical cache (linear_teams:all)
   * 3. Fallback to Linear API (if not in cache)
   */
  async assignTeamToCustomer(customerId, linearTeamId, assignedBy) {
    try {
      console.log(
        `[CustomerMethodsV2] Assigning team ${linearTeamId} to customer ${customerId}`
      );
      const customer = await get(`customer:${customerId}`);
      if (!customer) {
        return {
          success: false,
          error: "Customer not found"
        };
      }
      let teamExists = false;
      let teamName = linearTeamId;
      let team = await get(`linear_teams:${linearTeamId}`);
      if (typeof team === "string") {
        try {
          team = JSON.parse(team);
        } catch (err) {
          console.warn(
            `\uFE0F [CustomerMethodsV2] Failed to parse team ${linearTeamId} from cache`
          );
          team = null;
        }
      }
      if (team?.id === linearTeamId) {
        teamExists = true;
        teamName = team.name || linearTeamId;
        console.log(
          `[CustomerMethodsV2] Team found in individual cache: ${teamName}`
        );
      } else {
        const linearCache = await get("linear_teams:all");
        if (linearCache && linearCache.teams && Array.isArray(linearCache.teams)) {
          const findTeam = (teamList) => {
            for (const t of teamList) {
              if (t.id === linearTeamId) {
                return t;
              }
              if (t.children && t.children.length > 0) {
                const found = findTeam(t.children);
                if (found) return found;
              }
            }
            return null;
          };
          const foundTeam = findTeam(linearCache.teams);
          if (foundTeam) {
            teamExists = true;
            teamName = foundTeam.name || linearTeamId;
            console.log(
              `[CustomerMethodsV2] Team found in hierarchy cache: ${teamName}`
            );
            await set(
              `linear_teams:${linearTeamId}`,
              foundTeam
            );
          }
        }
        if (!teamExists) {
          try {
            console.log(
              `[CustomerMethodsV2] Team not in cache, fetching from Linear API...`
            );
            const { LinearTeamService: LinearTeamService2 } = await Promise.resolve().then(() => (init_linearTeamService(), linearTeamService_exports));
            const linearService2 = new LinearTeamService2();
            const teamData = await linearService2.getTeamById(linearTeamId);
            if (teamData?.id === linearTeamId) {
              teamExists = true;
              teamName = teamData.name || linearTeamId;
              console.log(
                `[CustomerMethodsV2] Team found via Linear API: ${teamName}`
              );
              await set(
                `linear_teams:${linearTeamId}`,
                teamData
              );
            }
          } catch (err) {
            console.error(
              `[CustomerMethodsV2] Failed to fetch team from Linear API:`,
              err
            );
          }
        }
      }
      if (!teamExists) {
        console.warn(
          `[CustomerMethodsV2] Team ${linearTeamId} not found in any source (cache or API)`
        );
        return {
          success: false,
          error: "Team not found. Please sync Linear teams in Admin > Teams > Linear Sync."
        };
      }
      const existingCustomer = await get(`team:${linearTeamId}:customer`);
      if (existingCustomer && existingCustomer !== customerId) {
        const existingCustomerData = await get(`customer:${existingCustomer}`);
        const existingCustomerName = existingCustomerData?.name || "Unknown Customer";
        console.warn(
          `[CustomerMethodsV2] Team ${teamName} (${linearTeamId}) is already assigned to customer ${existingCustomerName}`
        );
        return {
          success: false,
          error: `Team "${teamName}" is already assigned to customer "${existingCustomerName}". A team can only belong to one customer at a time. Please unassign it from the other customer first.`
        };
      }
      const customerTeams = await get(`customer:${customerId}:teams`) || [];
      if (!customerTeams.includes(linearTeamId)) {
        customerTeams.push(linearTeamId);
        console.log(
          `[CustomerMethodsV2] Writing team assignment to KV store:`,
          {
            customerTeamsKey: `customer:${customerId}:teams`,
            teamOwnershipKey: `team:${linearTeamId}:customer`,
            customerId,
            linearTeamId,
            teamName
          }
        );
        const setResult1 = await set(
          `customer:${customerId}:teams`,
          customerTeams
        );
        console.log(
          `[CustomerMethodsV2] Customer teams list write result:`,
          setResult1 !== void 0 ? "SUCCESS" : "FAILED"
        );
        const setResult2 = await set(
          `team:${linearTeamId}:customer`,
          customerId
        );
        console.log(
          `[CustomerMethodsV2] Team ownership mapping write result:`,
          setResult2 !== void 0 ? "SUCCESS" : "FAILED"
        );
        const verifyCustomerTeams = await get(`customer:${customerId}:teams`);
        const verifyOwnership = await get(`team:${linearTeamId}:customer`);
        console.log(
          `[CustomerMethodsV2] VERIFICATION - Data written successfully:`,
          {
            customerTeamsVerified: Array.isArray(verifyCustomerTeams) && verifyCustomerTeams.includes(linearTeamId),
            ownershipVerified: verifyOwnership === customerId,
            verifyCustomerTeams,
            verifyOwnership
          }
        );
        if (!verifyOwnership || verifyOwnership !== customerId) {
          throw new Error(
            `CRITICAL: Team ownership mapping write FAILED - Expected "${customerId}", got "${verifyOwnership}"`
          );
        }
        console.log(
          `[CustomerMethodsV2] Team ${teamName} (${linearTeamId}) assigned to customer - VERIFIED`
        );
      } else {
        console.log(
          `[CustomerMethodsV2] Team ${teamName} (${linearTeamId}) already assigned to customer`
        );
      }
      await del("team_ownership_map:all");
      console.log("[CustomerMethodsV2] Invalidated team ownership cache");
      return {
        success: true,
        data: {
          message: `Team "${teamName}" assigned successfully`,
          teamId: linearTeamId,
          teamName
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Assign team to customer error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to assign team to customer"
      };
    }
  }
  /**
   *Schema v2.0: Remove team from customer
   *FIX: Now includes team member cleanup to prevent orphaned access
   */
  async removeTeamFromCustomer(customerId, linearTeamId, removedBy) {
    try {
      console.log(
        `[CustomerMethodsV2] Removing team ${linearTeamId} from customer ${customerId}`
      );
      const teamMembersKey = `customer:${customerId}:team:${linearTeamId}:members`;
      const teamMembers = await get(teamMembersKey) || [];
      if (teamMembers.length > 0) {
        console.log(
          ` Cleaning up ${teamMembers.length} team member assignments`
        );
        await del(teamMembersKey);
      }
      const customerTeams = await get(`customer:${customerId}:teams`) || [];
      const updatedTeams = customerTeams.filter(
        (id) => id !== linearTeamId
      );
      console.log(
        `[CustomerMethodsV2] Removing team ownership from KV store:`,
        {
          customerTeamsKey: `customer:${customerId}:teams`,
          teamOwnershipKey: `team:${linearTeamId}:customer`,
          customerId,
          linearTeamId
        }
      );
      await set(
        `customer:${customerId}:teams`,
        updatedTeams
      );
      const delResult = await del(`team:${linearTeamId}:customer`);
      console.log(
        `[CustomerMethodsV2] Team ownership deletion result:`,
        delResult !== void 0 ? "SUCCESS" : "FAILED"
      );
      const verifyOwnership = await get(`team:${linearTeamId}:customer`);
      console.log(
        `[CustomerMethodsV2] VERIFICATION - Ownership deleted:`,
        {
          ownershipDeleted: verifyOwnership === null || verifyOwnership === void 0,
          verifyOwnership
        }
      );
      console.log(
        `[CustomerMethodsV2] Team removed from customer (cleaned ${teamMembers.length} member assignments) - VERIFIED`
      );
      await del("team_ownership_map:all");
      console.log("[CustomerMethodsV2] Invalidated team ownership cache");
      return {
        success: true,
        data: {
          message: "Team removed from customer successfully",
          cleanedMembers: teamMembers.length
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Remove team from customer error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to remove team from customer"
      };
    }
  }
  /**
   *Schema v2.0: Get team members for a customer's team
   */
  async getCustomerTeamMembers(customerId, teamId) {
    try {
      console.log(
        `[CustomerMethodsV2] Getting team members for customer ${customerId}, team ${teamId}`
      );
      const teamMembers = await get(
        `customer:${customerId}:team:${teamId}:members`
      ) || [];
      const members = [];
      for (const userId of teamMembers) {
        const user = await get(`user:${userId}`);
        if (user) {
          members.push({
            userId,
            //Schema V2.0: camelCase
            email: user.email,
            name: user.metadata?.name || user.email.split("@")[0],
            role: user.role || "viewer"
          });
        }
      }
      console.log(
        `[CustomerMethodsV2] Loaded ${members.length} team members`
      );
      return {
        success: true,
        data: {
          members,
          count: members.length
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Get customer team members error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get team members"
      };
    }
  }
  /**
   *Schema v2.0: Add member to customer's team
   */
  async addMemberToCustomerTeam(customerId, teamId, userId, addedBy) {
    try {
      console.log(
        `[CustomerMethodsV2] Adding user ${userId} to customer ${customerId}, team ${teamId}`
      );
      const customer = await get(`customer:${customerId}`);
      if (!customer) {
        return {
          success: false,
          error: "Customer not found"
        };
      }
      const customerTeams = await get(`customer:${customerId}:teams`) || [];
      if (!customerTeams.includes(teamId)) {
        return {
          success: false,
          error: "Team not assigned to customer"
        };
      }
      const customerMembers = await get(`customer:${customerId}:members`) || [];
      if (!customerMembers.includes(userId)) {
        return {
          success: false,
          error: "User not a member of this customer. Please add user to customer first."
        };
      }
      const membershipRecord = await get(
        `customer:${customerId}:member:${userId}`
      );
      if (!membershipRecord) {
        console.warn(
          `\uFE0F [CustomerMethodsV2] Data inconsistency: User ${userId} in members list but no membership record`
        );
        return {
          success: false,
          error: "User membership record missing. Please re-assign user to customer to fix."
        };
      }
      const teamMembers = await get(
        `customer:${customerId}:team:${teamId}:members`
      ) || [];
      if (!teamMembers.includes(userId)) {
        teamMembers.push(userId);
        await set(
          `customer:${customerId}:team:${teamId}:members`,
          teamMembers
        );
      }
      console.log(`[CustomerMethodsV2] User added to team`);
      return {
        success: true,
        data: {
          message: "User added to team successfully"
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Add member to team error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to add member to team"
      };
    }
  }
  /**
   *Schema v2.0: Remove member from customer's team
   */
  async removeMemberFromCustomerTeam(customerId, teamId, userId, removedBy) {
    try {
      console.log(
        `[CustomerMethodsV2] Removing user ${userId} from customer ${customerId}, team ${teamId}`
      );
      const teamMembers = await get(
        `customer:${customerId}:team:${teamId}:members`
      ) || [];
      const updatedMembers = teamMembers.filter(
        (id) => id !== userId
      );
      await set(
        `customer:${customerId}:team:${teamId}:members`,
        updatedMembers
      );
      console.log(`[CustomerMethodsV2] User removed from team`);
      return {
        success: true,
        data: {
          message: "User removed from team successfully"
        }
      };
    } catch (error) {
      console.error(
        "[CustomerMethodsV2] Remove member from team error:",
        error
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to remove member from team"
      };
    }
  }
};
var customerMethodsV2 = new CustomerMethodsV2();

// src/server/helpers/adminHelpers.ts
init_kv_store();
var AdminHelpers = class {
  /**
   * Get dashboard statistics
   */
  async getDashboardStats(supabase4) {
    try {
      console.log("[AdminHelpers] Fetching dashboard stats...");
      const { data: authUsers } = await supabase4.auth.admin.listUsers();
      const userCount = authUsers?.users?.length || 0;
      const customerKeys = await getByPrefix("customer:");
      const customerCount = customerKeys.filter((key) => !key.includes(":")).length;
      const teamKeys = await getByPrefix("linear_teams:");
      const teamCount = teamKeys.length;
      const activityKeys = await getByPrefix("admin_activity:");
      const recentActivityCount = activityKeys.slice(0, 10).length;
      const stats = {
        users: userCount,
        customers: customerCount,
        teams: teamCount,
        recentActivity: recentActivityCount,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      console.log("[AdminHelpers] Dashboard stats:", stats);
      return {
        success: true,
        data: { stats }
      };
    } catch (error) {
      console.error("[AdminHelpers] Get dashboard stats error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch dashboard stats"
      };
    }
  }
  /**
   *Get activity logs
   */
  async getActivityLogs(options = {}) {
    try {
      console.log("[AdminHelpers] Fetching activity logs...");
      const { limit = 50, offset = 0 } = options;
      const logKeys = await getByPrefix("admin_activity:");
      const sortedKeys = logKeys.sort().reverse();
      const paginatedKeys = sortedKeys.slice(offset, offset + limit);
      const logs = [];
      for (const key of paginatedKeys) {
        const log = await get(key);
        if (log) {
          logs.push(log);
        }
      }
      console.log(`[AdminHelpers] Retrieved ${logs.length} activity logs`);
      return {
        success: true,
        data: {
          logs,
          total: logKeys.length,
          limit,
          offset
        }
      };
    } catch (error) {
      console.error("[AdminHelpers] Get activity logs error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch activity logs"
      };
    }
  }
  /**
   *Get role definitions
   */
  async getRoleDefinitions() {
    try {
      console.log("[AdminHelpers] Fetching role definitions...");
      const roleDefinitions = {
        superadmin: {
          name: "Super Administrator",
          description: "Complete system access, manage all customers and global settings",
          permissions: [
            "view_issues",
            "create_issues",
            "edit_issues",
            "delete_issues",
            "view_project_status",
            "manage_users",
            "manage_permissions",
            "access_linear_test",
            "view_analytics",
            "export_data",
            "manage_system",
            "manage_customers",
            "manage_teams",
            "view_admin",
            "access_all_customers",
            "manage_security"
          ]
        },
        admin: {
          name: "Administrator",
          description: "Manage users and customers within assigned scope",
          permissions: [
            "view_issues",
            "create_issues",
            "edit_issues",
            "delete_issues",
            "view_project_status",
            "manage_users",
            "manage_permissions",
            "access_linear_test",
            "view_analytics",
            "export_data",
            "manage_customers",
            "manage_teams",
            "view_admin"
          ]
        },
        client_manager: {
          name: "Client Manager",
          description: "Manage client team and oversee project issues",
          permissions: [
            "view_issues",
            "create_issues",
            "edit_issues",
            "delete_issues",
            "view_project_status",
            "view_analytics",
            "export_data",
            "manage_teams"
          ]
        },
        client_user: {
          name: "Client User",
          description: "Standard client access for testing and issue reporting",
          permissions: [
            "view_issues",
            "create_issues",
            "edit_issues",
            "view_project_status"
          ]
        },
        tester: {
          name: "Tester",
          description: "Specialized testing role with enhanced bug reporting capabilities",
          permissions: [
            "view_issues",
            "create_issues",
            "edit_issues",
            "view_project_status",
            "access_linear_test"
          ]
        },
        viewer: {
          name: "Viewer",
          description: "Read-only access to dashboard and project status",
          permissions: ["view_issues", "view_project_status"]
        }
      };
      console.log("[AdminHelpers] Role definitions retrieved");
      return {
        success: true,
        data: { roles: roleDefinitions }
      };
    } catch (error) {
      console.error("[AdminHelpers] Get role definitions error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch role definitions"
      };
    }
  }
  /**
   *Get member permissions within customer
   * Returns user's role and permissions in a specific customer context
   */
  async getMemberPermissions(customerId, userId) {
    try {
      console.log(`[AdminHelpers] Getting permissions for user ${userId} in customer ${customerId}`);
      const customerMembers = await get(`customer:${customerId}:members`) || [];
      if (!customerMembers.includes(userId)) {
        return {
          success: false,
          error: "User is not a member of this customer"
        };
      }
      const userObj = await get(`user:${userId}`);
      if (!userObj) {
        return {
          success: false,
          error: "User not found"
        };
      }
      const membership = await get(`customer:${customerId}:member:${userId}`);
      const rolesResult = await this.getRoleDefinitions();
      const roleDefinitions = rolesResult.data?.roles || {};
      const rolePermissions = roleDefinitions[userObj.role]?.permissions || [];
      return {
        success: true,
        data: {
          user_id: userId,
          customer_id: customerId,
          role: userObj.role,
          permissions: rolePermissions,
          assigned_at: membership?.assigned_at,
          assigned_by: membership?.assigned_by
        }
      };
    } catch (error) {
      console.error("[AdminHelpers] Get member permissions error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get member permissions"
      };
    }
  }
  /**
   *  Update member permissions (role) within customer
   */
  async updateMemberPermissions(customerId, userId, newRole, updatedBy) {
    try {
      console.log(`[AdminHelpers] Updating role for user ${userId} in customer ${customerId} to ${newRole}`);
      const customerMembers = await get(`customer:${customerId}:members`) || [];
      if (!customerMembers.includes(userId)) {
        return {
          success: false,
          error: "User is not a member of this customer"
        };
      }
      const userObj = await get(`user:${userId}`);
      if (!userObj) {
        return {
          success: false,
          error: "User not found"
        };
      }
      userObj.role = newRole;
      userObj.updated_at = (/* @__PURE__ */ new Date()).toISOString();
      userObj.updated_by = updatedBy;
      await set(`user:${userId}`, userObj);
      const membership = await get(`customer:${customerId}:member:${userId}`) || {};
      membership.role_updated_at = (/* @__PURE__ */ new Date()).toISOString();
      membership.role_updated_by = updatedBy;
      await set(`customer:${customerId}:member:${userId}`, membership);
      console.log(`[AdminHelpers] Role updated successfully`);
      return {
        success: true,
        data: {
          message: "Member permissions updated successfully",
          user_id: userId,
          customer_id: customerId,
          new_role: newRole
        }
      };
    } catch (error) {
      console.error("[AdminHelpers] Update member permissions error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to update member permissions"
      };
    }
  }
  /**
   *Get customer permission matrix
   * Returns all members with their roles and permissions
   */
  async getOrganizationPermissionMatrix(customerId) {
    try {
      console.log(`[AdminHelpers] Getting permission matrix for customer ${customerId}`);
      const customer = await get(`customer:${customerId}`);
      if (!customer) {
        return {
          success: false,
          error: "Customer not found"
        };
      }
      const memberIds = await get(`customer:${customerId}:members`) || [];
      const rolesResult = await this.getRoleDefinitions();
      const roleDefinitions = rolesResult.data?.roles || {};
      const members = [];
      for (const userId of memberIds) {
        const userObj = await get(`user:${userId}`);
        const membership = await get(`customer:${customerId}:member:${userId}`);
        if (userObj) {
          const rolePermissions = roleDefinitions[userObj.role]?.permissions || [];
          members.push({
            user_id: userId,
            email: userObj.email,
            name: userObj.metadata?.name || userObj.email.split("@")[0],
            role: userObj.role,
            permissions: rolePermissions,
            assigned_at: membership?.assigned_at,
            assigned_by: membership?.assigned_by
          });
        }
      }
      console.log(`[AdminHelpers] Permission matrix retrieved for ${members.length} members`);
      return {
        success: true,
        data: {
          customer_id: customerId,
          customer_name: customer.name,
          members,
          roles: roleDefinitions
        }
      };
    } catch (error) {
      console.error("[AdminHelpers] Get permission matrix error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get permission matrix"
      };
    }
  }
  /**
   *Check user permission
   */
  async checkUserPermission(userId, permission, customerId) {
    try {
      const userObj = await get(`user:${userId}`);
      if (!userObj) {
        return {
          success: false,
          error: "User not found"
        };
      }
      const rolesResult = await this.getRoleDefinitions();
      const roleDefinitions = rolesResult.data?.roles || {};
      if (userObj.role === "superadmin") {
        return {
          success: true,
          data: {
            hasPermission: true,
            reason: "superadmin_role"
          }
        };
      }
      const rolePermissions = roleDefinitions[userObj.role]?.permissions || [];
      const hasPermission2 = rolePermissions.includes(permission);
      return {
        success: true,
        data: {
          hasPermission: hasPermission2,
          role: userObj.role,
          permission,
          reason: hasPermission2 ? "role_permission" : "no_permission"
        }
      };
    } catch (error) {
      console.error("[AdminHelpers] Check user permission error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to check user permission"
      };
    }
  }
  /**
   *Get user's role in customer
   */
  async getMyRoleInCustomer(userId, userEmail, customerId) {
    try {
      console.log(`[AdminHelpers] Getting role for user ${userEmail} in customer ${customerId}`);
      const { isSuperAdminUser: isSuperAdminUser2 } = await Promise.resolve().then(() => (init_authHelpers(), authHelpers_exports));
      const isSuperAdmin = await isSuperAdminUser2(userEmail);
      if (isSuperAdmin) {
        return {
          success: true,
          data: {
            role: "superadmin",
            isMember: true,
            canManage: true
          }
        };
      }
      const customerMembers = await get(`customer:${customerId}:members`) || [];
      const isMember = customerMembers.includes(userId);
      if (!isMember) {
        return {
          success: true,
          data: {
            role: null,
            isMember: false,
            canManage: false
          }
        };
      }
      const userObj = await get(`user:${userId}`);
      if (!userObj) {
        return {
          success: false,
          error: "User not found"
        };
      }
      const canManage = userObj.role === "superadmin" || userObj.role === "admin" || userObj.role === "client_manager";
      return {
        success: true,
        data: {
          role: userObj.role,
          isMember: true,
          canManage
        }
      };
    } catch (error) {
      console.error("[AdminHelpers] Get my role in customer error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get role in customer"
      };
    }
  }
  /**
   *Get team members with permissions
   * (Helper for team member management in customer context)
   */
  async getTeamMembersWithPermissions(customerId, teamId) {
    try {
      console.log(`[AdminHelpers] Getting team members with permissions for team ${teamId} in customer ${customerId}`);
      const customer = await get(`customer:${customerId}`);
      if (!customer) {
        return {
          success: false,
          error: "Customer not found"
        };
      }
      const team = await get(`linear_teams:${teamId}`);
      if (!team) {
        return {
          success: false,
          error: "Team not found"
        };
      }
      const teamMemberIds = await get(`team:${teamId}:members`) || [];
      const rolesResult = await this.getRoleDefinitions();
      const roleDefinitions = rolesResult.data?.roles || {};
      const members = [];
      for (const userId of teamMemberIds) {
        const userObj = await get(`user:${userId}`);
        const membership = await get(`team:${teamId}:member:${userId}`);
        if (userObj) {
          const rolePermissions = roleDefinitions[userObj.role]?.permissions || [];
          members.push({
            user_id: userId,
            email: userObj.email,
            name: userObj.metadata?.name || userObj.email.split("@")[0],
            role: userObj.role,
            status: userObj.status,
            permissions: rolePermissions,
            assigned_at: membership?.assigned_at,
            assigned_by: membership?.assigned_by
          });
        }
      }
      console.log(`[AdminHelpers] Found ${members.length} team members with permissions`);
      return {
        success: true,
        data: {
          members,
          count: members.length
        }
      };
    } catch (error) {
      console.error("[AdminHelpers] Get team members with permissions error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get team members with permissions"
      };
    }
  }
  /**
   *Add member to team (with customer validation)
   */
  async addMemberToTeam(customerId, teamId, userId, assignedBy) {
    try {
      console.log(`[AdminHelpers] Adding user ${userId} to team ${teamId} in customer ${customerId}`);
      const customerMembers = await get(`customer:${customerId}:members`) || [];
      if (!customerMembers.includes(userId)) {
        return {
          success: false,
          error: "User must be a member of the customer first"
        };
      }
      const customerTeams = await get(`customer:${customerId}:teams`) || [];
      if (!customerTeams.includes(teamId)) {
        return {
          success: false,
          error: "Team must be assigned to customer first"
        };
      }
      const teamMembers = await get(`team:${teamId}:members`) || [];
      if (teamMembers.includes(userId)) {
        return {
          success: false,
          error: "User is already a member of this team"
        };
      }
      teamMembers.push(userId);
      await set(`team:${teamId}:members`, teamMembers);
      const membership = {
        user_id: userId,
        team_id: teamId,
        customer_id: customerId,
        assigned_at: (/* @__PURE__ */ new Date()).toISOString(),
        assigned_by: assignedBy
      };
      await set(`team:${teamId}:member:${userId}`, membership);
      const userTeams = await get(`user:${userId}:teams`) || [];
      if (!userTeams.includes(teamId)) {
        userTeams.push(teamId);
        await set(`user:${userId}:teams`, userTeams);
      }
      console.log(`[AdminHelpers] User added to team successfully`);
      return {
        success: true,
        data: {
          message: "Member added to team successfully",
          membership
        }
      };
    } catch (error) {
      console.error("[AdminHelpers] Add member to team error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to add member to team"
      };
    }
  }
  /**
   *Remove member from team
   */
  async removeMemberFromTeam(customerId, teamId, userId, removedBy) {
    try {
      console.log(`[AdminHelpers] Removing user ${userId} from team ${teamId} in customer ${customerId}`);
      const teamMembers = await get(`team:${teamId}:members`) || [];
      const updatedMembers = teamMembers.filter((id) => id !== userId);
      await set(`team:${teamId}:members`, updatedMembers);
      await del(`team:${teamId}:member:${userId}`);
      const userTeams = await get(`user:${userId}:teams`) || [];
      const updatedUserTeams = userTeams.filter((id) => id !== teamId);
      await set(`user:${userId}:teams`, updatedUserTeams);
      console.log(`[AdminHelpers] User removed from team successfully`);
      return {
        success: true,
        data: {
          message: "Member removed from team successfully"
        }
      };
    } catch (error) {
      console.error("[AdminHelpers] Remove member from team error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to remove member from team"
      };
    }
  }
};
var adminHelpers = new AdminHelpers();

// src/server/methods/teamMethodsV2.ts
init_kv_store();
var TeamMethodsV2 = class {
  //PERFORMANCE: KV cache for enriched hierarchy (30 seconds TTL)
  CACHE_TTL_MS = 30 * 1e3;
  // 30 seconds
  ENRICHED_CACHE_KEY = "linear_teams:enriched";
  // PERFORMANCE: Cache for team ownership mappings (5 minutes TTL)
  OWNERSHIP_CACHE_KEY = "team_ownership_map:all";
  OWNERSHIP_CACHE_TTL_MS = 5 * 60 * 1e3;
  // 5 minutes
  /**
   * Get available teams for a customer (teams not assigned to other customers)
   * CRITICAL: Enforces team exclusivity - only returns unassigned teams
   * OPTIMIZED: Batch fetch with aggressive caching for ownership mappings
   */
  async getAvailableTeamsForCustomer(customerId) {
    try {
      console.log(`[TeamMethodsV2] Getting available teams for customer: ${customerId}`);
      const startTime = Date.now();
      const allTeamsResult = await this.getAllTeams(false);
      if (!allTeamsResult.success || !allTeamsResult.data?.teams) {
        return {
          success: false,
          error: "Failed to fetch teams from cache"
        };
      }
      const allTeams = allTeamsResult.data.teams;
      console.log(`[TeamMethodsV2] Loaded ${allTeams.length} teams from cache`);
      const customerTeamsIds = await get(`customer:${customerId}:teams`) || [];
      let teamOwnershipMap = /* @__PURE__ */ new Map();
      let usedCache = false;
      const cachedOwnership = await get(this.OWNERSHIP_CACHE_KEY);
      if (cachedOwnership && typeof cachedOwnership === "object") {
        const age = Date.now() - (cachedOwnership.timestamp || 0);
        if (age < this.OWNERSHIP_CACHE_TTL_MS) {
          console.log(`[TeamMethodsV2] Using cached ownership mappings (age: ${age}ms)`);
          teamOwnershipMap = new Map(cachedOwnership.data || []);
          usedCache = true;
        } else {
          console.log(`[TeamMethodsV2] Ownership cache expired (age: ${age}ms > ${this.OWNERSHIP_CACHE_TTL_MS}ms)`);
          await del(this.OWNERSHIP_CACHE_KEY);
        }
      }
      if (!usedCache) {
        console.log(`[TeamMethodsV2] Cache miss - fetching ownership mappings from database`);
        try {
          const ownershipKeys = await getByPrefix("team:");
          console.log(`[TeamMethodsV2] Found ${ownershipKeys.length} team-related keys from KV`);
          const ownershipRecords = ownershipKeys.filter((key) => key.endsWith(":customer"));
          console.log(`[TeamMethodsV2] Filtered to ${ownershipRecords.length} ownership records`);
          for (const key of ownershipRecords) {
            const parts = key.split(":");
            if (parts.length === 3 && parts[0] === "team" && parts[2] === "customer") {
              const teamId = parts[1];
              const ownerId = await get(key);
              if (ownerId && typeof ownerId === "string") {
                teamOwnershipMap.set(teamId, ownerId);
              } else {
                console.warn(`[TeamMethodsV2] Invalid ownership record: key=${key}, value=${typeof ownerId}`);
              }
            }
          }
          console.log(
            `[TeamMethodsV2] Built ownership map with ${teamOwnershipMap.size} assigned teams from ${ownershipRecords.length} KV records`
          );
        } catch (kvError) {
          console.error("[TeamMethodsV2] Error fetching from KV store:", kvError);
          console.log("[TeamMethodsV2] Falling back to showing all teams as available");
        }
        await set(this.OWNERSHIP_CACHE_KEY, {
          data: Array.from(teamOwnershipMap.entries()),
          timestamp: Date.now()
        });
        console.log(`[TeamMethodsV2] Cached ownership mappings for ${this.OWNERSHIP_CACHE_TTL_MS / 1e3}s`);
      }
      if (teamOwnershipMap.size > 0) {
        const sampleEntries = Array.from(teamOwnershipMap.entries()).slice(0, 3);
        console.log(
          `[TeamMethodsV2] Sample ownership mappings:`,
          sampleEntries.map(([teamId, customerId2]) => `${teamId} \u2192 ${customerId2}`).join(", ")
        );
      } else {
        console.log(`[TeamMethodsV2] WARNING: No ownership mappings found - all teams will appear available`);
      }
      console.log(
        `[TeamMethodsV2] Filtering teams for customer: ${customerId}`
      );
      const availableTeams = [];
      const excludedTeams = [];
      for (const team of allTeams) {
        const assignedCustomerId = teamOwnershipMap.get(team.id);
        if (!assignedCustomerId || assignedCustomerId === customerId) {
          availableTeams.push({
            id: team.id,
            name: team.name,
            key: team.key,
            description: team.description,
            state: team.state,
            color: team.color,
            isAssignedToThisCustomer: customerTeamsIds.includes(team.id)
          });
        } else {
          excludedTeams.push({
            teamId: team.id,
            teamName: team.name,
            assignedTo: assignedCustomerId
          });
        }
      }
      if (excludedTeams.length > 0) {
        console.log(
          `[TeamMethodsV2] Excluded ${excludedTeams.length} teams already assigned to other customers:`,
          excludedTeams.slice(0, 3).map((t) => `${t.teamName} \u2192 ${t.assignedTo}`).join(", ")
        );
      } else {
        console.log(`[TeamMethodsV2] No teams excluded - all teams are available`);
      }
      const duration = Date.now() - startTime;
      console.log(
        `[TeamMethodsV2] Found ${availableTeams.length} available teams (out of ${allTeams.length} total) in ${duration}ms - OPTIMIZED`
      );
      return {
        success: true,
        data: {
          teams: availableTeams,
          count: availableTeams.length,
          totalTeams: allTeams.length
        }
      };
    } catch (error) {
      console.error("[TeamMethodsV2] Get available teams error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get available teams"
      };
    }
  }
  /**
   *Schema v2.0: Get all Linear teams with hierarchy support (synced from Linear API)
   *OPTIMIZED: KV caching + batch queries
   * 
   * Returns teams with parent-child relationships from Linear Team Hierarchy Sync
   */
  async getAllTeams(includeHierarchy = false) {
    try {
      console.log("[TeamMethodsV2] Fetching all Linear teams (includeHierarchy:", includeHierarchy, ")");
      if (includeHierarchy) {
        const cachedEnriched = await get(this.ENRICHED_CACHE_KEY);
        if (cachedEnriched && typeof cachedEnriched === "object") {
          const age = Date.now() - (cachedEnriched.timestamp || 0);
          if (age < this.CACHE_TTL_MS) {
            console.log(`[TeamMethodsV2] Using enriched KV cache (age: ${age}ms)`);
            return {
              success: true,
              data: {
                ...cachedEnriched.data,
                cached: true,
                cacheAge: age,
                source: "enriched-cache"
              }
            };
          } else {
            console.log(`[TeamMethodsV2] Enriched cache expired (age: ${age}ms > ${this.CACHE_TTL_MS}ms)`);
            await del(this.ENRICHED_CACHE_KEY);
          }
        }
      }
      if (includeHierarchy) {
        console.log("[TeamMethodsV2] Checking KV for cached hierarchy...");
        let cachedHierarchy = await get("linear_teams:all");
        if (typeof cachedHierarchy === "string") {
          console.log("[TeamMethodsV2] Parsing JSON string from KV...");
          try {
            cachedHierarchy = JSON.parse(cachedHierarchy);
          } catch (err) {
            console.error("[TeamMethodsV2] Failed to parse cached hierarchy:", err);
            cachedHierarchy = null;
          }
        }
        console.log("[TeamMethodsV2] Cache check:", {
          exists: !!cachedHierarchy,
          type: typeof cachedHierarchy,
          hasTeams: !!cachedHierarchy?.teams,
          teamsCount: cachedHierarchy?.teams?.length || 0,
          hasHierarchy: !!cachedHierarchy?.hierarchy,
          hierarchyCount: cachedHierarchy?.hierarchy?.length || 0
        });
        if (cachedHierarchy && (cachedHierarchy.teams || cachedHierarchy.hierarchy)) {
          console.log("[TeamMethodsV2] Using KV cached team data");
          const enrichedHierarchy = cachedHierarchy.hierarchy ? await this.enrichTeamHierarchy(cachedHierarchy.hierarchy) : [];
          const responseData = {
            teams: cachedHierarchy.teams || [],
            hierarchy: enrichedHierarchy,
            rootTeamsCount: cachedHierarchy.rootTeamsCount || 0,
            totalTeamsCount: cachedHierarchy.totalTeamsCount || 0,
            count: cachedHierarchy.count || cachedHierarchy.teams?.length || 0,
            syncedAt: cachedHierarchy.syncedAt,
            source: "kv-cache"
          };
          await set(this.ENRICHED_CACHE_KEY, {
            data: responseData,
            timestamp: Date.now()
          });
          console.log(`[TeamMethodsV2] Cached enriched hierarchy for 30s`);
          return {
            success: true,
            data: responseData
          };
        }
        console.warn("[TeamMethodsV2] No cached hierarchy found, falling back to individual fetch");
      }
      console.log("[TeamMethodsV2] Fallback to individual team fetching (optimized)...");
      const startTime = Date.now();
      const teamKeys = await getByPrefix("linear_teams:");
      console.log(`[TeamMethodsV2] Found ${teamKeys.length} team keys`);
      const teams = [];
      const processedIds = /* @__PURE__ */ new Set();
      const teamIds = [];
      for (const key of teamKeys) {
        try {
          if (key === "linear_teams:all") {
            continue;
          }
          const teamId = key.replace("linear_teams:", "");
          if (processedIds.has(teamId)) {
            continue;
          }
          processedIds.add(teamId);
          teamIds.push(teamId);
          let team = await get(key);
          if (typeof team === "string") {
            try {
              team = JSON.parse(team);
            } catch (err) {
              console.warn(`\uFE0F [TeamMethodsV2] Failed to parse team at ${key}:`, err);
              continue;
            }
          }
          if (!team || !team.id) {
            console.warn(`\uFE0F [TeamMethodsV2] Invalid team at ${key}`);
            continue;
          }
          teams.push({
            id: team.id,
            name: team.name,
            key: team.key,
            description: team.description || "",
            state: team.state || "active",
            color: team.color,
            icon: team.icon,
            timezone: team.timezone,
            cyclesEnabled: team.cyclesEnabled,
            issueCount: team.issueCount || 0,
            parentId: team.parentId || team.parent_id || null,
            parentName: team.parentName || team.parent_name || null,
            parentKey: team.parentKey || team.parent_key || null,
            createdAt: team.createdAt || team.created_at,
            updatedAt: team.updatedAt || team.updated_at,
            // Placeholders - will be filled in Phase 2
            membersCount: 0,
            customersCount: 0
          });
        } catch (error) {
          console.warn(`\uFE0F [TeamMethodsV2] Error processing team ${key}:`, error);
        }
      }
      console.log(`[TeamMethodsV2] Batch fetching metadata for ${teams.length} teams...`);
      const teamMembersPromises = teams.map(async (team) => {
        const memberIds = await get(`team:${team.id}:members`) || [];
        return { teamId: team.id, count: memberIds.length };
      });
      const teamMembersResults = await Promise.all(teamMembersPromises);
      const teamMembersMap = new Map(
        teamMembersResults.map((r) => [r.teamId, r.count])
      );
      const customerKeys = await getByPrefix("customer:");
      const customerIds = customerKeys.filter((key) => !key.includes(":")).map((key) => key.replace("customer:", ""));
      const customerTeamsPromises = customerIds.map(async (customerId) => {
        const teams2 = await get(`customer:${customerId}:teams`) || [];
        return teams2;
      });
      const customerTeamsResults = await Promise.all(customerTeamsPromises);
      const teamCustomerCountMap = /* @__PURE__ */ new Map();
      for (const customerTeams of customerTeamsResults) {
        for (const teamId of customerTeams) {
          teamCustomerCountMap.set(
            teamId,
            (teamCustomerCountMap.get(teamId) || 0) + 1
          );
        }
      }
      for (const team of teams) {
        team.membersCount = teamMembersMap.get(team.id) || 0;
        team.customersCount = teamCustomerCountMap.get(team.id) || 0;
      }
      const duration = Date.now() - startTime;
      console.log(`[TeamMethodsV2] Processed ${teams.length} teams in ${duration}ms (optimized)`);
      return {
        success: true,
        data: {
          teams,
          count: teams.length,
          source: "flat-optimized"
        }
      };
    } catch (error) {
      console.error("[TeamMethodsV2] Get all teams error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch teams"
      };
    }
  }
  /**
   *Enrich team hierarchy with internal data (members, customers)
   *OPTIMIZED: Pre-fetch all data once, build lookup maps - O(1) access
   * Private helper method
   */
  async enrichTeamHierarchy(hierarchy) {
    if (!hierarchy || hierarchy.length === 0) {
      return [];
    }
    console.log(`[TeamMethodsV2] Enriching ${hierarchy.length} team nodes (optimized)...`);
    const startTime = Date.now();
    const allTeamIds = this.extractAllTeamIds(hierarchy);
    console.log(`[TeamMethodsV2] Found ${allTeamIds.size} unique teams to enrich`);
    const teamMembersMap = /* @__PURE__ */ new Map();
    const memberPromises = Array.from(allTeamIds).map(async (teamId) => {
      const memberIds = await get(`team:${teamId}:members`) || [];
      teamMembersMap.set(teamId, memberIds.length);
    });
    await Promise.all(memberPromises);
    const customerKeys = await getByPrefix("customer:");
    const customerIds = customerKeys.filter((key) => !key.includes(":")).map((key) => key.replace("customer:", ""));
    console.log(`[TeamMethodsV2] Found ${customerIds.length} customers to check`);
    const customerTeamsMap = /* @__PURE__ */ new Map();
    const customerTeamPromises = customerIds.map(async (customerId) => {
      const teams = await get(`customer:${customerId}:teams`) || [];
      customerTeamsMap.set(customerId, teams);
    });
    await Promise.all(customerTeamPromises);
    const teamCustomerCountMap = /* @__PURE__ */ new Map();
    for (const [customerId, teams] of customerTeamsMap.entries()) {
      for (const teamId of teams) {
        teamCustomerCountMap.set(
          teamId,
          (teamCustomerCountMap.get(teamId) || 0) + 1
        );
      }
    }
    const enrichNode = (node) => {
      const teamId = node.id;
      const membersCount = teamMembersMap.get(teamId) || 0;
      const customersCount = teamCustomerCountMap.get(teamId) || 0;
      const enrichedChildren = node.children && node.children.length > 0 ? node.children.map(enrichNode) : [];
      return {
        ...node,
        membersCount,
        //Schema V2.0: camelCase
        customersCount,
        //Schema V2.0: camelCase
        children: enrichedChildren
      };
    };
    const enriched = hierarchy.map(enrichNode);
    const duration = Date.now() - startTime;
    console.log(`[TeamMethodsV2] Enrichment complete in ${duration}ms (${allTeamIds.size} teams, ${customerIds.length} customers)`);
    return enriched;
  }
  /**
   *Extract all team IDs from hierarchy tree (recursive)
   * Helper for batch enrichment
   */
  extractAllTeamIds(hierarchy) {
    const teamIds = /* @__PURE__ */ new Set();
    const traverse = (nodes) => {
      for (const node of nodes) {
        if (node.id) {
          teamIds.add(node.id);
        }
        if (node.children && node.children.length > 0) {
          traverse(node.children);
        }
      }
    };
    traverse(hierarchy);
    return teamIds;
  }
  /**
   *Invalidate enriched hierarchy cache
   * Call this after Linear sync or team modifications
   */
  async invalidateCache() {
    console.log("\uFE0F [TeamMethodsV2] Invalidating enriched hierarchy cache");
    await del(this.ENRICHED_CACHE_KEY);
  }
  /**
   *Get cache stats (for debugging)
   */
  async getCacheStats() {
    const cachedEnriched = await get(this.ENRICHED_CACHE_KEY);
    if (!cachedEnriched || typeof cachedEnriched !== "object") {
      return { cached: false, ttl: this.CACHE_TTL_MS };
    }
    const age = Date.now() - (cachedEnriched.timestamp || 0);
    return {
      cached: true,
      age,
      ttl: this.CACHE_TTL_MS
    };
  }
  /**
   *Schema v2.0: Get team by ID with full details + hierarchy info
   * 
   * Returns team with parent/children relationships from Linear Team Hierarchy
   */
  async getTeamById(teamId, includeHierarchy = true) {
    try {
      console.log(`[TeamMethodsV2] Fetching team: ${teamId} (hierarchy: ${includeHierarchy})`);
      let team = await get(`linear_teams:${teamId}`);
      if (typeof team === "string") {
        try {
          team = JSON.parse(team);
        } catch (err) {
          console.error(`[TeamMethodsV2] Failed to parse team ${teamId}:`, err);
          return {
            success: false,
            error: "Failed to parse team data"
          };
        }
      }
      if (!team) {
        return {
          success: false,
          error: "Team not found"
        };
      }
      const memberIds = await get(`team:${teamId}:members`) || [];
      const members = [];
      for (const userId of memberIds) {
        let userObj = await get(`user:${userId}`);
        let membership = await get(`team:${teamId}:member:${userId}`);
        if (typeof userObj === "string") {
          try {
            userObj = JSON.parse(userObj);
          } catch (err) {
            console.warn(`\uFE0F [TeamMethodsV2] Failed to parse user ${userId}:`, err);
            continue;
          }
        }
        if (typeof membership === "string") {
          try {
            membership = JSON.parse(membership);
          } catch (err) {
            console.warn(`\uFE0F [TeamMethodsV2] Failed to parse membership:`, err);
            membership = null;
          }
        }
        if (userObj) {
          members.push({
            user_id: userId,
            email: userObj.email,
            name: userObj.metadata?.name || userObj.email.split("@")[0],
            role: userObj.role,
            status: userObj.status,
            assigned_at: membership?.assigned_at,
            assigned_by: membership?.assigned_by
          });
        }
      }
      const customerKeys = await getByPrefix("customer:");
      const assignedCustomers = [];
      for (const customerKey of customerKeys) {
        if (customerKey.includes(":")) {
          continue;
        }
        const customerId = customerKey.replace("customer:", "");
        const customerTeams = await get(`customer:${customerId}:teams`) || [];
        if (customerTeams.includes(teamId)) {
          let customer = await get(`customer:${customerId}`);
          if (typeof customer === "string") {
            try {
              customer = JSON.parse(customer);
            } catch (err) {
              console.warn(`\uFE0F [TeamMethodsV2] Failed to parse customer ${customerId}:`, err);
              continue;
            }
          }
          if (customer) {
            assignedCustomers.push({
              id: customer.id,
              name: customer.name,
              status: customer.status
            });
          }
        }
      }
      let parentTeam = null;
      let childTeams = [];
      if (includeHierarchy) {
        const teamParentId = team.parentId || team.parent_id;
        if (teamParentId) {
          let parent = await get(`linear_teams:${teamParentId}`);
          if (typeof parent === "string") {
            try {
              parent = JSON.parse(parent);
            } catch (err) {
              console.warn(`\uFE0F [TeamMethodsV2] Failed to parse parent team:`, err);
              parent = null;
            }
          }
          if (parent) {
            parentTeam = {
              id: parent.id,
              name: parent.name,
              key: parent.key,
              description: parent.description,
              color: parent.color,
              icon: parent.icon
            };
          }
        }
        let allTeamsData = await get("linear_teams:all");
        if (typeof allTeamsData === "string") {
          try {
            allTeamsData = JSON.parse(allTeamsData);
          } catch (err) {
            console.warn(`\uFE0F [TeamMethodsV2] Failed to parse all teams data:`, err);
            allTeamsData = null;
          }
        }
        if (allTeamsData?.teams) {
          childTeams = allTeamsData.teams.filter((t) => (t.parentId || t.parent_id) === teamId).map((t) => ({
            id: t.id,
            name: t.name,
            key: t.key,
            description: t.description,
            color: t.color,
            icon: t.icon
          }));
        }
      }
      return {
        success: true,
        data: {
          team: {
            ...team,
            //NEW: Hierarchy information
            parent: parentTeam,
            children: childTeams,
            childCount: childTeams.length,
            hasParent: !!(team.parentId || team.parent_id),
            //Schema V2.0: Support both
            hasChildren: childTeams.length > 0,
            // Existing fields
            members,
            membersCount: members.length,
            //Schema V2.0: camelCase
            customers: assignedCustomers,
            customersCount: assignedCustomers.length
            //Schema V2.0: camelCase
          }
        }
      };
    } catch (error) {
      console.error("[TeamMethodsV2] Get team error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch team"
      };
    }
  }
  /**
   *Schema v2.0: Get team members (users with access to this team)
   */
  async getTeamMembers(teamId) {
    try {
      console.log(`[TeamMethodsV2] Getting members for team: ${teamId}`);
      const team = await get(`linear_teams:${teamId}`);
      if (!team) {
        return {
          success: false,
          error: "Team not found"
        };
      }
      const memberIds = await get(`team:${teamId}:members`) || [];
      const members = [];
      for (const userId of memberIds) {
        const userObj = await get(`user:${userId}`);
        const membership = await get(`team:${teamId}:member:${userId}`);
        if (userObj) {
          members.push({
            userId,
            //Schema V2.0: camelCase
            email: userObj.email,
            name: userObj.metadata?.name || userObj.email.split("@")[0],
            role: userObj.role,
            status: userObj.status,
            assignedAt: membership?.assignedAt || membership?.assigned_at,
            //Schema V2.0: camelCase with backward compat
            assignedBy: membership?.assignedBy || membership?.assigned_by
            //Schema V2.0: camelCase with backward compat
          });
        }
      }
      console.log(`[TeamMethodsV2] Found ${members.length} members with team access`);
      return {
        success: true,
        data: {
          members,
          count: members.length
        }
      };
    } catch (error) {
      console.error("[TeamMethodsV2] Get team members error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch team members"
      };
    }
  }
  /**
   *Schema v2.0: Assign user to team (grant team access)
   */
  async assignUserToTeam(userId, teamId, assignedBy) {
    try {
      console.log(`[TeamMethodsV2] Assigning user ${userId} to team ${teamId}`);
      const userObj = await get(`user:${userId}`);
      if (!userObj) {
        return {
          success: false,
          error: "User not found"
        };
      }
      const team = await get(`linear_teams:${teamId}`);
      if (!team) {
        return {
          success: false,
          error: "Team not found"
        };
      }
      const userTeams = await get(`user:${userId}:teams`) || [];
      if (!userTeams.includes(teamId)) {
        userTeams.push(teamId);
        await set(`user:${userId}:teams`, userTeams);
      }
      const teamMembers = await get(`team:${teamId}:members`) || [];
      if (!teamMembers.includes(userId)) {
        teamMembers.push(userId);
        await set(`team:${teamId}:members`, teamMembers);
      }
      const membership = {
        userId,
        //Schema V2.0: camelCase
        teamId,
        //Schema V2.0: camelCase
        assignedAt: (/* @__PURE__ */ new Date()).toISOString(),
        //Schema V2.0: camelCase
        assignedBy
        //Schema V2.0: camelCase
      };
      await set(`team:${teamId}:member:${userId}`, membership);
      console.log(`[TeamMethodsV2] User assigned to team successfully`);
      return {
        success: true,
        data: {
          message: "User assigned to team successfully",
          membership
        }
      };
    } catch (error) {
      console.error("[TeamMethodsV2] Assign user to team error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to assign user to team"
      };
    }
  }
  /**
   *Schema v2.0: Remove user from team (revoke team access)
   */
  async removeUserFromTeam(userId, teamId, removedBy) {
    try {
      console.log(`[TeamMethodsV2] Removing user ${userId} from team ${teamId}`);
      const userTeams = await get(`user:${userId}:teams`) || [];
      const updatedUserTeams = userTeams.filter((id) => id !== teamId);
      await set(`user:${userId}:teams`, updatedUserTeams);
      const teamMembers = await get(`team:${teamId}:members`) || [];
      const updatedTeamMembers = teamMembers.filter((id) => id !== userId);
      await set(`team:${teamId}:members`, updatedTeamMembers);
      await del(`team:${teamId}:member:${userId}`);
      console.log(`[TeamMethodsV2] User removed from team successfully`);
      return {
        success: true,
        data: {
          message: "User removed from team successfully"
        }
      };
    } catch (error) {
      console.error("[TeamMethodsV2] Remove user from team error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to remove user from team"
      };
    }
  }
  /**
   *Schema v2.0: Get teams for a specific customer
   */
  async getTeamsByCustomer(customerId) {
    try {
      console.log(`[TeamMethodsV2] Getting teams for customer: ${customerId}`);
      const customer = await get(`customer:${customerId}`);
      if (!customer) {
        return {
          success: false,
          error: "Customer not found"
        };
      }
      const teamIds = await get(`customer:${customerId}:teams`) || [];
      const teams = [];
      for (const teamId of teamIds) {
        const team = await get(`linear_teams:${teamId}`);
        if (team) {
          teams.push({
            id: team.id,
            name: team.name,
            key: team.key,
            description: team.description,
            state: team.state,
            color: team.color,
            issueCount: team.issueCount || 0
          });
        }
      }
      console.log(`[TeamMethodsV2] Found ${teams.length} teams for customer`);
      return {
        success: true,
        data: {
          teams,
          count: teams.length
        }
      };
    } catch (error) {
      console.error("[TeamMethodsV2] Get teams by customer error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch teams for customer"
      };
    }
  }
  /**
   *Schema v2.0: Check if user has access to team
   * (either through direct assignment or customer membership)
   */
  async checkUserTeamAccess(userId, teamId) {
    try {
      console.log(`[TeamMethodsV2] Checking team access for user ${userId} on team ${teamId}`);
      const userObj = await get(`user:${userId}`);
      if (!userObj) {
        return {
          success: false,
          error: "User not found"
        };
      }
      if (userObj.role === "superadmin" || userObj.role === "admin") {
        return {
          success: true,
          data: {
            hasAccess: true,
            reason: "admin_role"
          }
        };
      }
      const userCustomers = await get(`user:${userId}:customers`) || [];
      for (const customerId of userCustomers) {
        const customerTeams = await get(`customer:${customerId}:teams`) || [];
        if (customerTeams.includes(teamId)) {
          return {
            success: true,
            data: {
              hasAccess: true,
              reason: "customer_member_access",
              customerId
            }
          };
        }
      }
      return {
        success: true,
        data: {
          hasAccess: false,
          reason: "no_access"
        }
      };
    } catch (error) {
      console.error("[TeamMethodsV2] Check user team access error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to check team access"
      };
    }
  }
  /**
   *Schema v2.0: Get all teams accessible by user
   * (includes admin access, direct assignments, and customer-based access)
   */
  async getUserAccessibleTeams(userId) {
    try {
      console.log(`[TeamMethodsV2] Getting accessible teams for user: ${userId}`);
      const userObj = await get(`user:${userId}`);
      if (!userObj) {
        return {
          success: false,
          error: "User not found"
        };
      }
      if (userObj.role === "superadmin" || userObj.role === "admin") {
        const allTeamsResult = await this.getAllTeams();
        if (allTeamsResult.success) {
          return {
            success: true,
            data: {
              teams: allTeamsResult.data.teams,
              count: allTeamsResult.data.count,
              access_reason: "admin_role"
            }
          };
        }
      }
      const accessibleTeamIds = /* @__PURE__ */ new Set();
      const userCustomers = await get(`user:${userId}:customers`) || [];
      for (const customerId of userCustomers) {
        const customerTeams = await get(`customer:${customerId}:teams`) || [];
        for (const teamId of customerTeams) {
          accessibleTeamIds.add(teamId);
        }
      }
      const teams = [];
      for (const teamId of Array.from(accessibleTeamIds)) {
        const team = await get(`linear_teams:${teamId}`);
        if (team) {
          teams.push({
            id: team.id,
            name: team.name,
            key: team.key,
            description: team.description,
            state: team.state,
            color: team.color,
            issueCount: team.issueCount || 0
          });
        }
      }
      console.log(`[TeamMethodsV2] Found ${teams.length} accessible teams for user`);
      return {
        success: true,
        data: {
          teams,
          count: teams.length
        }
      };
    } catch (error) {
      console.error("[TeamMethodsV2] Get user accessible teams error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch accessible teams"
      };
    }
  }
  /**
   *Schema v2.0: Get team hierarchy for user (Customer > Teams structure)
   * Returns teams grouped by customers with parent-child relationships
   */
  async getTeamHierarchy(userId, isSuperAdmin) {
    try {
      console.log(`\uFE0F [TeamMethodsV2] Getting team hierarchy for user: ${userId}, superadmin: ${isSuperAdmin}`);
      let accessibleTeamIds = [];
      if (isSuperAdmin) {
        console.log("[TeamMethodsV2] Superadmin - fetching all teams");
        const teamKeys = await getByPrefix("linear_teams:");
        accessibleTeamIds = teamKeys.filter((key) => !key.includes(":all")).map((key) => key.replace("linear_teams:", ""));
      } else {
        console.log(`[TeamMethodsV2] Loading teams for regular user...`);
        const userCustomers = await get(`user:${userId}:customers`) || [];
        console.log(`[TeamMethodsV2] User belongs to ${userCustomers.length} customers`);
        const accessibleSet = /* @__PURE__ */ new Set();
        for (const customerId of userCustomers) {
          const customerTeams = await get(`customer:${customerId}:teams`) || [];
          console.log(`[TeamMethodsV2] Customer ${customerId} has ${customerTeams.length} teams`);
          for (const teamId of customerTeams) {
            accessibleSet.add(teamId);
            console.log(`[TeamMethodsV2] User has access to team ${teamId} via customer ${customerId}`);
          }
        }
        accessibleTeamIds = Array.from(accessibleSet);
        console.log(`[TeamMethodsV2] User has ${accessibleTeamIds.length} accessible teams (via customer membership)`);
      }
      if (accessibleTeamIds.length === 0) {
        console.log("\uFE0F [TeamMethodsV2] No accessible teams found");
        return {
          success: true,
          data: []
        };
      }
      const customerMap = /* @__PURE__ */ new Map();
      for (const teamId of accessibleTeamIds) {
        let team = await get(`linear_teams:${teamId}`);
        if (typeof team === "string") {
          try {
            team = JSON.parse(team);
          } catch (err) {
            console.warn(`\uFE0F [TeamMethodsV2] Failed to parse team ${teamId}:`, err);
            continue;
          }
        }
        if (!team) {
          console.warn(`\uFE0F [TeamMethodsV2] Team ${teamId} not found in cache`);
          continue;
        }
        const customerKeys = await getByPrefix("customer:");
        for (const customerKey of customerKeys) {
          const customerIdPart = customerKey.replace("customer:", "");
          if (customerIdPart.includes(":")) continue;
          const customerId = customerIdPart;
          const customerTeams = await get(`customer:${customerId}:teams`) || [];
          if (customerTeams.includes(teamId)) {
            if (!customerMap.has(customerId)) {
              let customer = await get(`customer:${customerId}`);
              if (typeof customer === "string") {
                try {
                  customer = JSON.parse(customer);
                } catch (err) {
                  console.warn(`\uFE0F [TeamMethodsV2] Failed to parse customer ${customerId}:`, err);
                  continue;
                }
              }
              if (customer) {
                customerMap.set(customerId, {
                  id: customerId,
                  name: customer.name,
                  key: customer.name.substring(0, 3).toUpperCase(),
                  children: []
                });
              }
            }
            const customerEntry = customerMap.get(customerId);
            if (customerEntry) {
              customerEntry.children.push({
                id: team.id,
                name: team.name,
                key: team.key,
                description: team.description || "",
                level: 1,
                children: []
                // Teams don't have children in current schema
              });
            }
          }
        }
      }
      const hierarchy = Array.from(customerMap.values());
      console.log(`[TeamMethodsV2] Built hierarchy: ${hierarchy.length} customers, ${accessibleTeamIds.length} teams`);
      return {
        success: true,
        data: hierarchy
      };
    } catch (error) {
      console.error("[TeamMethodsV2] Get team hierarchy error:", error);
      console.error("[TeamMethodsV2] Error details:", {
        message: error instanceof Error ? error.message : "Unknown error",
        stack: error instanceof Error ? error.stack : void 0,
        type: typeof error,
        userId
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch team hierarchy"
      };
    }
  }
  /**
   * Get team's current customer assignment
   * CRITICAL: Used to check team ownership exclusivity
   */
  async getTeamCustomer(teamId) {
    try {
      console.log(`[TeamMethodsV2] Getting customer for team: ${teamId}`);
      const customerId = await get(`team:${teamId}:customer`);
      if (!customerId) {
        return {
          success: true,
          data: {
            teamId,
            customerId: null,
            customerName: null,
            isAssigned: false
          }
        };
      }
      const customer = await get(`customer:${customerId}`);
      return {
        success: true,
        data: {
          teamId,
          customerId,
          customerName: customer?.name || "Unknown Customer",
          isAssigned: true
        }
      };
    } catch (error) {
      console.error("[TeamMethodsV2] Get team customer error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get team customer"
      };
    }
  }
};
var teamMethodsV2 = new TeamMethodsV2();

// src/server/routes/adminRoutes.ts
var adminRoutes = new Hono2();
adminRoutes.use("/admin/*", adminMiddleware);
adminRoutes.get("/admin/stats", async (c) => {
  try {
    const user = c.get("user");
    const result = await adminHelpers.getDashboardStats(supabase);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Admin] Get stats error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch dashboard stats"
      },
      { status: 500 }
    );
  }
});
adminRoutes.get("/admin/users", async (c) => {
  try {
    const user = c.get("user");
    const result = await UserMethodsV2.getAllUsers(supabase);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Admin] Get users error:", error);
    return c.json(
      { success: false, error: "Failed to fetch users" },
      { status: 500 }
    );
  }
});
adminRoutes.post("/admin/users", async (c) => {
  try {
    const user = c.get("user");
    const body = await c.req.json();
    const { email, password, name, role, status, customers } = body;
    if (!email || !password) {
      return c.json(
        {
          success: false,
          error: "Email and password are required"
        },
        { status: 400 }
      );
    }
    const result = await UserMethodsV2.createUser(
      { email, password, name, role, status, customers },
      supabase,
      user.id
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data,
      message: "User created successfully"
    });
  } catch (error) {
    console.error("[Admin] Create user error:", error);
    return c.json(
      { success: false, error: "Failed to create user" },
      { status: 500 }
    );
  }
});
adminRoutes.get("/admin/users/:userId", async (c) => {
  try {
    const user = c.get("user");
    const userId = c.req.param("userId");
    const result = await UserMethodsV2.getUserById(userId, supabase);
    if (!result.success) {
      return c.json(
        { success: false, error: result.error },
        {
          status: result.error?.includes("not found") ? 404 : 500
        }
      );
    }
    return c.json({
      success: true,
      data: result.data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Admin] Get user error:", error);
    return c.json(
      { success: false, error: "Failed to fetch user" },
      { status: 500 }
    );
  }
});
adminRoutes.put("/admin/users/:userId", async (c) => {
  try {
    const user = c.get("user");
    const userId = c.req.param("userId");
    const body = await c.req.json();
    const { name, role, status, customers } = body;
    const result = await UserMethodsV2.updateUser(
      userId,
      { name, role, status },
      user.id,
      supabase
      //CRITICAL: Pass supabase to update Auth metadata
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    if (Array.isArray(customers)) {
      const syncResult = await UserMethodsV2.syncCustomerAssignments(
        userId,
        customers,
        user.id
      );
      if (!syncResult.success) {
        console.warn(`\uFE0F [Admin] Customer sync failed:`, syncResult.error);
      } else {
      }
    }
    return c.json({
      success: true,
      data: result.data,
      message: "User updated successfully"
    });
  } catch (error) {
    console.error("[Admin] Update user error:", error);
    return c.json(
      { success: false, error: "Failed to update user" },
      { status: 500 }
    );
  }
});
adminRoutes.delete("/admin/users/:userId", async (c) => {
  try {
    const user = c.get("user");
    const userId = c.req.param("userId");
    const result = await UserMethodsV2.deleteUser(userId, supabase);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      message: "User deleted successfully"
    });
  } catch (error) {
    console.error("[Admin] Delete user error:", error);
    return c.json(
      { success: false, error: "Failed to delete user" },
      { status: 500 }
    );
  }
});
adminRoutes.get("/admin/users/:userId/customers", async (c) => {
  try {
    const userId = c.req.param("userId");
    const result = await UserMethodsV2.getUserCustomers(userId);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Admin] Get user customers error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch user customers"
      },
      { status: 500 }
    );
  }
});
adminRoutes.post("/admin/users/:userId/customers/:customerId", async (c) => {
  try {
    const user = c.get("user");
    const userId = c.req.param("userId");
    const customerId = c.req.param("customerId");
    const result = await UserMethodsV2.assignUserToCustomer(
      userId,
      customerId,
      user.id
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      message: "User assigned to customer successfully"
    });
  } catch (error) {
    console.error("[Admin] Assign user to customer error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to assign user to customer"
      },
      { status: 500 }
    );
  }
});
adminRoutes.delete("/admin/users/:userId/customers/:customerId", async (c) => {
  try {
    const user = c.get("user");
    const userId = c.req.param("userId");
    const customerId = c.req.param("customerId");
    const result = await UserMethodsV2.removeUserFromCustomer(
      userId,
      customerId,
      user.id
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      message: "User removed from customer successfully"
    });
  } catch (error) {
    console.error("[Admin] Remove user from customer error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to remove user from customer"
      },
      { status: 500 }
    );
  }
});
adminRoutes.get("/admin/customers", async (c) => {
  try {
    const user = c.get("user");
    const result = await customerMethodsV2.getAllCustomers();
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Admin] Get customers error:", error);
    return c.json(
      { success: false, error: "Failed to fetch customers" },
      { status: 500 }
    );
  }
});
adminRoutes.post("/admin/customers", async (c) => {
  try {
    const user = c.get("user");
    const body = await c.req.json();
    const { name, status, metadata } = body;
    if (!name) {
      return c.json(
        { success: false, error: "Customer name is required" },
        { status: 400 }
      );
    }
    const result = await customerMethodsV2.createCustomer(
      { name, status, metadata },
      user.id
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data,
      message: "Customer created successfully"
    });
  } catch (error) {
    console.error("[Admin] Create customer error:", error);
    return c.json(
      { success: false, error: "Failed to create customer" },
      { status: 500 }
    );
  }
});
adminRoutes.put("/admin/customers/:customerId", async (c) => {
  try {
    const user = c.get("user");
    const customerId = c.req.param("customerId");
    const body = await c.req.json();
    const { name, status, metadata } = body;
    const result = await customerMethodsV2.updateCustomer(
      customerId,
      { name, status, metadata },
      user.id
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data,
      message: "Customer updated successfully"
    });
  } catch (error) {
    console.error("[Admin] Update customer error:", error);
    return c.json(
      { success: false, error: "Failed to update customer" },
      { status: 500 }
    );
  }
});
adminRoutes.delete("/admin/customers/:customerId", async (c) => {
  try {
    const user = c.get("user");
    const customerId = c.req.param("customerId");
    const result = await customerMethodsV2.deleteCustomer(customerId, user.id);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      message: "Customer deleted successfully"
    });
  } catch (error) {
    console.error("[Admin] Delete customer error:", error);
    return c.json(
      { success: false, error: "Failed to delete customer" },
      { status: 500 }
    );
  }
});
adminRoutes.get("/admin/customers/:customerId/teams", async (c) => {
  try {
    const user = c.get("user");
    const customerId = c.req.param("customerId");
    const result = await customerMethodsV2.getCustomerTeams(customerId);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Admin] Get customer teams error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch customer teams"
      },
      { status: 500 }
    );
  }
});
adminRoutes.post("/admin/customers/:customerId/teams", async (c) => {
  try {
    const admin = c.get("user");
    const customerId = c.req.param("customerId");
    const body = await c.req.json();
    const { linearTeamId, linear_team_id } = body;
    const teamId = linearTeamId || linear_team_id;
    if (!teamId) {
      return c.json(
        { success: false, error: "Team ID is required" },
        { status: 400 }
      );
    }
    const result = await customerMethodsV2.assignTeamToCustomer(
      customerId,
      teamId,
      admin.id
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      message: "Team assigned to customer successfully",
      data: result.data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Admin] Assign team to customer error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to assign team to customer"
      },
      { status: 500 }
    );
  }
});
adminRoutes.delete("/admin/customers/:customerId/teams/:teamId", async (c) => {
  try {
    const admin = c.get("user");
    const customerId = c.req.param("customerId");
    const teamId = c.req.param("teamId");
    const result = await customerMethodsV2.removeTeamFromCustomer(
      customerId,
      teamId
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      message: "Team removed from customer successfully",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Admin] Remove team from customer error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to remove team from customer"
      },
      { status: 500 }
    );
  }
});
adminRoutes.get(
  "/admin/customers/:customerId/teams/:teamId/members",
  async (c) => {
    try {
      const admin = c.get("user");
      const customerId = c.req.param("customerId");
      const teamId = c.req.param("teamId");
      const result = await customerMethodsV2.getCustomerTeamMembers(
        customerId,
        teamId
      );
      if (!result.success) {
        return c.json({ success: false, error: result.error }, { status: 500 });
      }
      return c.json({
        success: true,
        data: result.data,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("[Admin] Get customer team members error:", error);
      return c.json(
        {
          success: false,
          error: error instanceof Error ? error.message : "Failed to fetch team members"
        },
        { status: 500 }
      );
    }
  }
);
adminRoutes.post(
  "/admin/customers/:customerId/teams/:teamId/members",
  async (c) => {
    try {
      const admin = c.get("user");
      const customerId = c.req.param("customerId");
      const teamId = c.req.param("teamId");
      const body = await c.req.json();
      const { userId } = body;
      if (!userId) {
        return c.json(
          { success: false, error: "User ID is required" },
          { status: 400 }
        );
      }
      const result = await customerMethodsV2.addMemberToCustomerTeam(
        customerId,
        teamId,
        userId,
        admin.id
      );
      if (!result.success) {
        return c.json({ success: false, error: result.error }, { status: 500 });
      }
      return c.json({
        success: true,
        message: "Member added to team successfully",
        data: result.data,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("[Admin] Add member to team error:", error);
      return c.json(
        {
          success: false,
          error: error instanceof Error ? error.message : "Failed to add member to team"
        },
        { status: 500 }
      );
    }
  }
);
adminRoutes.delete(
  "/admin/customers/:customerId/teams/:teamId/members/:userId",
  async (c) => {
    try {
      const admin = c.get("user");
      const customerId = c.req.param("customerId");
      const teamId = c.req.param("teamId");
      const userId = c.req.param("userId");
      const result = await customerMethodsV2.removeMemberFromCustomerTeam(
        customerId,
        teamId,
        userId,
        admin.id
      );
      if (!result.success) {
        return c.json({ success: false, error: result.error }, { status: 500 });
      }
      return c.json({
        success: true,
        message: "Member removed from team successfully",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("[Admin] Remove member from team error:", error);
      return c.json(
        {
          success: false,
          error: error instanceof Error ? error.message : "Failed to remove member from team"
        },
        { status: 500 }
      );
    }
  }
);
adminRoutes.get("/admin/customers/:customerId/members", async (c) => {
  try {
    const user = c.get("user");
    const customerId = c.req.param("customerId");
    const memberIds = await get(`customer:${customerId}:members`) || [];
    const members = [];
    for (const userId of memberIds) {
      const userData = await get(`user:${userId}`);
      const membershipData = await get(
        `customer:${customerId}:member:${userId}`
      );
      if (userData) {
        const user2 = typeof userData === "string" ? JSON.parse(userData) : userData;
        const membership = typeof membershipData === "string" ? JSON.parse(membershipData) : membershipData;
        members.push({
          userId: user2.id,
          //Schema V2.0: camelCase
          email: user2.email,
          name: user2.metadata?.name || user2.email.split("@")[0],
          role: user2.role || "viewer",
          status: user2.status || "active",
          assignedAt: membership?.assignedAt || user2.createdAt,
          //Schema V2.0: Include membership date
          assignedBy: membership?.assignedBy
          //Schema V2.0: Who assigned the user
        });
      }
    }
    return c.json({
      success: true,
      data: {
        members,
        count: members.length,
        customerId
      },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Admin] Get customer members error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch customer members"
      },
      { status: 500 }
    );
  }
});
adminRoutes.post("/admin/customers/:customerId/members", async (c) => {
  try {
    const admin = c.get("user");
    const customerId = c.req.param("customerId");
    const body = await c.req.json();
    const { userId } = body;
    if (!userId) {
      return c.json(
        { success: false, error: "User ID is required" },
        { status: 400 }
      );
    }
    const members = await get(`customer:${customerId}:members`) || [];
    if (members.includes(userId)) {
      return c.json({
        success: true,
        message: "User already assigned to customer",
        data: { customerId, userId }
      });
    }
    const result = await UserMethodsV2.assignUserToCustomer(
      userId,
      customerId,
      admin.id
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      message: "User added to customer successfully",
      data: { customerId, userId }
    });
  } catch (error) {
    console.error("[Admin] Add customer member error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to add customer member"
      },
      { status: 500 }
    );
  }
});
adminRoutes.delete(
  "/admin/customers/:customerId/members/:userId",
  async (c) => {
    try {
      const admin = c.get("user");
      const customerId = c.req.param("customerId");
      const userId = c.req.param("userId");
      const members = await get(`customer:${customerId}:members`) || [];
      const updatedMembers = members.filter((id) => id !== userId);
      await set(`customer:${customerId}:members`, updatedMembers);
      const userCustomers = await get(`user:${userId}:customers`) || [];
      const updatedCustomers = userCustomers.filter(
        (id) => id !== customerId
      );
      await set(`user:${userId}:customers`, updatedCustomers);
      return c.json({
        success: true,
        message: "User removed from customer successfully"
      });
    } catch (error) {
      console.error("[Admin] Remove customer member error:", error);
      return c.json(
        {
          success: false,
          error: error instanceof Error ? error.message : "Failed to remove customer member"
        },
        { status: 500 }
      );
    }
  }
);
adminRoutes.get("/admin/teams/:teamId/customer", async (c) => {
  try {
    const admin = c.get("user");
    const teamId = c.req.param("teamId");
    const result = await teamMethodsV2.getTeamCustomer(teamId);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Admin] Get team customer error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get team customer"
      },
      { status: 500 }
    );
  }
});
adminRoutes.get("/admin/customers/:customerId/available-teams", async (c) => {
  try {
    const admin = c.get("user");
    const customerId = c.req.param("customerId");
    const result = await teamMethodsV2.getAvailableTeamsForCustomer(customerId);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Admin] Get available teams error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to get available teams"
      },
      { status: 500 }
    );
  }
});
adminRoutes.get(
  "/admin/customers/:customerId/teams/:teamId/members",
  async (c) => {
    try {
      const admin = c.get("user");
      const customerId = c.req.param("customerId");
      const teamId = c.req.param("teamId");
      const result = await customerMethodsV2.getCustomerTeamMembers(
        customerId,
        teamId
      );
      if (!result.success) {
        return c.json({ success: false, error: result.error }, { status: 500 });
      }
      return c.json({
        success: true,
        data: result.data,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("[Admin] Get customer team members error:", error);
      return c.json(
        {
          success: false,
          error: error instanceof Error ? error.message : "Failed to fetch team members"
        },
        { status: 500 }
      );
    }
  }
);
adminRoutes.get("/admin/activity", async (c) => {
  try {
    const user = c.get("user");
    const limit = parseInt(c.req.query("limit") || "50");
    const offset = parseInt(c.req.query("offset") || "0");
    const result = await adminHelpers.getActivityLogs({
      limit,
      offset
    });
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Admin] Get activity logs error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch activity logs"
      },
      { status: 500 }
    );
  }
});
adminRoutes.get("/admin/roles", async (c) => {
  try {
    const user = c.get("user");
    const result = await adminHelpers.getRoleDefinitions();
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Admin] Get role definitions error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch role definitions"
      },
      { status: 500 }
    );
  }
});

// src/server/routes/userRoutes.ts
init_authHelpers();
init_kv_store();
import { Hono as Hono3 } from "hono";
var userRoutes = new Hono3();
userRoutes.get("/user/teams", authMiddleware, async (c) => {
  try {
    const userId = c.get("userId");
    const userEmail = c.get("userEmail");
    const role = c.get("role");
    const isSuperAdmin = c.get("isSuperAdmin");
    if (isSuperAdmin || role === "admin") {
      const cachedHierarchy = await get("linear_teams:all");
      let teams2 = [];
      if (cachedHierarchy) {
        const parsedCache = typeof cachedHierarchy === "string" ? JSON.parse(cachedHierarchy) : cachedHierarchy;
        teams2 = parsedCache.teams || [];
      }
      return c.json({
        success: true,
        data: {
          teams: teams2,
          count: teams2.length,
          access: "all",
          reason: isSuperAdmin ? "superadmin" : "admin"
        }
      });
    }
    const userCustomers = await get(`user:${userId}:customers`) || [];
    if (userCustomers.length === 0) {
      return c.json({
        success: true,
        data: {
          teams: [],
          count: 0,
          access: "none",
          reason: "no_customer_assignment"
        }
      });
    }
    const accessibleTeams = /* @__PURE__ */ new Set();
    const teamMembershipMap = /* @__PURE__ */ new Map();
    for (const customerId of userCustomers) {
      const customerTeams = await get(`customer:${customerId}:teams`) || [];
      if (customerTeams.length === 0) {
        console.warn(`   \uFE0F No teams assigned to this customer`);
        continue;
      }
      for (const teamId of customerTeams) {
        const teamMembersKey = `customer:${customerId}:team:${teamId}:members`;
        const teamMembers = await get(teamMembersKey) || [];
        if (teamMembers.includes(userId)) {
          accessibleTeams.add(teamId);
          teamMembershipMap.set(teamId, customerId);
        } else {
        }
      }
    }
    if (accessibleTeams.size === 0) {
      console.error(
        `
========== NO TEAMS ACCESSIBLE! ==========`
      );
      console.error(`Possible causes:`);
      console.error(`  1. User not assigned to any customer`);
      console.error(`  2. Customer has no teams assigned`);
      console.error(
        `  3. User not added to team-level members (Schema V2.0)`
      );
      console.error(`  4. Empty KV keys for team members`);
      console.error(`
Next Steps:`);
      console.error(
        `  1. Check backend logs for detailed info`
      );
      console.error(`  2. Verify KV storage keys:`);
      console.error(`     - user:{userId}:customers`);
      console.error(`     - customer:{customerId}:teams`);
      console.error(
        `     - customer:{customerId}:team:{teamId}:members`
      );
      console.error(
        `  3. Admin: Open Team Assignment \u2192 Manage Team Members \u2192 Add user`
      );
      console.error(
        `===============================================
`
      );
      let totalCustomerTeams = 0;
      for (const customerId of userCustomers) {
        const customerTeams = await get(`customer:${customerId}:teams`) || [];
        totalCustomerTeams += customerTeams.length;
      }
      console.error(`Diagnostic Summary:`);
      console.error(`  - User ID: ${userId}`);
      console.error(`  - Email: ${userEmail}`);
      console.error(
        `  - Customers assigned: ${userCustomers.length}`
      );
      console.error(
        `  - Total teams across customers: ${totalCustomerTeams}`
      );
      console.error(`  - Teams user is member of: 0`);
    }
    const teams = [];
    for (const teamId of accessibleTeams) {
      let team = await get(`linear_teams:${teamId}`);
      if (typeof team === "string") {
        try {
          team = JSON.parse(team);
        } catch (err) {
          console.warn(
            `\uFE0F [UserRoutes] Failed to parse team ${teamId}`
          );
          continue;
        }
      }
      if (team && team.id) {
        teams.push({
          id: team.id,
          name: team.name,
          key: team.key,
          description: team.description
        });
      }
    }
    return c.json({
      success: true,
      data: {
        teamIds: Array.from(accessibleTeams),
        //Return team IDs for PermissionContext
        teams,
        count: teams.length,
        permissionModel: "team-level",
        //Granular team-level access
        customerCount: userCustomers.length
      }
    });
  } catch (error) {
    console.error(
      "[UserRoutes] Error fetching user teams:",
      error
    );
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch user teams"
      },
      { status: 500 }
    );
  }
});
userRoutes.get(
  "/user/teams/:teamId/access",
  authMiddleware,
  async (c) => {
    try {
      const userId = c.get("userId");
      const userEmail = c.get("userEmail");
      const role = c.get("role");
      const isSuperAdmin = c.get("isSuperAdmin");
      const teamId = c.req.param("teamId");
      const getTeamName = async (id) => {
        let team = await get(`linear_teams:${id}`);
        if (typeof team === "string") {
          try {
            team = JSON.parse(team);
          } catch (err) {
            console.warn(
              `\uFE0F [UserRoutes] Failed to parse team ${id} from cache`
            );
            team = null;
          }
        }
        if (team?.name) {
          return team.name;
        }
        try {
          const { LinearTeamService: LinearTeamService2 } = await Promise.resolve().then(() => (init_linearTeamService(), linearTeamService_exports));
          const linearService2 = new LinearTeamService2();
          const teamData = await linearService2.getTeamById(id);
          if (teamData?.name) {
            await set(`linear_teams:${id}`, teamData);
            return teamData.name;
          }
        } catch (err) {
          console.error(
            `[UserRoutes] Failed to fetch team from Linear API:`,
            err
          );
        }
        console.warn(
          `\uFE0F [UserRoutes] Could not get team name for ${id}, using ID as fallback`
        );
        return id;
      };
      if (isSuperAdmin || role === "admin") {
        const teamName = await getTeamName(teamId);
        return c.json({
          success: true,
          hasAccess: true,
          accessType: "customer-level",
          role: isSuperAdmin ? "superadmin" : "admin",
          teamName,
          teamId
        });
      }
      const userCustomers = await get(`user:${userId}:customers`) || [];
      for (const customerId of userCustomers) {
        const customerTeams = await get(`customer:${customerId}:teams`) || [];
        if (customerTeams.includes(teamId)) {
          const teamName = await getTeamName(teamId);
          return c.json({
            success: true,
            hasAccess: true,
            accessType: "customer-level",
            role,
            teamName,
            customerId,
            teamId
          });
        }
      }
      return c.json({
        success: true,
        hasAccess: false,
        accessType: null,
        teamId
      });
    } catch (error) {
      console.error(
        "[UserRoutes] Error checking team access:",
        error
      );
      return c.json(
        {
          success: false,
          error: error instanceof Error ? error.message : "Failed to check team access"
        },
        { status: 500 }
      );
    }
  }
);
userRoutes.get(
  "/user/teams/:teamId/kanban-settings",
  authMiddleware,
  async (c) => {
    try {
      const userId = c.get("userId");
      const teamId = c.req.param("teamId");
      const settingsKey = `user:${userId}:team:${teamId}:kanban_settings`;
      const settings = await get(settingsKey);
      if (!settings) {
        return c.json(
          { success: true, data: null },
          { status: 404 }
        );
      }
      return c.json({
        success: true,
        data: settings
      });
    } catch (error) {
      console.error(
        "[UserRoutes] Error fetching Kanban settings:",
        error
      );
      return c.json(
        {
          success: false,
          error: error instanceof Error ? error.message : "Failed to fetch Kanban settings"
        },
        { status: 500 }
      );
    }
  }
);
userRoutes.put(
  "/user/teams/:teamId/kanban-settings",
  authMiddleware,
  async (c) => {
    try {
      const userId = c.get("userId");
      const teamId = c.req.param("teamId");
      const settings = await c.req.json();
      if (!settings.columnsOrder || !Array.isArray(settings.columnsOrder)) {
        return c.json(
          {
            success: false,
            error: "Invalid settings: columnsOrder is required and must be an array"
          },
          { status: 400 }
        );
      }
      const settingsWithMetadata = {
        ...settings,
        teamId,
        userId,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const settingsKey = `user:${userId}:team:${teamId}:kanban_settings`;
      await set(settingsKey, settingsWithMetadata);
      return c.json({
        success: true,
        message: "Kanban settings saved successfully"
      });
    } catch (error) {
      console.error(
        "[UserRoutes] Error saving Kanban settings:",
        error
      );
      return c.json(
        {
          success: false,
          error: error instanceof Error ? error.message : "Failed to save Kanban settings"
        },
        { status: 500 }
      );
    }
  }
);
userRoutes.delete(
  "/user/teams/:teamId/kanban-settings",
  authMiddleware,
  async (c) => {
    try {
      const userId = c.get("userId");
      const teamId = c.req.param("teamId");
      const settingsKey = `user:${userId}:team:${teamId}:kanban_settings`;
      await del(settingsKey);
      return c.json({
        success: true,
        message: "Kanban settings deleted successfully"
      });
    } catch (error) {
      console.error(
        "[UserRoutes] Error deleting Kanban settings:",
        error
      );
      return c.json(
        {
          success: false,
          error: error instanceof Error ? error.message : "Failed to delete Kanban settings"
        },
        { status: 500 }
      );
    }
  }
);

// src/server/routes/teamRoutes.ts
init_authHelpers();
import { Hono as Hono4 } from "hono";
init_kv_store();
var teamRoutes = new Hono4();
teamRoutes.use("*", authMiddleware);
teamRoutes.get("/teams/my-teams", async (c) => {
  try {
    const user = c.get("user");
    const result = await teamMethodsV2.getUserTeams(user.id);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Teams] Get user teams error:", error);
    return c.json(
      { success: false, error: "Failed to fetch user teams" },
      { status: 500 }
    );
  }
});
teamRoutes.get("/teams/hierarchy", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    const isSuperAdmin = c.get("isSuperAdmin");
    const userPermissions = c.get("userPermissions");
    if (!user || !user.id) {
      console.error("[Teams] Missing user context in request");
      return c.json(
        { success: false, error: "Authentication required" },
        { status: 401 }
      );
    }
    const result = await teamMethodsV2.getTeamHierarchy(user.id, isSuperAdmin);
    if (!result.success) {
      console.error(`[Teams] getTeamHierarchy failed:`, result.error);
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Teams] Get hierarchy error:", error);
    return c.json(
      { success: false, error: "Failed to fetch team hierarchy" },
      { status: 500 }
    );
  }
});
teamRoutes.get("/teams/:teamId/access", async (c) => {
  try {
    const user = c.get("user");
    const teamId = c.req.param("teamId");
    const result = await teamMethodsV2.checkUserTeamAccess(user.id, teamId);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 403 });
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Teams] Check team access error:", error);
    return c.json(
      { success: false, error: "Failed to check team access" },
      { status: 500 }
    );
  }
});
teamRoutes.get("/teams/:teamId", async (c) => {
  try {
    const user = c.get("user");
    const teamId = c.req.param("teamId");
    const includeHierarchy = c.req.query("includeHierarchy") !== "false";
    const accessCheck = await teamMethodsV2.checkUserTeamAccess(
      user.id,
      teamId
    );
    if (!accessCheck.success) {
      return c.json(
        { success: false, error: "Access denied" },
        { status: 403 }
      );
    }
    const result = await teamMethodsV2.getTeamById(teamId, includeHierarchy);
    if (!result.success) {
      return c.json(
        { success: false, error: result.error },
        { status: result.error === "Team not found" ? 404 : 500 }
      );
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Teams] Get team error:", error);
    return c.json(
      { success: false, error: "Failed to fetch team" },
      { status: 500 }
    );
  }
});
teamRoutes.get("/teams", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    const includeHierarchy = c.req.query("includeHierarchy") === "true";
    const result = await teamMethodsV2.getAllTeams(includeHierarchy);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Teams] Get all teams error:", error);
    return c.json(
      { success: false, error: "Failed to fetch teams" },
      { status: 500 }
    );
  }
});
teamRoutes.post("/teams", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    if (role !== "admin" && role !== "superadmin") {
      return c.json(
        { success: false, error: "Admin access required" },
        { status: 403 }
      );
    }
    const body = await c.req.json();
    const { customer_id, name, linear_team_id, linear_team_key } = body;
    if (!customer_id || !name) {
      return c.json(
        { success: false, error: "customer_id and name are required" },
        { status: 400 }
      );
    }
    const result = await teamMethodsV2.createTeam(
      { customer_id, name, linear_team_id, linear_team_key },
      user.id
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data,
      message: "Team created successfully"
    });
  } catch (error) {
    console.error("[Teams] Create team error:", error);
    return c.json(
      { success: false, error: "Failed to create team" },
      { status: 500 }
    );
  }
});
teamRoutes.put("/teams/:teamId", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    const teamId = c.req.param("teamId");
    if (role !== "admin" && role !== "superadmin") {
      return c.json(
        { success: false, error: "Admin access required" },
        { status: 403 }
      );
    }
    const body = await c.req.json();
    const { name, linear_team_id, linear_team_key, status } = body;
    const result = await teamMethodsV2.updateTeam(
      teamId,
      { name, linear_team_id, linear_team_key, status },
      user.id
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data,
      message: "Team updated successfully"
    });
  } catch (error) {
    console.error("[Teams] Update team error:", error);
    return c.json(
      { success: false, error: "Failed to update team" },
      { status: 500 }
    );
  }
});
teamRoutes.delete("/teams/:teamId", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    const teamId = c.req.param("teamId");
    if (role !== "admin" && role !== "superadmin") {
      return c.json(
        { success: false, error: "Admin access required" },
        { status: 403 }
      );
    }
    const result = await teamMethodsV2.deleteTeam(teamId, user.id);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      message: "Team deleted successfully"
    });
  } catch (error) {
    console.error("[Teams] Delete team error:", error);
    return c.json(
      { success: false, error: "Failed to delete team" },
      { status: 500 }
    );
  }
});
teamRoutes.post("/teams/sync-from-linear", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    if (role !== "admin" && role !== "superadmin") {
      return c.json(
        { success: false, error: "Admin access required" },
        { status: 403 }
      );
    }
    const { LinearTeamService: LinearTeamService2 } = await Promise.resolve().then(() => (init_linearTeamService(), linearTeamService_exports));
    const linearService2 = new LinearTeamService2();
    const linearResult = await linearService2.listTeams();
    if (!linearResult.success || !linearResult.teams) {
      console.error(
        "[Teams] Failed to fetch teams from Linear:",
        linearResult.message
      );
      return c.json(
        {
          success: false,
          error: linearResult.message || "Failed to fetch teams from Linear"
        },
        { status: 500 }
      );
    }
    const teams = linearResult.teams;
    let syncedCount = 0;
    let errorCount = 0;
    for (const team of teams) {
      try {
        const teamKey = `linear_teams:${team.id}`;
        await set(teamKey, {
          id: team.id,
          name: team.name,
          key: team.key,
          description: team.description || "",
          state: "active",
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          updated_at: (/* @__PURE__ */ new Date()).toISOString(),
          synced_from_linear: true,
          last_sync: (/* @__PURE__ */ new Date()).toISOString()
        });
        syncedCount++;
      } catch (error) {
        errorCount++;
        console.error(`[Teams] Failed to sync team ${team.name}:`, error);
      }
    }
    return c.json({
      success: true,
      data: {
        total: teams.length,
        synced: syncedCount,
        errors: errorCount
      },
      message: `Successfully synced ${syncedCount} teams from Linear`
    });
  } catch (error) {
    console.error("[Teams] Sync from Linear error:", error);
    return c.json(
      { success: false, error: "Failed to sync teams from Linear" },
      { status: 500 }
    );
  }
});
teamRoutes.get("/teams/:teamId/members", async (c) => {
  try {
    const user = c.get("user");
    const teamId = c.req.param("teamId");
    const accessCheck = await teamMethodsV2.checkUserTeamAccess(
      user.id,
      teamId
    );
    if (!accessCheck.success) {
      return c.json(
        { success: false, error: "Access denied to this team" },
        { status: 403 }
      );
    }
    const result = await teamMethodsV2.getTeamMembers(teamId);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Teams] Get team members error:", error);
    return c.json(
      { success: false, error: "Failed to fetch team members" },
      { status: 500 }
    );
  }
});
teamRoutes.post("/teams/:teamId/members/:userId", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    const teamId = c.req.param("teamId");
    const userId = c.req.param("userId");
    if (role !== "admin" && role !== "superadmin" && role !== "client_manager") {
      return c.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }
    const result = await teamMethodsV2.addMemberToTeam(teamId, userId, user.id);
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      message: "Member added to team successfully"
    });
  } catch (error) {
    console.error("[Teams] Add member error:", error);
    return c.json(
      { success: false, error: "Failed to add member to team" },
      { status: 500 }
    );
  }
});
teamRoutes.delete("/teams/:teamId/members/:userId", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    const teamId = c.req.param("teamId");
    const userId = c.req.param("userId");
    if (role !== "admin" && role !== "superadmin" && role !== "client_manager") {
      return c.json(
        { success: false, error: "Insufficient permissions" },
        { status: 403 }
      );
    }
    const result = await teamMethodsV2.removeMemberFromTeam(
      teamId,
      userId,
      user.id
    );
    if (!result.success) {
      return c.json({ success: false, error: result.error }, { status: 500 });
    }
    return c.json({
      success: true,
      message: "Member removed from team successfully"
    });
  } catch (error) {
    console.error("[Teams] Remove member error:", error);
    return c.json(
      { success: false, error: "Failed to remove member from team" },
      { status: 500 }
    );
  }
});

// src/server/routes/linearRoutes.ts
init_authHelpers();
init_linearTeamService();
import { Hono as Hono5 } from "hono";
import { createClient as createClient5 } from "@supabase/supabase-js";

// src/server/services/linearTeamIssuesService.ts
import { createClient as createClient4 } from "@supabase/supabase-js";

// src/server/helpers/linearGraphQL.ts
var FRAGMENTS = {
  /**
   * User/Member fields (basic)
   */
  USER_FIELDS: `
    id
    name
    email
    avatarUrl
  `,
  USER_WITH_ACTIVE: `
    id
    name
    email
    avatarUrl
    active
  `,
  /**
   * State fields
   */
  STATE_BASIC: `
    id
    name
    type
  `,
  STATE_FULL: `
    id
    name
    type
    position
    color
    description
  `,
  /**
   * Label fields
   */
  LABEL_BASIC: `
    id
    name
    color
  `,
  LABEL_FULL: `
    id
    name
    color
    description
  `,
  /**
   * Project fields
   */
  PROJECT_BASIC: `
    id
    name
    icon
    color
  `,
  PROJECT_FULL: `
    id
    name
    description
    state
    color
    icon
    startedAt
    targetDate
  `,
  /**
   * Comment fields
   */
  COMMENT_WITH_USER: `
    id
    body
    createdAt
    user {
      id
      name
      avatarUrl
    }
  `,
  /**
   * Attachment fields
   */
  ATTACHMENT_FIELDS: `
    id
    title
    url
    createdAt
  `,
  /**
   * Issue core fields (without relationships)
   */
  ISSUE_CORE: `
    id
    identifier
    title
    description
    url
    priority
    createdAt
    updatedAt
  `
};
var COMPOSITE_FRAGMENTS = {
  /**
   * Team configuration (full team details)
   */
  TEAM_CONFIG: `
    id
    name
    key
    description
    timezone
    states {
      nodes {
        ${FRAGMENTS.STATE_FULL}
      }
    }
    labels {
      nodes {
        ${FRAGMENTS.LABEL_FULL}
      }
    }
    projects {
      nodes {
        ${FRAGMENTS.PROJECT_FULL}
      }
    }
    members {
      nodes {
        ${FRAGMENTS.USER_WITH_ACTIVE}
      }
    }
  `
};
var LINEAR_QUERIES = {
  /**
   * Get team configuration with full details
   * Used for: Team settings, workflow configuration
   */
  GET_TEAM_CONFIG: `
    query GetTeamConfig($teamId: String!) {
      team(id: $teamId) {
        ${COMPOSITE_FRAGMENTS.TEAM_CONFIG}
      }
    }
  `,
  /**
   * Get all team issues (OPTIMIZED for Kanban with pagination)
   * NO comments, NO attachments (reduces bandwidth by 87%)
   */
  GET_ALL_TEAM_ISSUES: `
    query GetAllTeamIssues($teamId: ID!, $after: String) {
      issues(
        filter: { 
          team: { id: { eq: $teamId } } 
        }
        first: 200
        after: $after
        orderBy: updatedAt
      ) {
        nodes {
          ${FRAGMENTS.ISSUE_CORE}
          priority
          priorityLabel
          estimate
          dueDate
          state {
            ${FRAGMENTS.STATE_FULL}
          }
          assignee {
            ${FRAGMENTS.USER_FIELDS}
          }
          creator {
            ${FRAGMENTS.USER_FIELDS}
          }
          project {
            ${FRAGMENTS.PROJECT_BASIC}
          }
          labels {
            nodes {
              ${FRAGMENTS.LABEL_BASIC}
            }
          }
          completedAt
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
  `,
  /**
   * Get issues in specific state (OPTIMIZED for Kanban columns)
   * Includes parent-child relationships for hierarchy
   * NO deep nesting (1 level only)
   */
  GET_ISSUES_IN_STATE: `
    query GetIssuesInState($teamId: ID!, $stateId: ID!, $after: String) {
      issues(
        filter: { 
          team: { id: { eq: $teamId } }, 
          state: { id: { eq: $stateId } } 
        }
        first: 100
        after: $after
      ) {
        nodes {
          ${FRAGMENTS.ISSUE_CORE}
          parent {
            id
            identifier
            title
          }
          state {
            ${FRAGMENTS.STATE_BASIC}
          }
          assignee {
            ${FRAGMENTS.USER_FIELDS}
          }
          project {
            ${FRAGMENTS.PROJECT_BASIC}
          }
          labels {
            nodes {
              ${FRAGMENTS.LABEL_BASIC}
            }
          }
          children {
            nodes {
              id
              identifier
              title
              url
              state {
                ${FRAGMENTS.STATE_FULL}
              }
              assignee {
                ${FRAGMENTS.USER_FIELDS}
              }
              labels {
                nodes {
                  ${FRAGMENTS.LABEL_BASIC}
                }
              }
              priority
              priorityLabel
            }
          }
          priority
          priorityLabel
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
  `,
  /**
   * Get full issue detail (for modal)
   * INCLUDES: Comments, attachments, children
   * PERFORMANCE: Reduced comments to 50 (most issues have < 50 comments)
   */
  GET_ISSUE_DETAIL: `
    query GetIssueDetail($issueId: String!) {
      issue(id: $issueId) {
        ${FRAGMENTS.ISSUE_CORE}
        estimate
        dueDate
        completedAt
        priorityLabel
        state {
          ${FRAGMENTS.STATE_FULL}
        }
        team {
          id
          name
          key
        }
        project {
          id
          name
          description
          color
          icon
        }
        assignee {
          ${FRAGMENTS.USER_WITH_ACTIVE}
        }
        creator {
          ${FRAGMENTS.USER_FIELDS}
        }
        parent {
          id
          identifier
          title
        }
        labels {
          nodes {
            ${FRAGMENTS.LABEL_FULL}
          }
        }
        comments(first: 50, orderBy: createdAt) {
          nodes {
            ${FRAGMENTS.COMMENT_WITH_USER}
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
        attachments {
          nodes {
            ${FRAGMENTS.ATTACHMENT_FIELDS}
          }
        }
        children(first: 50) {
          nodes {
            id
            identifier
            title
            description
            url
            priority
            priorityLabel
            state {
              ${FRAGMENTS.STATE_FULL}
            }
            assignee {
              ${FRAGMENTS.USER_FIELDS}
            }
          }
        }
      }
    }
  `,
  /**
   * Get customer deliverables (filtered by project and states)
   * Used for: Client UAT board
   */
  GET_CUSTOMER_DELIVERABLES: `
    query GetCustomerDeliverables($teamId: ID!, $projectName: String!, $states: [String!], $after: String) {
      issues(
        filter: {
          team: { id: { eq: $teamId } },
          project: { name: { eq: $projectName } },
          state: { name: { in: $states } }
        }
        orderBy: updatedAt
        first: 100
        after: $after
      ) {
        nodes {
          ${FRAGMENTS.ISSUE_CORE}
          state {
            ${FRAGMENTS.STATE_BASIC}
          }
          assignee {
            ${FRAGMENTS.USER_FIELDS}
          }
          project {
            ${FRAGMENTS.PROJECT_BASIC}
          }
          labels {
            nodes {
              ${FRAGMENTS.LABEL_BASIC}
            }
          }
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
  `
};
var LINEAR_MUTATIONS = {
  /**
   * Update issue state
   */
  UPDATE_ISSUE_STATE: `
    mutation UpdateIssueState($issueId: String!, $stateId: String!) {
      issueUpdate(id: $issueId, input: { stateId: $stateId }) {
        success
        issue {
          id
          identifier
          state {
            ${FRAGMENTS.STATE_BASIC}
          }
        }
      }
    }
  `,
  /**
   * Add comment to issue
   */
  ADD_COMMENT: `
    mutation AddComment($issueId: String!, $body: String!) {
      commentCreate(input: { issueId: $issueId, body: $body }) {
        success
        comment {
          ${FRAGMENTS.COMMENT_WITH_USER}
        }
      }
    }
  `,
  /**
   * Create new issue
   */
  CREATE_ISSUE: `
    mutation CreateIssue($teamId: String!, $title: String!, $description: String, $stateId: String, $priority: Int, $assigneeId: String, $labelIds: [String!]) {
      issueCreate(input: {
        teamId: $teamId,
        title: $title,
        description: $description,
        stateId: $stateId,
        priority: $priority,
        assigneeId: $assigneeId,
        labelIds: $labelIds
      }) {
        success
        issue {
          ${FRAGMENTS.ISSUE_CORE}
          state {
            ${FRAGMENTS.STATE_BASIC}
          }
          priority
          assignee {
            ${FRAGMENTS.USER_FIELDS}
          }
          labels {
            nodes {
              ${FRAGMENTS.LABEL_BASIC}
            }
          }
        }
      }
    }
  `,
  /**
   * Delete issue
   */
  DELETE_ISSUE: `
    mutation DeleteIssue($issueId: String!) {
      issueDelete(id: $issueId) {
        success
      }
    }
  `,
  /**
   * Update issue fields
   */
  UPDATE_ISSUE: `
    mutation UpdateIssue($issueId: String!, $title: String, $description: String, $priority: Int, $assigneeId: String, $stateId: String, $labelIds: [String!]) {
      issueUpdate(id: $issueId, input: {
        title: $title,
        description: $description,
        priority: $priority,
        assigneeId: $assigneeId,
        stateId: $stateId,
        labelIds: $labelIds
      }) {
        success
        issue {
          ${FRAGMENTS.ISSUE_CORE}
          priority
          state {
            ${FRAGMENTS.STATE_BASIC}
          }
          assignee {
            ${FRAGMENTS.USER_FIELDS}
          }
          labels {
            nodes {
              ${FRAGMENTS.LABEL_BASIC}
            }
          }
          updatedAt
        }
      }
    }
  `
};

// src/server/services/linearTeamIssuesService.ts
init_kv_store();
var LINEAR_API_URL = "https://api.linear.app/graphql";
async function getLinearApiKey() {
  const envKey = process.env.LINEAR_API_KEY;
  if (envKey) {
    return envKey;
  }
  try {
    const supabase4 = createClient4(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    const { data, error } = await supabase4.from("kv_store_7f0d90fb").select("value").eq("key", "linear_api_key").single();
    if (error || !data?.value) {
      throw new Error(
        "Linear API key not found in environment or KV store"
      );
    }
    return data.value;
  } catch (error) {
    console.error("Failed to get Linear API key:", error);
    throw new Error("Linear API key not configured");
  }
}
async function executeLinearQuery(query, variables = {}) {
  const requestId = Math.random().toString(36).substr(2, 9);
  const startTime = Date.now();
  try {
    const apiKey = await getLinearApiKey();
    const queryNameMatch = query.match(
      /(?:query|mutation)\s+(\w+)/
    );
    const queryName = queryNameMatch ? queryNameMatch[1] : "UnknownQuery";
    const requestPayload = {
      query,
      variables
    };
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 1e4);
    const response = await fetch(LINEAR_API_URL, {
      method: "POST",
      headers: {
        Authorization: apiKey,
        "Content-Type": "application/json",
        "User-Agent": "Teifi-Digital-Client-Portal/1.0",
        "public-file-urls-expire-in": "3600"
        // 1 hour signed URLs for attachments
      },
      body: JSON.stringify(requestPayload),
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    const responseTime = Date.now() - startTime;
    if (responseTime > 1e3 || !response.ok) {
      console.log(
        `[${requestId}] [Linear API] ${queryName} - ${responseTime}ms (${response.status})`
      );
    }
    if (!response.ok) {
      const errorText = await response.text();
      console.error(
        `[${requestId}] [Linear API] HTTP Error for ${queryName}:`,
        {
          status: response.status,
          statusText: response.statusText,
          responseBody: errorText,
          headers: Object.fromEntries(
            response.headers.entries()
          )
        }
      );
      throw new Error(
        `Linear API HTTP Error: ${response.status} ${response.statusText} - ${errorText}`
      );
    }
    const result = await response.json();
    if (result.errors && result.errors.length > 0) {
      console.error(
        `[${requestId}] [Linear API] GraphQL Errors for ${queryName}:`,
        {
          errors: result.errors,
          query: queryName,
          variables,
          fullResponse: result
        }
      );
      console.error(
        `[${requestId}] [Linear API] Failed Query Details:`
      );
      console.error(
        `[${requestId}] [Linear API] Query Name: ${queryName}`
      );
      console.error(
        `[${requestId}] [Linear API] Variables: ${JSON.stringify(variables, null, 2)}`
      );
      console.error(
        `[${requestId}] [Linear API] Query Text: ${query}`
      );
      const errorMessage = result.errors[0]?.message || "Unknown GraphQL error";
      if (errorMessage.includes("Variable") && errorMessage.includes("type") && errorMessage.includes("expecting")) {
        console.error(
          `[${requestId}] [Linear API] TYPE MISMATCH ERROR in ${queryName}:`
        );
        console.error(
          `[${requestId}] [Linear API] Error: ${errorMessage}`
        );
        console.error(
          `[${requestId}] [Linear API] This indicates variable type doesn't match GraphQL schema`
        );
        throw new Error(
          `Linear GraphQL Type Error in ${queryName}: ${errorMessage}`
        );
      }
      if (errorMessage.includes("Entity not found: Team")) {
        const teamId = variables.teamId;
        const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        console.warn(
          `\uFE0F [${requestId}] [Linear API] Team entity not found:`,
          {
            teamId,
            isUUID: teamId && uuidPattern.test(teamId),
            queryName
          }
        );
        if (teamId && uuidPattern.test(teamId)) {
          console.warn(
            `\uFE0F [${requestId}] [Linear API] UUID team ${teamId} not found in Linear workspace`
          );
          throw new Error(
            `UUID team not found in Linear workspace: ${teamId}`
          );
        }
        console.warn(
          `\uFE0F [${requestId}] [Linear API] Team ${teamId} not found in Linear workspace`
        );
        throw new Error(
          `Team not found in Linear workspace: ${teamId}`
        );
      }
      throw new Error(
        `Linear GraphQL Error in ${queryName}: ${errorMessage}`
      );
    }
    if (!result.data) {
      console.error(
        `\uFE0F [${requestId}] [Linear API] No data in response for ${queryName}:`,
        {
          fullResponse: result,
          queryName,
          variables
        }
      );
      throw new Error(
        `No data returned from Linear GraphQL query: ${queryName}`
      );
    }
    if (responseTime > 1e3) {
      console.log(
        `[${requestId}] [Linear API] ${queryName} completed in ${responseTime}ms`
      );
    }
    return result.data;
  } catch (error) {
    const responseTime = Date.now() - startTime;
    console.error(
      `[${requestId}] [Linear API] Request failed:`,
      {
        error: error instanceof Error ? error.message : String(error),
        errorType: error?.constructor?.name,
        responseTime: `${responseTime}ms`,
        stack: error instanceof Error ? error.stack : void 0
      }
    );
    throw error;
  }
}
async function getTeamConfig(teamId) {
  try {
    const data = await executeLinearQuery(LINEAR_QUERIES.GET_TEAM_CONFIG, { teamId });
    if (!data || !data.team) {
      console.warn(`\uFE0F [getTeamConfig] No team data returned for teamId: ${teamId}`);
      return null;
    }
    const team = data.team;
    return {
      id: team.id,
      name: team.name,
      key: team.key,
      description: team.description,
      timezone: team.timezone,
      // Transform GraphQL nodes arrays to simple arrays
      states: team.states?.nodes || [],
      labels: team.labels?.nodes || [],
      members: team.members?.nodes || [],
      projects: team.projects?.nodes || [],
      createdAt: team.createdAt,
      updatedAt: team.updatedAt
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("team not found") || errorMessage.includes("Entity not found: Team")) {
      console.warn(`\uFE0F [getTeamConfig] Team not found in Linear: ${teamId}`);
      return null;
    }
    throw error;
  }
}
async function getAllTeamIssues(teamId) {
  let allIssues = [];
  let after = void 0;
  let pageCount = 0;
  console.log(
    `[Pagination] Starting to fetch all issues for team ${teamId}`
  );
  while (true) {
    pageCount++;
    console.log(
      `[Pagination] Fetching page ${pageCount}${after ? ` (cursor: ${after.substring(0, 10)}...)` : ""}`
    );
    const data = await executeLinearQuery(LINEAR_QUERIES.GET_ALL_TEAM_ISSUES, {
      teamId,
      after
    });
    const issues = data.issues.nodes;
    allIssues = allIssues.concat(issues);
    console.log(
      `[Pagination] Page ${pageCount}: Retrieved ${issues.length} issues (total: ${allIssues.length})`
    );
    const pageInfo = data.issues.pageInfo;
    if (!pageInfo.hasNextPage) {
      console.log(
        `[Pagination] Complete! Total issues fetched: ${allIssues.length} across ${pageCount} page(s)`
      );
      break;
    }
    after = pageInfo.endCursor;
  }
  return allIssues;
}
async function getIssuesInState(teamId, stateId) {
  let allIssues = [];
  let after = void 0;
  while (true) {
    const data = await executeLinearQuery(LINEAR_QUERIES.GET_ISSUES_IN_STATE, {
      teamId,
      stateId,
      after
    });
    const issues = data.issues.nodes;
    allIssues = allIssues.concat(issues);
    const pageInfo = data.issues.pageInfo;
    if (!pageInfo.hasNextPage) break;
    after = pageInfo.endCursor;
  }
  return allIssues;
}
async function getIssuesGroupedByParent(teamId, stateId) {
  const allIssues = await getIssuesInState(teamId, stateId);
  console.log(
    `[Parent-Child] Processing ${allIssues.length} issues for grouping`
  );
  const countAllDescendants = (issue) => {
    const childrenNodes = issue.children?.nodes || [];
    if (childrenNodes.length === 0) return 0;
    let totalCount = childrenNodes.length;
    childrenNodes.forEach((child) => {
      totalCount += countAllDescendants(child);
    });
    return totalCount;
  };
  const calculateHierarchyBreakdown = (issue) => {
    const childrenNodes = issue.children?.nodes || [];
    const breakdown = {
      level1: 0,
      // Direct children
      level2: 0,
      // Grandchildren
      level3Plus: 0,
      // Great-grandchildren and deeper
      byState: {},
      total: 0
    };
    breakdown.level1 = childrenNodes.length;
    childrenNodes.forEach((child) => {
      const childState = child.state?.name || "unknown";
      breakdown.byState[childState] = (breakdown.byState[childState] || 0) + 1;
      const grandchildrenNodes = child.children?.nodes || [];
      breakdown.level2 += grandchildrenNodes.length;
      grandchildrenNodes.forEach((grandchild) => {
        const grandchildState = grandchild.state?.name || "unknown";
        breakdown.byState[grandchildState] = (breakdown.byState[grandchildState] || 0) + 1;
        const greatGrandchildrenCount = countAllDescendants(grandchild);
        breakdown.level3Plus += greatGrandchildrenCount;
      });
    });
    breakdown.total = breakdown.level1 + breakdown.level2 + breakdown.level3Plus;
    return breakdown;
  };
  console.log(`[Hierarchy Counter] Processing ${allIssues.length} issues to count descendants...`);
  allIssues.forEach((issue) => {
    const totalDescendants = countAllDescendants(issue);
    const hierarchyBreakdown = calculateHierarchyBreakdown(issue);
    const directChildrenFromAPI = issue.children?.nodes?.length || 0;
    issue._originalSubIssueCount = directChildrenFromAPI;
    issue._hierarchyBreakdown = hierarchyBreakdown;
    console.log(`[Hierarchy] ${issue.identifier}: ${directChildrenFromAPI} direct children from API (total descendants: ${totalDescendants}, L1:${hierarchyBreakdown.level1}, L2:${hierarchyBreakdown.level2}, L3+:${hierarchyBreakdown.level3Plus})`);
    if (totalDescendants > 0) {
      const stateDistribution = Object.entries(hierarchyBreakdown.byState).map(([state, count]) => `${state}:${count}`).join(", ");
      console.log(`   \u2514\u2500Distribution: ${stateDistribution}`);
      const childrenNodes = issue.children?.nodes || [];
      childrenNodes.forEach((child) => {
        const childDescendants = countAllDescendants(child);
        const childInfo = childDescendants > 0 ? `${child.identifier} (${child.state?.name}, +${childDescendants} nested)` : `${child.identifier} (${child.state?.name})`;
        console.log(`   \u2514\u2500 ${childInfo}`);
      });
    }
  });
  const issuesById = Object.fromEntries(
    allIssues.map((issue) => [
      issue.id,
      {
        ...issue,
        subIssues: [],
        _originalSubIssueCount: issue._originalSubIssueCount,
        //Preserve count
        _hierarchyBreakdown: issue._hierarchyBreakdown
        //Preserve hierarchy breakdown
      }
    ])
  );
  const rootIssues = [];
  let subIssueCount = 0;
  const originalParentMap = {};
  allIssues.forEach((issue) => {
    if (issue.parent?.id) {
      originalParentMap[issue.id] = issue.parent;
    }
  });
  const isNestedSubIssue = (issue) => {
    if (!issue.parent?.id) return false;
    const parentInSameState = issuesById[issue.parent.id];
    if (!parentInSameState) return false;
    const parentOriginalData = allIssues.find((i) => i.id === issue.parent.id);
    if (parentOriginalData?.parent?.id) {
      const grandparentInSameState = issuesById[parentOriginalData.parent.id];
      if (grandparentInSameState) {
        console.log(`[Hierarchy] ${issue.identifier} is nested: parent=${parentOriginalData.identifier}, grandparent=${grandparentInSameState.identifier}`);
        return true;
      }
    }
    return false;
  };
  for (const issue of allIssues) {
    if (issue.parent?.id) {
      const parent = issuesById[issue.parent.id];
      if (parent) {
        if (!isNestedSubIssue(issue)) {
          subIssueCount++;
          parent.subIssues.push(issue);
          console.log(`[Hierarchy] ${issue.identifier} \u2192 parent ${parent.identifier} (direct child)`);
        } else {
          console.log(`[Hierarchy] ${issue.identifier} is nested sub-issue \u2192 HIDDEN from Kanban`);
        }
      } else {
        console.log(`[Parent-Child] ${issue.identifier} has parent ${issue.parent.identifier} in different state - showing as root`);
        rootIssues.push(issuesById[issue.id]);
      }
    } else {
      rootIssues.push(issuesById[issue.id]);
    }
  }
  console.log(
    `[Parent-Child] Grouped into ${rootIssues.length} root issues with ${subIssueCount} sub-issues`
  );
  console.log(`[SubIssue Count] Verifying _originalSubIssueCount for ${rootIssues.length} root issues:`);
  rootIssues.forEach((issue) => {
    if (issue._originalSubIssueCount !== void 0) {
      console.log(`  ${issue.identifier}._originalSubIssueCount = ${issue._originalSubIssueCount}`);
    } else {
      console.log(`  [DEBUG] ${issue.identifier}._originalSubIssueCount = UNDEFINED (this is a BUG!)`);
    }
  });
  const parentsWithChildren = rootIssues.filter(
    (issue) => issue.subIssues.length > 0
  );
  if (parentsWithChildren.length > 0) {
    console.log(
      `[Parent-Child] ${parentsWithChildren.length} issues have sub-issues:`
    );
    parentsWithChildren.forEach((parent) => {
      console.log(
        `   ${parent.identifier}: ${parent.subIssues.length} sub-issue(s)`
      );
    });
  }
  return rootIssues;
}
async function getIssueDetail(issueId) {
  const cacheKey = `linear:issue-detail:${issueId}`;
  const cacheTTL = 120;
  const startTime = Date.now();
  try {
    const cached = await get(cacheKey);
    if (cached) {
      if (cached.data && cached.expiresAt) {
        if (cached.expiresAt > Date.now()) {
          const cacheTime = Date.now() - startTime;
          console.log(`[getIssueDetail] Cache HIT for ${issueId} (${cacheTime}ms)`);
          return cached.data;
        } else {
          console.log(`[getIssueDetail] Cache EXPIRED for ${issueId}`);
        }
      } else if (cached.expiresAt) {
        if (cached.expiresAt > Date.now()) {
          const cacheTime = Date.now() - startTime;
          console.log(`[getIssueDetail] Cache HIT (legacy) for ${issueId} (${cacheTime}ms)`);
          return cached;
        }
      }
    }
  } catch (error) {
    console.log(`[getIssueDetail] Cache MISS for ${issueId}:`, error instanceof Error ? error.message : "Unknown error");
  }
  console.log(`[getIssueDetail] Fetching from Linear API for ${issueId}...`);
  const apiStartTime = Date.now();
  const data = await executeLinearQuery(LINEAR_QUERIES.GET_ISSUE_DETAIL, { issueId });
  const apiTime = Date.now() - apiStartTime;
  console.log(`[getIssueDetail] Linear API response for ${issueId}: ${apiTime}ms`);
  if (data.issue && data.issue.children) {
    data.issue.subIssues = data.issue.children.nodes || [];
    delete data.issue.children;
  }
  try {
    await set(cacheKey, {
      data: data.issue,
      expiresAt: Date.now() + cacheTTL * 1e3
    });
    console.log(`[getIssueDetail] Cached ${issueId} for ${cacheTTL}s`);
  } catch (error) {
    console.warn(`[getIssueDetail] Failed to cache ${issueId}:`, error instanceof Error ? error.message : "Unknown error");
  }
  const totalTime = Date.now() - startTime;
  console.log(`[getIssueDetail] Total time for ${issueId}: ${totalTime}ms (API: ${apiTime}ms)`);
  return data.issue;
}
async function getTeamIssuesByState(teamId) {
  console.log(`[IssuesByState] Fetching team ${teamId} with issues grouped by state`);
  try {
    const teamConfig = await getTeamConfig(teamId);
    if (!teamConfig) {
      throw new Error(`Team ${teamId} not found or has no configuration`);
    }
    console.log(`[IssuesByState] Team: ${teamConfig.name} (${teamConfig.key}) - ${teamConfig.states?.length || 0} states`);
    const states = teamConfig.states || [];
    const stateResults = await Promise.all(
      states.map(async (state) => {
        const rootIssues = await getIssuesGroupedByParent(teamId, state.id);
        const subIssueCount = rootIssues.reduce(
          (sum, issue) => sum + (issue.subIssues?.length || 0),
          0
        );
        return {
          state: {
            id: state.id,
            name: state.name,
            type: state.type,
            color: state.color,
            position: state.position
          },
          issues: rootIssues,
          totalCount: rootIssues.length + subIssueCount,
          rootCount: rootIssues.length,
          subIssueCount
        };
      })
    );
    const totalIssues = stateResults.reduce(
      (sum, stateData) => sum + stateData.totalCount,
      0
    );
    console.log(`[IssuesByState] Total: ${totalIssues} issues across ${states.length} states`);
    stateResults.forEach((stateData) => {
      if (stateData.rootCount > 0) {
        console.log(
          `  ${stateData.state.name}: ${stateData.rootCount} root, ${stateData.subIssueCount} sub-issues`
        );
      }
    });
    return {
      team: {
        id: teamConfig.id,
        name: teamConfig.name,
        key: teamConfig.key
      },
      states: stateResults,
      totalIssues,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  } catch (error) {
    console.error(`[IssuesByState] Error fetching team ${teamId}:`, error);
    throw error;
  }
}
async function updateIssueState(issueId, stateId) {
  const mutation = `
    mutation UpdateIssueState($issueId: String!, $stateId: String!) {
      issueUpdate(id: $issueId, input: { stateId: $stateId }) {
        success
        issue {
          id
          identifier
          state {
            id
            name
            type
          }
        }
      }
    }
  `;
  const data = await executeLinearQuery(mutation, {
    issueId,
    stateId
  });
  try {
    await del(`linear:issue-detail:${issueId}`);
  } catch (error) {
  }
  return data.issueUpdate;
}
async function requestLinearFileUpload(contentType, filename, size) {
  console.log(`[Linear] Requesting upload credentials for: ${filename} (${size} bytes)`);
  const mutation = `
    mutation FileUpload($contentType: String!, $filename: String!, $size: Int!) {
      fileUpload(contentType: $contentType, filename: $filename, size: $size) {
        success
        uploadFile {
          uploadUrl
          assetUrl
          headers {
            key
            value
          }
        }
      }
    }
  `;
  const data = await executeLinearQuery(mutation, {
    contentType,
    filename,
    size
  });
  if (!data.fileUpload?.success || !data.fileUpload?.uploadFile) {
    console.error("[Linear] Invalid fileUpload response:", data);
    throw new Error("Failed to request upload URL from Linear");
  }
  console.log(`[Linear] Got upload credentials for: ${filename}`);
  console.log(`[Linear] Asset URL: ${data.fileUpload.uploadFile.assetUrl}`);
  return data.fileUpload.uploadFile;
}
async function uploadFileToLinear(file) {
  console.log(`[Linear] Starting file upload: ${file.name}`);
  const uploadPayload = await requestLinearFileUpload(
    file.type || "application/octet-stream",
    file.name,
    file.size
  );
  const uploadUrl = uploadPayload.uploadUrl;
  const assetUrl = uploadPayload.assetUrl;
  const headers = new Headers();
  headers.set("Content-Type", file.type || "application/octet-stream");
  headers.set("Cache-Control", "public, max-age=31536000");
  if (uploadPayload.headers && Array.isArray(uploadPayload.headers)) {
    uploadPayload.headers.forEach((header) => {
      headers.set(header.key, header.value);
    });
  }
  console.log(`[Linear] Uploading to Linear storage...`);
  const uploadResponse = await fetch(uploadUrl, {
    method: "PUT",
    headers,
    body: file
  });
  if (!uploadResponse.ok) {
    const errorText = await uploadResponse.text();
    console.error("[Linear] Upload failed:", {
      status: uploadResponse.status,
      error: errorText
    });
    throw new Error(`Failed to upload file to Linear: ${uploadResponse.status}`);
  }
  console.log(`[Linear] File uploaded successfully: ${file.name}`);
  console.log(`[Linear] Asset URL: ${assetUrl}`);
  return assetUrl;
}
async function createSubIssue(parentIssueId, title, description) {
  console.log(`[Linear] Creating sub-issue for parent: ${parentIssueId}`);
  const parentQuery = `
    query GetParentIssue($issueId: String!) {
      issue(id: $issueId) {
        id
        identifier
        title
        cycle {
          id
          name
        }
        team {
          id
          name
        }
      }
    }
  `;
  const parentData = await executeLinearQuery(parentQuery, { issueId: parentIssueId });
  if (!parentData?.issue) {
    throw new Error(`Parent issue not found: ${parentIssueId}`);
  }
  const teamId = parentData.issue.team?.id;
  if (!teamId) {
    throw new Error(`Parent issue ${parentIssueId} has no team assigned`);
  }
  const cycleId = parentData.issue.cycle?.id;
  console.log(`[Linear] Parent team: ${parentData.issue.team.name}, cycle: ${cycleId ? parentData.issue.cycle.name : "none"}`);
  const teamStatesQuery = `
    query GetTeamStates($teamId: String!) {
      team(id: $teamId) {
        states {
          nodes {
            id
            name
            type
          }
        }
      }
    }
  `;
  const teamStatesData = await executeLinearQuery(teamStatesQuery, { teamId });
  const triageState = teamStatesData?.team?.states?.nodes?.find(
    (state) => state.name.toLowerCase() === "triage"
  );
  const stateId = triageState?.id;
  if (stateId) {
    console.log(`[Linear] Found Triage state: ${stateId}`);
  } else {
    console.log(`[Linear] Warning: Triage state not found for team ${teamId}`);
  }
  const teamLabelsQuery = `
    query GetTeamLabels($teamId: String!) {
      team(id: $teamId) {
        labels {
          nodes {
            id
            name
          }
        }
      }
    }
  `;
  const teamLabelsData = await executeLinearQuery(teamLabelsQuery, { teamId });
  const labels = teamLabelsData?.team?.labels?.nodes || [];
  const uatLabel = labels.find((label) => label.name.toLowerCase() === "uat");
  const clientSubmittedLabel = labels.find((label) => label.name.toLowerCase() === "client-submitted");
  const labelIds = [];
  if (uatLabel) {
    labelIds.push(uatLabel.id);
    console.log(`[Linear] Found UAT label: ${uatLabel.id}`);
  }
  if (clientSubmittedLabel) {
    labelIds.push(clientSubmittedLabel.id);
    console.log(`[Linear] Found Client-Submitted label: ${clientSubmittedLabel.id}`);
  }
  const mutation = `
    mutation CreateSubIssue(
      $title: String!, 
      $description: String, 
      $teamId: String!, 
      $parentId: String!,
      $cycleId: String,
      $stateId: String,
      $labelIds: [String!]
    ) {
      issueCreate(input: { 
        title: $title
        description: $description
        teamId: $teamId
        parentId: $parentId
        cycleId: $cycleId
        stateId: $stateId
        labelIds: $labelIds
      }) {
        success
        issue {
          id
          identifier
          title
          description
          url
          parent {
            id
            identifier
            title
          }
          cycle {
            id
            name
          }
          state {
            id
            name
          }
          labels {
            nodes {
              id
              name
            }
          }
          team {
            id
            name
          }
        }
      }
    }
  `;
  const data = await executeLinearQuery(mutation, {
    title,
    description: description || "",
    teamId,
    parentId: parentIssueId,
    cycleId: cycleId || null,
    stateId: stateId || null,
    labelIds: labelIds.length > 0 ? labelIds : null
  });
  if (!data.issueCreate?.success) {
    throw new Error("Failed to create sub-issue in Linear");
  }
  const createdIssue = data.issueCreate.issue;
  console.log(`[Linear] Sub-issue created: ${createdIssue.identifier}`, {
    parentId: parentIssueId,
    cycleId: createdIssue.cycle?.id,
    stateId: createdIssue.state?.id,
    stateName: createdIssue.state?.name,
    labels: createdIssue.labels?.nodes?.map((l) => l.name).join(", ") || "none"
  });
  return createdIssue;
}
async function uploadFilesToIssue(issueId, files) {
  console.log(`[Linear] Starting uploadFilesToIssue for issue: ${issueId}`);
  console.log(`[Linear] Files count: ${files.length}`);
  console.log(`[Linear] Files details:`, files.map((f) => ({
    name: f.name,
    size: f.size,
    type: f.type
  })));
  if (!files || files.length === 0) {
    throw new Error("No files provided to upload");
  }
  const assetUrls = [];
  const errors = [];
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    try {
      console.log(`[Linear] Processing file ${i + 1}/${files.length}: ${file.name}`);
      const assetUrl = await uploadFileToLinear(file);
      assetUrls.push(assetUrl);
      console.log(`[Linear] File uploaded: ${file.name}`);
    } catch (error) {
      const errorMsg = `Failed to upload ${file.name}: ${error instanceof Error ? error.message : String(error)}`;
      console.error(`[Linear] ${errorMsg}`);
      console.error(`[Linear] Error stack:`, error instanceof Error ? error.stack : "No stack");
      errors.push(errorMsg);
    }
  }
  if (assetUrls.length === 0) {
    const errorSummary = errors.length > 0 ? `Failed to upload any files to Linear. Errors: ${errors.join("; ")}` : "Failed to upload any files to Linear. No errors captured.";
    console.error(`[Linear] ${errorSummary}`);
    throw new Error(errorSummary);
  }
  console.log(`[Linear] Successfully uploaded ${assetUrls.length}/${files.length} files to Linear storage`);
  if (errors.length > 0) {
    console.warn(`[Linear] ${errors.length} files failed:`, errors);
  }
  const attachments = [];
  const attachErrors = [];
  for (let i = 0; i < assetUrls.length; i++) {
    const assetUrl = assetUrls[i];
    const fileName = files[i].name;
    try {
      console.log(`[Linear] Attaching ${i + 1}/${assetUrls.length}: ${fileName}`);
      const mutation = `
        mutation AttachUrl($issueId: String!, $url: String!, $title: String!) {
          attachmentCreate(input: { issueId: $issueId, url: $url, title: $title }) {
            success
            attachment {
              id
              title
              url
            }
          }
        }
      `;
      const data = await executeLinearQuery(mutation, {
        issueId,
        url: assetUrl,
        title: fileName
      });
      if (!data.attachmentCreate?.success) {
        throw new Error("attachmentCreate returned success: false");
      }
      attachments.push({
        id: data.attachmentCreate.attachment.id,
        title: data.attachmentCreate.attachment.title,
        url: data.attachmentCreate.attachment.url
      });
      console.log(`[Linear] Attached to issue: ${fileName}`);
    } catch (error) {
      const errorMsg = `Failed to attach ${fileName}: ${error instanceof Error ? error.message : String(error)}`;
      console.error(`[Linear] ${errorMsg}`);
      attachErrors.push(errorMsg);
    }
  }
  if (attachments.length === 0) {
    const errorSummary = `Failed to attach any files to issue. Errors: ${attachErrors.join("; ")}`;
    console.error(`[Linear] ${errorSummary}`);
    throw new Error(errorSummary);
  }
  console.log(`[Linear] Successfully attached ${attachments.length}/${assetUrls.length} files to issue`);
  if (attachErrors.length > 0) {
    console.warn(`[Linear] ${attachErrors.length} attachments failed:`, attachErrors);
  }
  return attachments;
}
async function getStateIdByName(teamId, stateName) {
  try {
    console.log(`[Linear] Finding state ID for: "${stateName}" in team ${teamId}`);
    const query = `
      query GetTeamWorkflowStates($teamId: String!) {
        team(id: $teamId) {
          id
          states {
            nodes {
              id
              name
              type
            }
          }
        }
      }
    `;
    const data = await executeLinearQuery(query, { teamId });
    if (!data?.team?.states?.nodes) {
      console.error("[Linear] No states found in team");
      return null;
    }
    const states = data.team.states.nodes;
    console.log(`[Linear] Found ${states.length} workflow states`);
    const targetState = states.find(
      (state) => state.name.toLowerCase() === stateName.toLowerCase()
    );
    if (targetState) {
      console.log(`[Linear] Found state: ${targetState.name} \u2192 ${targetState.id}`);
      return targetState.id;
    } else {
      console.warn(`\uFE0F [Linear] State "${stateName}" not found in team ${teamId}`);
      console.log("Available states:", states.map((s) => s.name).join(", "));
      return null;
    }
  } catch (error) {
    console.error("[Linear] Error fetching state ID:", error);
    return null;
  }
}
async function createIssue(params) {
  const { teamId, title, description, priority, assigneeId, stateId, labelIds, parentId } = params;
  let { cycleId } = params;
  const issueType = parentId ? "sub-issue" : "parent issue";
  console.log(`[Linear] Creating ${issueType}:`, {
    teamId,
    title,
    hasPriority: priority !== void 0,
    hasAssignee: !!assigneeId,
    hasState: !!stateId,
    labelCount: labelIds?.length || 0,
    cycleIdProvided: !!cycleId,
    hasParent: !!parentId
  });
  if (!cycleId) {
    console.log("[Linear] No cycleId provided, fetching active UAT cycle...");
    const cycleQuery = `
      query GetActiveCycle($teamId: String!) {
        team(id: $teamId) {
          cycles(
            filter: { 
              isActive: { eq: true }
            }
            first: 10
          ) {
            nodes {
              id
              name
              startsAt
              endsAt
            }
          }
        }
      }
    `;
    try {
      const cycleData = await executeLinearQuery(cycleQuery, { teamId });
      const activeCycles = cycleData.team?.cycles?.nodes || [];
      const uatCycle = activeCycles.find(
        (c) => c.name.toLowerCase().includes("uat")
      );
      if (uatCycle) {
        cycleId = uatCycle.id;
        console.log("[Linear] Found active UAT cycle:", {
          id: uatCycle.id,
          name: uatCycle.name
        });
      } else {
        if (activeCycles.length > 0) {
          cycleId = activeCycles[0].id;
          console.log("[Linear] Using first active cycle:", {
            id: activeCycles[0].id,
            name: activeCycles[0].name
          });
        } else {
          console.log("[Linear] No active cycle found, proceeding without cycle");
        }
      }
    } catch (err) {
      console.error("[Linear] Failed to fetch active cycle:", err);
      console.log("[Linear] Proceeding without cycle");
    }
  }
  const mutation = `
    mutation CreateIssue(
      $teamId: String!
      $title: String!
      $description: String
      $priority: Int
      $assigneeId: String
      $stateId: String
      $labelIds: [String!]
      $cycleId: String
      $parentId: String
    ) {
      issueCreate(input: {
        teamId: $teamId
        title: $title
        description: $description
        priority: $priority
        assigneeId: $assigneeId
        stateId: $stateId
        labelIds: $labelIds
        cycleId: $cycleId
        parentId: $parentId
      }) {
        success
        issue {
          id
          identifier
          title
          description
          url
          priority
          priorityLabel
          state {
            id
            name
            type
          }
          assignee {
            id
            name
            email
            avatarUrl
          }
          labels {
            nodes {
              id
              name
              color
            }
          }
          cycle {
            id
            name
          }
          team {
            id
            name
            key
          }
          createdAt
          updatedAt
        }
      }
    }
  `;
  const variables = {
    teamId,
    title
  };
  if (description) variables.description = description;
  if (priority !== void 0) variables.priority = priority;
  if (assigneeId) variables.assigneeId = assigneeId;
  if (stateId) variables.stateId = stateId;
  if (labelIds && labelIds.length > 0) variables.labelIds = labelIds;
  if (cycleId) variables.cycleId = cycleId;
  if (parentId) variables.parentId = parentId;
  const data = await executeLinearQuery(mutation, variables);
  if (!data.issueCreate?.success) {
    throw new Error("Failed to create issue in Linear");
  }
  const createdIssue = data.issueCreate.issue;
  console.log(`[Linear] ${issueType} created:`, {
    identifier: createdIssue.identifier,
    id: createdIssue.id,
    state: createdIssue.state?.name,
    priority: createdIssue.priorityLabel,
    labels: createdIssue.labels?.nodes?.map((l) => l.name).join(", ") || "none",
    parentId: parentId || "none"
  });
  return {
    success: true,
    data: createdIssue
  };
}
async function getTeamIssues(teamId) {
  return await getTeamIssuesByState(teamId);
}
async function invalidateCache(teamId) {
  try {
    const allIssues = await getAllTeamIssues(teamId);
    const cacheKeys = allIssues.map((issue) => `linear:issue-detail:${issue.id}`);
    for (const key of cacheKeys) {
      try {
        await del(key);
      } catch (error) {
      }
    }
    return {
      success: true,
      message: `Invalidated cache for ${cacheKeys.length} issues in team ${teamId}`,
      invalidatedCount: cacheKeys.length
    };
  } catch (error) {
    console.error(`[invalidateCache] Error invalidating cache for team ${teamId}:`, error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to invalidate cache"
    };
  }
}
async function getCacheStats() {
  try {
    const cacheKeys = await getByPrefix("linear:issue-detail:");
    let totalSize = 0;
    let validCaches = 0;
    let expiredCaches = 0;
    for (const key of cacheKeys) {
      try {
        const cached = await get(key);
        if (cached) {
          if (cached.expiresAt && cached.expiresAt > Date.now()) {
            validCaches++;
          } else {
            expiredCaches++;
          }
          totalSize += JSON.stringify(cached).length;
        }
      } catch (error) {
      }
    }
    return {
      success: true,
      data: {
        totalCaches: cacheKeys.length,
        validCaches,
        expiredCaches,
        estimatedSize: totalSize,
        estimatedSizeKB: Math.round(totalSize / 1024)
      }
    };
  } catch (error) {
    console.error("[getCacheStats] Error getting cache stats:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to get cache stats"
    };
  }
}

// src/server/routes/linearRoutes.ts
var linearRoutes = new Hono5();
linearRoutes.use("*", authMiddleware);
var linearService = new LinearTeamService();
linearRoutes.get("/linear/test", async (c) => {
  try {
    const user = c.get("user");
    const result = await linearService.testConnection();
    return c.json({
      success: result.success,
      message: result.message,
      data: result.data || null
    });
  } catch (error) {
    console.error("[Linear] Test connection error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to test Linear connection",
        message: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/hierarchy", async (c) => {
  try {
    const user = c.get("user");
    const { data: kvData, error: kvError } = await createClient5(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    ).from("kv_store_7f0d90fb").select("value").eq("key", "linear_teams:all").single();
    if (kvError) {
    }
    if (!kvError && kvData?.value) {
      const hierarchyData = typeof kvData.value === "string" ? JSON.parse(kvData.value) : kvData.value;
      if (!hierarchyData.teams || !Array.isArray(hierarchyData.teams)) {
        console.error("[Linear] Invalid KV cache data structure:", {
          hasTeams: !!hierarchyData.teams,
          isArray: Array.isArray(hierarchyData.teams),
          keys: Object.keys(hierarchyData)
        });
      } else {
        return c.json({
          success: true,
          data: hierarchyData,
          source: "cache"
        });
      }
    }
    const result = await linearService.listTeams();
    if (!result.success) {
      return c.json(
        {
          success: false,
          error: result.message || "Failed to fetch teams"
        },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: {
        teams: result.teams || [],
        count: result.teams?.length || 0,
        syncedAt: (/* @__PURE__ */ new Date()).toISOString()
      },
      source: "api"
    });
  } catch (error) {
    console.error("[Linear] Get hierarchy error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch team hierarchy",
        message: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/teams", async (c) => {
  try {
    const user = c.get("user");
    const result = await linearService.listTeams();
    if (!result.success) {
      return c.json(
        {
          success: false,
          error: result.message || "Failed to fetch teams"
        },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: result.teams || []
    });
  } catch (error) {
    console.error("[Linear] Get teams error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch Linear teams",
        message: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
});
linearRoutes.post("/linear/clear-cache", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    const isSuperAdmin = c.get("isSuperAdmin");
    if (!["superadmin", "admin"].includes(role) && !isSuperAdmin) {
      return c.json(
        {
          success: false,
          error: "Unauthorized. Only admins can clear cache."
        },
        { status: 403 }
      );
    }
    const supabase4 = createClient5(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    const keysToDelete = [
      "linear:organization",
      "linear_teams:all",
      "team_ownership_map:all"
    ];
    let deletedCount = 0;
    for (const key of keysToDelete) {
      const { error } = await supabase4.from("kv_store_7f0d90fb").delete().eq("key", key);
      if (!error) {
        deletedCount++;
      }
    }
    const prefixes = ["cache:linear-teams", "linear:", "team:"];
    for (const prefix of prefixes) {
      const { error } = await supabase4.from("kv_store_7f0d90fb").delete().like("key", `${prefix}%`);
      if (!error) {
      }
    }
    await teamMethodsV2.invalidateCache();
    return c.json({
      success: true,
      message: "All Linear cache data cleared successfully",
      deletedKeys: deletedCount,
      clearedPrefixes: prefixes
    });
  } catch (error) {
    console.error("[Linear Cache Clear] Error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to clear cache",
        message: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
});
linearRoutes.post("/linear/sync-hierarchy", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    const isSuperAdmin = c.get("isSuperAdmin");
    await teamMethodsV2.invalidateCache();
    const supabase4 = createClient5(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    await supabase4.from("kv_store_7f0d90fb").delete().or(
      "key.eq.linear:organization,key.eq.team_ownership_map:all,key.like.cache:linear-teams%"
    );
    if (!["superadmin", "admin"].includes(role) && !isSuperAdmin) {
      return c.json(
        {
          success: false,
          error: "Unauthorized. Only admins can sync team hierarchy."
        },
        { status: 403 }
      );
    }
    const result = await linearService.syncTeamHierarchy();
    if (!result.success) {
      return c.json(
        {
          success: false,
          error: result.message || "Failed to sync team hierarchy"
        },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      message: result.message,
      data: result.data
    });
  } catch (error) {
    console.error("[Linear] Sync hierarchy error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to sync team hierarchy",
        message: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/teams/:teamId", async (c) => {
  const teamId = c.req.param("teamId");
  try {
    const user = c.get("user");
    const result = await linearService.getTeamById(teamId);
    if (!result) {
      return c.json(
        {
          success: false,
          error: "Team not found",
          teamId
        },
        { status: 404 }
      );
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.error("[Linear] Get team error:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("not found in Linear workspace")) {
      return c.json(
        {
          success: false,
          error: "Team not found in Linear workspace",
          message: "This team may have been deleted from Linear or you don't have access to it.",
          teamId
          //Now teamId is in scope!
        },
        { status: 404 }
      );
    }
    return c.json(
      {
        success: false,
        error: "Failed to fetch Linear team",
        message: errorMessage
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/teams/:teamId/config", async (c) => {
  const teamId = c.req.param("teamId");
  try {
    const user = c.get("user");
    const result = await getTeamConfig(teamId);
    if (!result) {
      return c.json(
        {
          success: false,
          error: "Team config not found"
        },
        { status: 404 }
      );
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.error("[Linear] Get team config error:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("not found in Linear workspace")) {
      return c.json(
        {
          success: false,
          error: "Team not found in Linear workspace",
          message: "This team may have been deleted from Linear or you don't have access to it.",
          teamId
          //Now teamId is in scope!
        },
        { status: 404 }
      );
    }
    return c.json(
      {
        success: false,
        error: "Failed to fetch team config",
        message: errorMessage
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/teams/:teamId/state-by-name", async (c) => {
  const teamId = c.req.param("teamId");
  const stateName = c.req.query("name");
  try {
    const user = c.get("user");
    if (!stateName) {
      return c.json(
        {
          success: false,
          error: "Missing required query parameter: name"
        },
        { status: 400 }
      );
    }
    const stateId = await getStateIdByName(
      teamId,
      stateName
    );
    if (!stateId) {
      return c.json(
        {
          success: false,
          error: `State "${stateName}" not found in team`
        },
        { status: 404 }
      );
    }
    return c.json({
      success: true,
      data: {
        stateId,
        stateName
      }
    });
  } catch (error) {
    console.error("[Linear] Get state by name error:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch state by name",
        message: errorMessage
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/teams/:teamId/issues-by-state", async (c) => {
  const teamId = c.req.param("teamId");
  try {
    const user = c.get("user");
    const result = await getTeamIssuesByState(teamId);
    if (!result) {
      return c.json(
        {
          success: false,
          error: "Failed to fetch team issues by state"
        },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: result,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Linear] Get team issues by state error:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("not found in Linear workspace")) {
      return c.json(
        {
          success: false,
          error: "Team not found in Linear workspace",
          message: "This team may have been deleted from Linear or you don't have access to it.",
          teamId
          //Now teamId is in scope!
        },
        { status: 404 }
      );
    }
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to fetch team issues by state",
        message: errorMessage
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/teams/:teamId/issues", async (c) => {
  const teamId = c.req.param("teamId");
  try {
    const user = c.get("user");
    const result = await getTeamIssues(teamId);
    if (!result) {
      return c.json(
        {
          success: false,
          error: "Failed to fetch team issues"
        },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.error("[Linear] Get team issues error:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("not found in Linear workspace")) {
      return c.json(
        {
          success: false,
          error: "Team not found in Linear workspace",
          message: "This team may have been deleted from Linear or you don't have access to it.",
          teamId
          //Now teamId is in scope!
        },
        { status: 404 }
      );
    }
    return c.json(
      {
        success: false,
        error: "Failed to fetch team issues",
        message: errorMessage
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/teams/:teamId/issues/by-state", async (c) => {
  try {
    const user = c.get("user");
    const teamId = c.req.param("teamId");
    const result = await getTeamIssuesByState(teamId);
    if (!result) {
      return c.json(
        {
          success: false,
          error: "Failed to fetch issues by state"
        },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.error("[Linear] Get issues by state error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch issues by state"
      },
      { status: 500 }
    );
  }
});
linearRoutes.post("/linear/graphql", async (c) => {
  try {
    const user = c.get("user");
    const body = await c.req.json();
    const { query, variables } = body;
    if (!query) {
      return c.json(
        {
          success: false,
          error: "GraphQL query is required"
        },
        { status: 400 }
      );
    }
    const result = await executeLinearQuery(
      query,
      variables || {}
    );
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.error("[Linear] GraphQL execution error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to execute GraphQL query"
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/issues/:issueId", async (c) => {
  try {
    const user = c.get("user");
    const issueId = c.req.param("issueId");
    const result = await getIssueDetail(issueId);
    if (!result) {
      return c.json(
        {
          success: false,
          error: "Issue not found"
        },
        { status: 404 }
      );
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.error("[Linear] Get issue error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch issue"
      },
      { status: 500 }
    );
  }
});
linearRoutes.post("/linear/issues/:parentIssueId/sub-issues", async (c) => {
  try {
    const user = c.get("user");
    const parentIssueId = c.req.param("parentIssueId");
    const body = await c.req.json();
    const { title, description } = body;
    if (!title || !title.trim()) {
      return c.json(
        {
          success: false,
          error: "Title is required"
        },
        { status: 400 }
      );
    }
    const result = await createSubIssue(
      parentIssueId,
      title.trim(),
      description?.trim()
    );
    if (!result) {
      return c.json(
        {
          success: false,
          error: "Failed to create sub-issue"
        },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.error("[Linear] Create sub-issue error:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return c.json(
      {
        success: false,
        error: "Failed to create sub-issue",
        message: errorMessage
      },
      { status: 500 }
    );
  }
});
linearRoutes.put("/linear/issues/:issueId/state", async (c) => {
  try {
    const user = c.get("user");
    const issueId = c.req.param("issueId");
    const body = await c.req.json();
    const { stateId } = body;
    if (!stateId) {
      return c.json(
        { success: false, error: "stateId is required" },
        { status: 400 }
      );
    }
    const result = await updateIssueState(
      issueId,
      stateId
    );
    if (!result) {
      return c.json(
        {
          success: false,
          error: "Failed to update issue state"
        },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: result,
      message: "Issue state updated successfully"
    });
  } catch (error) {
    console.error("[Linear] Update issue state error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to update issue state"
      },
      { status: 500 }
    );
  }
});
linearRoutes.post("/linear/issues/create", async (c) => {
  try {
    const user = c.get("user");
    const body = await c.req.json();
    const {
      teamId,
      title,
      description,
      priority,
      stateId,
      assigneeId,
      labelIds,
      cycleId
    } = body;
    if (!teamId || !title) {
      return c.json(
        {
          success: false,
          error: "teamId and title are required"
        },
        { status: 400 }
      );
    }
    const accessCheck = await teamMethodsV2.checkUserTeamAccess(
      user.id,
      teamId
    );
    if (!accessCheck.success) {
      return c.json(
        { success: false, error: "Access denied to this team" },
        { status: 403 }
      );
    }
    const result = await createIssue({
      teamId,
      title,
      description,
      priority,
      stateId,
      assigneeId,
      labelIds,
      cycleId
    });
    if (!result || !result.data) {
      return c.json(
        {
          success: false,
          error: "Failed to create issue"
        },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Linear] Create issue error:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return c.json(
      {
        success: false,
        error: "Failed to create issue",
        message: errorMessage
      },
      { status: 500 }
    );
  }
});
linearRoutes.post("/linear/cache/invalidate", async (c) => {
  try {
    const user = c.get("user");
    const body = await c.req.json();
    const { teamId } = body;
    const result = await invalidateCache(teamId);
    return c.json({
      success: true,
      message: "Cache invalidated successfully"
    });
  } catch (error) {
    console.error("[Linear] Invalidate cache error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to invalidate cache"
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/cache/stats", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    if (role !== "admin" && role !== "superadmin") {
      return c.json(
        { success: false, error: "Admin access required" },
        { status: 403 }
      );
    }
    const result = await getCacheStats();
    return c.json({
      success: true,
      data: result.data || {}
    });
  } catch (error) {
    console.error("[Linear] Get cache stats error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch cache stats"
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/teams/:teamId/states", async (c) => {
  try {
    const user = c.get("user");
    const teamId = c.req.param("teamId");
    const config = await getTeamConfig(teamId);
    if (!config) {
      return c.json(
        {
          success: false,
          error: "Team config not found"
        },
        { status: 404 }
      );
    }
    return c.json({
      success: true,
      data: {
        states: config.states || [],
        team: {
          id: config.id,
          name: config.name,
          key: config.key
        }
      }
    });
  } catch (error) {
    console.error("[Linear] Get states error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch team states"
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/teams/:teamId/labels", async (c) => {
  try {
    const user = c.get("user");
    const teamId = c.req.param("teamId");
    const config = await getTeamConfig(teamId);
    if (!config) {
      return c.json(
        {
          success: false,
          error: "Team config not found"
        },
        { status: 404 }
      );
    }
    return c.json({
      success: true,
      data: {
        labels: config.labels || [],
        team: {
          id: config.id,
          name: config.name,
          key: config.key
        }
      }
    });
  } catch (error) {
    console.error("[Linear] Get labels error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch team labels"
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/teams/:teamId/members", async (c) => {
  try {
    const user = c.get("user");
    const teamId = c.req.param("teamId");
    const config = await getTeamConfig(teamId);
    if (!config) {
      return c.json(
        {
          success: false,
          error: "Team config not found"
        },
        { status: 404 }
      );
    }
    return c.json({
      success: true,
      data: {
        members: config.members || [],
        team: {
          id: config.id,
          name: config.name,
          key: config.key
        }
      }
    });
  } catch (error) {
    console.error("[Linear] Get members error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch team members"
      },
      { status: 500 }
    );
  }
});
linearRoutes.get("/linear/teams/:teamId/projects", async (c) => {
  try {
    const user = c.get("user");
    const teamId = c.req.param("teamId");
    const config = await getTeamConfig(teamId);
    if (!config) {
      return c.json(
        {
          success: false,
          error: "Team config not found"
        },
        { status: 404 }
      );
    }
    return c.json({
      success: true,
      data: {
        projects: config.projects || [],
        team: {
          id: config.id,
          name: config.name,
          key: config.key
        }
      }
    });
  } catch (error) {
    console.error("[Linear] Get projects error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch team projects"
      },
      { status: 500 }
    );
  }
});
linearRoutes.post("/linear/issues/:issueId/upload", async (c) => {
  try {
    const issueId = c.req.param("issueId");
    const contentType = c.req.header("Content-Type");
    const formData = await c.req.formData();
    const files = formData.getAll("files");
    if (!files || files.length === 0) {
      console.error("[Linear Routes] No files in formData");
      return c.json(
        { success: false, error: "No files provided" },
        { status: 400 }
      );
    }
    const validFiles = files.filter((f) => f instanceof File);
    if (validFiles.length === 0) {
      console.error("[Linear Routes] No valid File objects found");
      return c.json(
        { success: false, error: "No valid files found" },
        { status: 400 }
      );
    }
    const attachments = await uploadFilesToIssue(
      issueId,
      validFiles
    );
    if (!attachments || attachments.length === 0) {
      console.error("[Linear Routes] No attachments returned from service");
      return c.json(
        { success: false, error: "Failed to upload any files" },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: {
        attachments,
        count: attachments.length
      }
    });
  } catch (error) {
    console.error("[Linear Routes] File upload error:", error);
    console.error(
      "[Linear Routes] Error stack:",
      error instanceof Error ? error.stack : "No stack"
    );
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Failed to upload files"
      },
      { status: 500 }
    );
  }
});

// src/server/routes/linearMaintenanceRoutes.ts
init_authHelpers();
import { Hono as Hono6 } from "hono";
import { createClient as createClient6 } from "@supabase/supabase-js";
var linearMaintenanceRoutes = new Hono6();
linearMaintenanceRoutes.use("*", authMiddleware);
linearMaintenanceRoutes.post("/linear/cleanup-orphaned-mappings", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    const isSuperAdmin = c.get("isSuperAdmin");
    if (!["superadmin", "admin"].includes(role) && !isSuperAdmin) {
      return c.json(
        {
          success: false,
          error: "Unauthorized. Only admins can cleanup orphaned mappings."
        },
        { status: 403 }
      );
    }
    const supabase4 = createClient6(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    const { data: teamsData, error: teamsError } = await supabase4.from("kv_store_7f0d90fb").select("value").eq("key", "linear_teams:all").single();
    if (teamsError || !teamsData?.value) {
      return c.json(
        {
          success: false,
          error: "Could not load teams data. Please sync teams first."
        },
        { status: 500 }
      );
    }
    const teamsValue = typeof teamsData.value === "string" ? JSON.parse(teamsData.value) : teamsData.value;
    const validTeamIds = new Set(
      (teamsValue.teams || []).map((t) => t.id)
    );
    const { data: customerMappings, error: mappingsError } = await supabase4.from("kv_store_7f0d90fb").select("key, value").like("key", "customer_teams:%");
    if (mappingsError) {
      return c.json(
        {
          success: false,
          error: "Failed to load customer mappings"
        },
        { status: 500 }
      );
    }
    if (!customerMappings || customerMappings.length === 0) {
      return c.json({
        success: true,
        message: "No customer mappings found",
        data: {
          customersChecked: 0,
          orphanedRemoved: 0,
          customersUpdated: 0
        }
      });
    }
    let totalOrphanedRemoved = 0;
    let customersUpdated = 0;
    const cleanupDetails = [];
    for (const mapping of customerMappings) {
      const customerId = mapping.key.replace("customer_teams:", "");
      const teamIds = Array.isArray(mapping.value) ? mapping.value : [];
      const validTeams = teamIds.filter((teamId) => validTeamIds.has(teamId));
      const orphanedTeams = teamIds.filter((teamId) => !validTeamIds.has(teamId));
      if (orphanedTeams.length > 0) {
        await supabase4.from("kv_store_7f0d90fb").update({
          value: validTeams
        }).eq("key", `customer_teams:${customerId}`);
        totalOrphanedRemoved += orphanedTeams.length;
        customersUpdated++;
        cleanupDetails.push({
          customerId,
          removed: orphanedTeams,
          remaining: validTeams.length
        });
      }
    }
    return c.json({
      success: true,
      message: `Cleanup complete! Removed ${totalOrphanedRemoved} orphaned team assignments from ${customersUpdated} customers`,
      data: {
        customersChecked: customerMappings.length,
        orphanedRemoved: totalOrphanedRemoved,
        customersUpdated,
        validTeamsCount: validTeamIds.size,
        details: cleanupDetails
      }
    });
  } catch (error) {
    console.error("[Linear Cleanup] Error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to cleanup orphaned mappings",
        message: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
});
linearMaintenanceRoutes.get("/linear/validate-mappings", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    const isSuperAdmin = c.get("isSuperAdmin");
    if (!["superadmin", "admin", "client_manager"].includes(role) && !isSuperAdmin) {
      return c.json(
        {
          success: false,
          error: "Unauthorized. Only admins can validate mappings."
        },
        { status: 403 }
      );
    }
    const supabase4 = createClient6(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    const { data: teamsData, error: teamsError } = await supabase4.from("kv_store_7f0d90fb").select("value").eq("key", "linear_teams:all").single();
    if (teamsError || !teamsData?.value) {
      return c.json(
        {
          success: false,
          error: "Could not load teams data. Please sync teams first."
        },
        { status: 500 }
      );
    }
    const teamsValue = typeof teamsData.value === "string" ? JSON.parse(teamsData.value) : teamsData.value;
    const validTeamIds = new Set(
      (teamsValue.teams || []).map((t) => t.id)
    );
    const teamMap = new Map(
      (teamsValue.teams || []).map((t) => [t.id, t])
    );
    const { data: customerMappings } = await supabase4.from("kv_store_7f0d90fb").select("key, value").like("key", "customer_teams:%");
    if (!customerMappings || customerMappings.length === 0) {
      return c.json({
        success: true,
        message: "No customer mappings found",
        data: {
          validTeamsCount: validTeamIds.size,
          customersChecked: 0,
          customersWithOrphans: 0,
          totalOrphaned: 0,
          issues: []
        }
      });
    }
    const issues = [];
    let totalOrphaned = 0;
    for (const mapping of customerMappings) {
      const customerId = mapping.key.replace("customer_teams:", "");
      const teamIds = Array.isArray(mapping.value) ? mapping.value : [];
      const orphaned = [];
      for (const teamId of teamIds) {
        if (!validTeamIds.has(teamId)) {
          const team = teamMap.get(teamId);
          orphaned.push({
            teamId,
            note: team ? `Team "${team.name}" no longer exists` : "Unknown team (deleted from Linear)"
          });
          totalOrphaned++;
        }
      }
      if (orphaned.length > 0) {
        issues.push({
          customerId,
          orphanedTeams: orphaned,
          validTeamsCount: teamIds.length - orphaned.length
        });
      }
    }
    return c.json({
      success: true,
      message: totalOrphaned > 0 ? `Found ${totalOrphaned} orphaned team assignments in ${issues.length} customers. Use cleanup endpoint to remove them.` : "All customer-team mappings are valid",
      data: {
        validTeamsCount: validTeamIds.size,
        customersChecked: customerMappings.length,
        customersWithOrphans: issues.length,
        totalOrphaned,
        issues
      }
    });
  } catch (error) {
    console.error("[Linear Validate] Error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to validate mappings",
        message: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
});

// src/server/routes/issueRoutes.ts
init_authHelpers();
import { Hono as Hono7 } from "hono";
var issueRoutes = new Hono7();
issueRoutes.use("*", authMiddleware);
issueRoutes.get("/issues/team/:teamId", async (c) => {
  try {
    const user = c.get("user");
    const teamId = c.req.param("teamId");
    const accessCheck = await teamMethodsV2.checkUserTeamAccess(
      user.id,
      teamId
    );
    if (!accessCheck.success) {
      return c.json(
        { success: false, error: "Access denied to this team" },
        { status: 403 }
      );
    }
    const result = await getTeamIssues(teamId);
    if (!result.success) {
      return c.json(
        { success: false, error: result.error },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Issues] Get team issues error:", error);
    return c.json(
      { success: false, error: "Failed to fetch team issues" },
      { status: 500 }
    );
  }
});
issueRoutes.get("/issues/team/:teamId/by-state", async (c) => {
  try {
    const user = c.get("user");
    const teamId = c.req.param("teamId");
    const accessCheck = await teamMethodsV2.checkUserTeamAccess(
      user.id,
      teamId
    );
    if (!accessCheck.success) {
      return c.json(
        { success: false, error: "Access denied to this team" },
        { status: 403 }
      );
    }
    const result = await getTeamIssuesByState(
      teamId
    );
    if (!result) {
      return c.json(
        {
          success: false,
          error: "Failed to fetch issues by state"
        },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Issues] Get issues by state error:", error);
    return c.json(
      {
        success: false,
        error: "Failed to fetch issues by state"
      },
      { status: 500 }
    );
  }
});
issueRoutes.get("/issues/:issueId", async (c) => {
  try {
    const user = c.get("user");
    const issueId = c.req.param("issueId");
    const issue = await getIssueDetail(issueId);
    if (!issue) {
      return c.json(
        { success: false, error: "Issue not found" },
        { status: 404 }
      );
    }
    const response = {
      success: true,
      data: {
        issue
      }
    };
    return c.json(response);
  } catch (error) {
    console.error("[Issues] Get issue error:", error);
    return c.json(
      { success: false, error: "Failed to fetch issue" },
      { status: 500 }
    );
  }
});
issueRoutes.put("/issues/:issueId/state", async (c) => {
  try {
    const user = c.get("user");
    const issueId = c.req.param("issueId");
    const body = await c.req.json();
    const { stateId } = body;
    if (!stateId) {
      return c.json(
        { success: false, error: "stateId is required" },
        { status: 400 }
      );
    }
    const result = await updateIssueState(
      issueId,
      stateId
    );
    if (!result.success) {
      return c.json(
        { success: false, error: result.error },
        { status: 500 }
      );
    }
    return c.json({
      success: true,
      data: result.data,
      message: "Issue state updated successfully"
    });
  } catch (error) {
    console.error("[Issues] Update issue state error:", error);
    return c.json(
      { success: false, error: "Failed to update issue state" },
      { status: 500 }
    );
  }
});
issueRoutes.post("/issues/create", async (c) => {
  try {
    const user = c.get("user");
    const body = await c.req.json();
    const {
      teamId,
      title,
      description,
      priority,
      stateId,
      assigneeId,
      labelIds,
      cycleId
    } = body;
    if (!teamId || !title) {
      return c.json(
        {
          success: false,
          error: "teamId and title are required"
        },
        { status: 400 }
      );
    }
    const accessCheck = await teamMethodsV2.checkUserTeamAccess(
      user.id,
      teamId
    );
    if (!accessCheck.success) {
      return c.json(
        { success: false, error: "Access denied to this team" },
        { status: 403 }
      );
    }
    const result = await createIssue({
      teamId,
      title,
      description,
      priority,
      stateId,
      assigneeId,
      labelIds,
      cycleId
    });
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Issues] Create issue error:", error);
    return c.json(
      { success: false, error: "Failed to create issue" },
      { status: 500 }
    );
  }
});
issueRoutes.post("/issues/:parentIssueId/sub-issues", async (c) => {
  try {
    const user = c.get("user");
    const parentIssueId = c.req.param("parentIssueId");
    const body = await c.req.json();
    const { title, description } = body;
    if (!title) {
      return c.json(
        { success: false, error: "title is required" },
        { status: 400 }
      );
    }
    const result = await createSubIssue(
      parentIssueId,
      title,
      description
    );
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.error("[Issues] Create sub-issue error:", error);
    return c.json(
      { success: false, error: "Failed to create sub-issue" },
      { status: 500 }
    );
  }
});
issueRoutes.post("/issues/cache/invalidate", async (c) => {
  try {
    const user = c.get("user");
    const body = await c.req.json();
    const { teamId } = body;
    const result = await invalidateCache(teamId);
    return c.json({
      success: true,
      message: "Cache invalidated successfully"
    });
  } catch (error) {
    console.error("[Issues] Invalidate cache error:", error);
    return c.json(
      { success: false, error: "Failed to invalidate cache" },
      { status: 500 }
    );
  }
});
issueRoutes.get("/issues/cache/stats", async (c) => {
  try {
    const user = c.get("user");
    const role = c.get("role");
    if (role !== "admin" && role !== "superadmin") {
      return c.json(
        { success: false, error: "Admin access required" },
        { status: 403 }
      );
    }
    const result = await getCacheStats();
    return c.json({
      success: true,
      data: result.data
    });
  } catch (error) {
    console.error("[Issues] Get cache stats error:", error);
    return c.json(
      { success: false, error: "Failed to fetch cache stats" },
      { status: 500 }
    );
  }
});

// src/server/routes/superadminRoutes.ts
init_kv_store();
init_authHelpers();
import { Hono as Hono8 } from "hono";
var superadminRoutes = new Hono8();
async function checkIsSuperAdmin(email) {
  try {
    const superadmins = await getSuperadminEmails();
    return superadmins.includes(email.toLowerCase().trim());
  } catch (error) {
    console.error("[SuperadminRoutes] Error checking superadmin status:", error);
    return false;
  }
}
superadminRoutes.post("/superadmin/initialize", async (c) => {
  try {
    const existingSuperadmins = await get("superadmin:emails");
    if (existingSuperadmins && Array.isArray(existingSuperadmins) && existingSuperadmins.length > 0) {
      console.warn("[SuperadminRoutes] Initialization attempt when list already exists");
      return c.json(
        { success: false, error: "Superadmin list already initialized" },
        { status: 400 }
      );
    }
    const body = await c.req.json();
    const { emails } = body;
    if (!emails || !Array.isArray(emails) || emails.length === 0) {
      return c.json(
        { success: false, error: "Invalid email list" },
        { status: 400 }
      );
    }
    const normalizedEmails = emails.map((email) => email.toLowerCase().trim());
    const validEmails = normalizedEmails.filter((email) => email.includes("@"));
    if (validEmails.length === 0) {
      return c.json(
        { success: false, error: "No valid emails provided" },
        { status: 400 }
      );
    }
    await set("superadmin:emails", validEmails);
    await set("superadmin:settings", {
      enableDynamicSuperadmins: true,
      requireMFA: false,
      maxSuperadmins: 10,
      allowSelfRemoval: false
    });
    const auditKey = `audit:superadmin:initialize:${Date.now()}`;
    await set(auditKey, {
      action: "superadmin_initialized",
      emails: validEmails,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      count: validEmails.length
    });
    return c.json({
      success: true,
      data: {
        superadmins: validEmails,
        count: validEmails.length
      }
    });
  } catch (error) {
    console.error("[SuperadminRoutes] Error initializing:", error);
    return c.json(
      { success: false, error: "Failed to initialize superadmin list" },
      { status: 500 }
    );
  }
});
superadminRoutes.use("*", authMiddleware);
superadminRoutes.get("/superadmin/check", async (c) => {
  try {
    const user = c.get("user");
    const userEmail = (user.email || "").toLowerCase().trim();
    const isSuperAdmin = await checkIsSuperAdmin(userEmail);
    return c.json({
      success: true,
      data: {
        isSuperAdmin,
        email: userEmail
      }
    });
  } catch (error) {
    console.error("[SuperadminRoutes] Error checking superadmin status:", error);
    return c.json(
      { success: false, error: "Failed to check superadmin status" },
      { status: 500 }
    );
  }
});
superadminRoutes.get("/superadmin/list", async (c) => {
  try {
    const user = c.get("user");
    const userEmail = (user.email || "").toLowerCase().trim();
    const superadmins = await getSuperadminEmails();
    const isSuperAdmin = superadmins.includes(userEmail);
    if (!isSuperAdmin) {
      return c.json({
        success: true,
        data: {
          superadmins: [],
          count: 0,
          isSuperAdmin: false
        }
      });
    }
    return c.json({
      success: true,
      data: {
        superadmins,
        count: superadmins.length,
        isSuperAdmin: true
      },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[SuperadminRoutes] Error fetching list:", error);
    return c.json(
      { success: false, error: "Failed to fetch superadmin list" },
      { status: 500 }
    );
  }
});
superadminRoutes.post("/superadmin/add", async (c) => {
  try {
    const user = c.get("user");
    const isSuperAdmin = await checkIsSuperAdmin(user.email || "");
    if (!isSuperAdmin) {
      console.warn(`[SuperadminRoutes] Unauthorized add attempt by ${user.email}`);
      return c.json(
        { success: false, error: "Superadmin access required" },
        { status: 403 }
      );
    }
    const body = await c.req.json();
    const { email, reason } = body;
    if (!email || typeof email !== "string" || !email.includes("@")) {
      return c.json(
        { success: false, error: "Invalid email address" },
        { status: 400 }
      );
    }
    const normalizedEmail = email.toLowerCase().trim();
    const superadmins = await get("superadmin:emails") || [];
    if (superadmins.includes(normalizedEmail)) {
      return c.json(
        { success: false, error: "Email already in superadmin list" },
        { status: 400 }
      );
    }
    const updatedList = [...superadmins, normalizedEmail];
    await set("superadmin:emails", updatedList);
    const auditKey = `audit:superadmin:add:${Date.now()}`;
    await set(auditKey, {
      action: "superadmin_added",
      email: normalizedEmail,
      addedBy: user.email,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      ip: c.req.header("x-forwarded-for") || "unknown",
      userAgent: c.req.header("user-agent"),
      reason: reason || null
    });
    await mdel(["system:superadmins:cache", "system:superadmin:audit:cache"]);
    return c.json({
      success: true,
      data: {
        email: normalizedEmail,
        addedBy: user.email,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  } catch (error) {
    console.error("[SuperadminRoutes] Error adding superadmin:", error);
    return c.json(
      { success: false, error: "Failed to add superadmin" },
      { status: 500 }
    );
  }
});
superadminRoutes.delete("/superadmin/remove/:email", async (c) => {
  try {
    const user = c.get("user");
    const isSuperAdmin = await checkIsSuperAdmin(user.email || "");
    if (!isSuperAdmin) {
      console.warn(`[SuperadminRoutes] Unauthorized remove attempt by ${user.email}`);
      return c.json(
        { success: false, error: "Superadmin access required" },
        { status: 403 }
      );
    }
    const emailToRemove = decodeURIComponent(c.req.param("email")).toLowerCase().trim();
    if (emailToRemove === user.email?.toLowerCase()) {
      console.warn(`[SuperadminRoutes] Self-removal attempt by ${user.email}`);
      return c.json(
        { success: false, error: "Cannot remove yourself from superadmin list" },
        { status: 400 }
      );
    }
    const superadmins = await get("superadmin:emails") || [];
    if (!superadmins.includes(emailToRemove)) {
      return c.json(
        { success: false, error: "Email not in superadmin list" },
        { status: 404 }
      );
    }
    if (superadmins.length === 1) {
      console.warn(`[SuperadminRoutes] Attempt to remove last superadmin by ${user.email}`);
      return c.json(
        { success: false, error: "Cannot remove last superadmin" },
        { status: 400 }
      );
    }
    const updatedList = superadmins.filter((e) => e !== emailToRemove);
    await set("superadmin:emails", updatedList);
    const auditKey = `audit:superadmin:remove:${Date.now()}`;
    await set(auditKey, {
      action: "superadmin_removed",
      email: emailToRemove,
      removedBy: user.email,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      ip: c.req.header("x-forwarded-for") || "unknown",
      userAgent: c.req.header("user-agent")
    });
    await mdel(["system:superadmins:cache", "system:superadmin:audit:cache"]);
    return c.json({
      success: true,
      data: {
        email: emailToRemove,
        removedBy: user.email,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  } catch (error) {
    console.error("[SuperadminRoutes] Error removing superadmin:", error);
    return c.json(
      { success: false, error: "Failed to remove superadmin" },
      { status: 500 }
    );
  }
});
superadminRoutes.get("/superadmin/audit", async (c) => {
  try {
    const user = c.get("user");
    const isSuperAdmin = await checkIsSuperAdmin(user.email || "");
    if (!isSuperAdmin) {
      console.warn(`[SuperadminRoutes] Unauthorized audit access by ${user.email}`);
      return c.json(
        { success: false, error: "Superadmin access required" },
        { status: 403 }
      );
    }
    const cacheKey = "system:superadmin:audit:cache";
    const cached = await get(cacheKey);
    if (cached && typeof cached === "object" && "logs" in cached && "timestamp" in cached) {
      const cacheAge = Date.now() - new Date(cached.timestamp).getTime();
      const CACHE_TTL = 5 * 60 * 1e3;
      if (cacheAge < CACHE_TTL) {
        return c.json({
          success: true,
          data: {
            logs: cached.logs,
            count: cached.logs.length,
            cached: true
          }
        });
      }
    }
    const auditKeys = await getByPrefix("audit:superadmin:");
    if (!auditKeys || auditKeys.length === 0) {
      return c.json({
        success: true,
        data: {
          logs: [],
          count: 0
        }
      });
    }
    const logs = await mget(auditKeys);
    const validLogs = logs.filter((log) => log !== null).sort(
      (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    );
    const limitedLogs = validLogs.slice(0, 100);
    await set(cacheKey, {
      logs: limitedLogs,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      ttl: 5 * 60 * 1e3
    });
    return c.json({
      success: true,
      data: {
        logs: limitedLogs,
        count: limitedLogs.length,
        total: validLogs.length,
        cached: false
      }
    });
  } catch (error) {
    console.error("[SuperadminRoutes] Error fetching audit:", error);
    return c.json(
      { success: false, error: "Failed to fetch audit trail" },
      { status: 500 }
    );
  }
});

// src/server/index.ts
var app = new Hono9();
var ALLOWED_ORIGINS = [
  "http://localhost:5173",
  // Vite default
  "http://localhost:3000",
  // Alternative dev port
  "http://127.0.0.1:5173",
  // Localhost alternative
  "http://127.0.0.1:3000",
  // Localhost alternative
  "https://fwltshzniolrekqhtpgv.supabase.co",
  // Supabase hosted
  "https://dashboard.teifi.work",
  // Production domain
  "https://portal-seven-alpha.vercel.app",
  // Production domain
  // Vercel URLs (dynamic)
  ...process.env.VERCEL_URL ? [`https://${process.env.VERCEL_URL}`] : [],
  ...process.env.NEXT_PUBLIC_VERCEL_URL ? [`https://${process.env.NEXT_PUBLIC_VERCEL_URL}`] : []
].filter(Boolean);
app.use(
  "*",
  cors({
    origin: (origin) => {
      if (!origin) {
        return origin;
      }
      if (ALLOWED_ORIGINS.includes(origin)) {
        return origin;
      }
      console.warn("[CORS] Rejected origin:", origin);
      return null;
    },
    allowMethods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    allowHeaders: ["Content-Type", "Authorization", "X-CSRF-Token"],
    exposeHeaders: ["Content-Length"],
    maxAge: 86400,
    credentials: true
  })
);
app.use("*", logger(console.log));
var API_PREFIX = "/api";
app.route(API_PREFIX, systemRoutes);
app.route(API_PREFIX, adminRoutes);
app.route(API_PREFIX, userRoutes);
app.route(API_PREFIX, teamRoutes);
app.route(API_PREFIX, linearRoutes);
app.route(API_PREFIX, linearMaintenanceRoutes);
app.route(API_PREFIX, issueRoutes);
app.route(API_PREFIX, superadminRoutes);
app.post("/api/debug/clear-ownership-cache", async (c) => {
  try {
    const { createClient: createClient7 } = await import("@supabase/supabase-js");
    const supabase4 = createClient7(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    const { error } = await supabase4.from("kv_store_7f0d90fb").delete().eq("key", "team_ownership_map:all");
    if (error) {
      console.error("[Debug] Error clearing ownership cache:", error);
      return c.json(
        {
          success: false,
          error: error.message
        },
        { status: 500 }
      );
    }
    console.log("[Debug] Ownership cache cleared successfully");
    return c.json({
      success: true,
      message: "Ownership cache cleared",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Debug] Unexpected error:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
});
app.get("/api/debug/ownership-data", async (c) => {
  try {
    const { createClient: createClient7 } = await import("@supabase/supabase-js");
    const supabase4 = createClient7(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    const { data: ownershipData, error: ownershipError } = await supabase4.from("kv_store_7f0d90fb").select("key, value").like("key", "team:%:customer");
    if (ownershipError) {
      return c.json(
        {
          success: false,
          error: ownershipError.message
        },
        { status: 500 }
      );
    }
    const { data: cacheData } = await supabase4.from("kv_store_7f0d90fb").select("key, value").eq("key", "team_ownership_map:all").single();
    const ownershipMap = {};
    if (ownershipData) {
      for (const row of ownershipData) {
        const teamId = row.key.replace("team:", "").replace(":customer", "");
        ownershipMap[teamId] = row.value;
      }
    }
    return c.json({
      success: true,
      data: {
        directMappings: ownershipData?.length || 0,
        ownershipMap,
        cacheExists: !!cacheData,
        cacheAge: cacheData?.value?.timestamp ? Date.now() - cacheData.value.timestamp : null,
        rawData: ownershipData
      },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("[Debug] Error inspecting ownership data:", error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
});
app.get("/", (c) => {
  return c.json({
    name: "Teifi Digital Client Portal API",
    version: "2.0.0",
    status: "operational",
    architecture: "Clean & Modular",
    endpoints: {
      system: `/api/health`,
      admin: `/api/admin/stats`,
      teams: `/api/teams/my-teams`,
      linear: `/api/linear/test`,
      issues: `/api/issues/team/:teamId`,
      superadmin: `/api/superadmin/list`
    },
    documentation: "https://github.com/teifi-digital/client-portal",
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  });
});
app.all("*", (c) => {
  return c.json(
    {
      success: false,
      error: "Endpoint not found",
      path: c.req.path,
      method: c.req.method,
      available_prefixes: []
    },
    { status: 404 }
  );
});
var server_default = app;
if (process.env.VERCEL !== "1") {
  const port = parseInt(process.env.PORT || "3001", 10);
  console.log("Starting Teifi Digital Client Portal Server...");
  console.log(`Server listening on port ${port}`);
  serve(
    {
      fetch: app.fetch,
      port
    },
    (info) => {
      console.log(`Server ready at http://localhost:${info.port}`);
    }
  );
}

// src/api/server.ts
var server_default2 = handle(server_default);
export {
  server_default2 as default
};
