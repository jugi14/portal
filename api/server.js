// @ts-nocheck
// This file is auto-generated by esbuild
// Do not edit directly - edit source files in src/server/
// Bundled from: src/api/server.ts
var Ke=Object.defineProperty;var ye=(s,e)=>()=>(s&&(e=s(s=0)),e);var we=(s,e)=>{for(var t in e)Ke(s,t,{get:e[t],enumerable:!0})};var C={};we(C,{del:()=>T,get:()=>l,getByPrefix:()=>S,mdel:()=>re,mget:()=>$e,mset:()=>Ge,set:()=>w});import{createClient as He}from"@supabase/supabase-js";var H,w,l,T,Ge,$e,re,S,M=ye(()=>{"use strict";H=()=>He(process.env.SUPABASE_URL,process.env.SUPABASE_SERVICE_ROLE_KEY),w=async(s,e)=>{let t=H(),{error:r}=await t.from("kv_store_7f0d90fb").upsert({key:s,value:e});if(r)throw new Error(r.message)},l=async s=>{try{let e=H();if(!e)throw new Error("Failed to initialize Supabase client - check SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY");let{data:t,error:r}=await e.from("kv_store_7f0d90fb").select("value").eq("key",s).maybeSingle();if(r)throw new Error(`KV Store get error for key "${s}": ${r.message}`);return t?.value}catch(e){throw console.error(`[KV Store] get("${s}") error:`,e),e}},T=async s=>{let e=H(),{error:t}=await e.from("kv_store_7f0d90fb").delete().eq("key",s);if(t)throw new Error(t.message)},Ge=async(s,e)=>{let t=H(),{error:r}=await t.from("kv_store_7f0d90fb").upsert(s.map((a,o)=>({key:a,value:e[o]})));if(r)throw new Error(r.message)},$e=async s=>{let e=H(),{data:t,error:r}=await e.from("kv_store_7f0d90fb").select("value").in("key",s);if(r)throw new Error(r.message);return t?.map(a=>a.value)??[]},re=async s=>{let e=H(),{error:t}=await e.from("kv_store_7f0d90fb").delete().in("key",s);if(t)throw new Error(t.message)},S=async s=>{try{let e=H();if(!e)throw new Error("Failed to initialize Supabase client - check SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY");let{data:t,error:r}=await e.from("kv_store_7f0d90fb").select("key, value").like("key",s+"%");if(r)throw new Error(`KV Store getByPrefix error for prefix "${s}": ${r.message}`);return t?.map(a=>a.key)??[]}catch(e){throw console.error(`[KV Store] getByPrefix("${s}") error:`,e),e}}});var oe={};we(oe,{ENHANCED_ROLE_DEFINITIONS:()=>ae,ROLE_HIERARCHY:()=>Se,adminMiddleware:()=>ke,authMiddleware:()=>E,checkAuthPermissions:()=>W,getDefaultRole:()=>Le,getSuperadminEmails:()=>Y,hasPermission:()=>Ue,hasRoleLevel:()=>Pe,isSuperAdminUser:()=>Ie,isTeifiUser:()=>Fe,supabase:()=>D});import{createClient as ze}from"@supabase/supabase-js";async function Y(){try{let s="system:superadmins:cache",e;try{e=await l(s)}catch{}if(e&&typeof e=="object"&&"emails"in e&&"timestamp"in e){let r=Date.now()-new Date(e.timestamp).getTime(),a=300*1e3;if(r<a)return e.emails}let t;try{t=await l("superadmin:emails")}catch{let a=ve();if(a.length>0)try{await w("superadmin:emails",a),console.log("[Auth] Auto-initialized superadmin list from fallback:",a.length,"emails")}catch(o){console.warn("[Auth] Failed to auto-initialize superadmin list:",o)}return a}if(!t||!Array.isArray(t))return console.warn("[Auth] No superadmin list in KV (invalid data), using fallback"),ve();try{await w(s,{emails:t,timestamp:new Date().toISOString(),ttl:300*1e3})}catch{}return t}catch(s){return console.error("[Auth] Error fetching superadmin list:",s),ve()}}function ve(){let s=process.env.SUPERADMIN_EMAILS_FALLBACK;return s?s.split(",").map(e=>e.trim().toLowerCase()):(console.error("[Auth] CRITICAL: No superadmin list in KV store and no fallback configured"),[])}async function Le(s){return await Ie(s)?"superadmin":s.includes("@teifi.com")?be["@teifi.com"]:s.includes("@teifi.ca")?be["@teifi.ca"]:be.default}function Ue(s,e,t=!1){return t||s==="superadmin"?!0:ae[s]?.permissions.includes(e)||!1}function Pe(s,e){if(s==="superadmin")return!0;let t=Se[s]||0,r=Se[e]||0;return t>=r}async function Ie(s){let e=s.toLowerCase().trim();return(await Y()).includes(e)}function Fe(s){return Qe.some(e=>s.includes(e))}async function W(s,e,t){try{let{data:{user:r},error:a}=await D.auth.getUser(s);if(!r||a)return{authorized:!1,user:null,userPermissions:null,role:"viewer",error:a?.message||"Authentication failed",isSuperAdmin:!1};let o=(r.email||"").toLowerCase().trim(),[n,c,i]=await Promise.all([l(`user:${r.id}`),Le(o),Ie(o)]),u=Fe(o);if(n)i&&n.role!=="superadmin"&&(console.log(`[Auth] Correcting role for superadmin ${o}: ${n.role} -> superadmin`),n.role="superadmin",n.status="active",n.updatedAt=new Date().toISOString(),await w(`user:${r.id}`,n)),n.status==="pending"&&(console.log(`[Auth] Auto-activating user ${o}: pending -> active`),n.status="active",n.updatedAt=new Date().toISOString(),await w(`user:${r.id}`,n),console.log(`[Auth] User ${o} activated successfully (role: ${c})`));else{let g=r.user_metadata?.name||r.user_metadata?.full_name||o.split("@")[0];n={id:r.id,email:o,role:c,status:"active",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),metadata:{name:g}},await w(`user:${r.id}`,n),await w(`user:${r.id}:customers`,[]),console.log(`[Auth] Created ${c} user: ${o} (${i?"superadmin":u?"Teifi admin":"customer user"})`)}let m=i?"superadmin":n.role,d=m==="superadmin"||i;return n.status!=="active"?(console.error(`[Auth] Authentication failed for ${o}: Status=${n.status}, Role=${m}, IsTeifi=${u}, IsSuperAdmin=${d}`),{authorized:!1,user:r,userPermissions:n,role:m,error:`Account status: ${n.status}. Please contact an administrator.`,isSuperAdmin:d}):(console.log(`[Auth] Authentication successful for ${o}: Role=${m}, Status=${n.status}`),e&&!Ue(m,e,d)?{authorized:!1,user:r,userPermissions:n,role:m,error:`Missing required permission: ${e}`,isSuperAdmin:d}:t&&!Pe(m,t)?{authorized:!1,user:r,userPermissions:n,role:m,error:`Insufficient role level. Required: ${t}, Current: ${m}`,isSuperAdmin:d}:{authorized:!0,user:r,userPermissions:n,role:m,isSuperAdmin:d,error:null})}catch(r){return console.error("[Auth] Authentication error:",r),{authorized:!1,user:null,userPermissions:null,role:"viewer",error:"Authentication failed",isSuperAdmin:!1}}}async function E(s,e){let t=s.get("_authCheck");if(t){s.set("user",t.user),s.set("userPermissions",t.userPermissions),s.set("role",t.role),s.set("isSuperAdmin",t.isSuperAdmin),await e();return}let r=s.req.header("Authorization");if(!r||!r.startsWith("Bearer "))return s.json({success:!1,error:"Missing or invalid authorization header"},{status:401});let a=r.split(" ")[1],o=await W(a);if(!o.authorized)return s.json({success:!1,error:o.error||"Unauthorized"},{status:401});s.set("_authCheck",o),s.set("user",o.user),s.set("userPermissions",o.userPermissions),s.set("role",o.role),s.set("isSuperAdmin",o.isSuperAdmin),await e()}async function ke(s,e){let t=s.req.header("Authorization");if(!t||!t.startsWith("Bearer "))return s.json({success:!1,error:"Missing or invalid authorization header"},{status:401});let r=t.split(" ")[1],a=await W(r,"manage_users");if(!a.authorized)return s.json({success:!1,error:a.error||"Admin access required"},{status:403});s.set("user",a.user),s.set("userPermissions",a.userPermissions),s.set("role",a.role),s.set("isSuperAdmin",a.isSuperAdmin),await e()}var D,Se,Qe,be,ae,V=ye(()=>{"use strict";M();D=ze(process.env.SUPABASE_URL,process.env.SUPABASE_SERVICE_ROLE_KEY),Se={superadmin:100,admin:80,client_manager:60,client_user:40,tester:30,viewer:10};Qe=["@teifi.com","@teifi.ca"],be={"@teifi.com":"admin","@teifi.ca":"admin",default:"viewer"},ae={superadmin:{name:"Super Administrator",role:"superadmin",description:"Complete system access, manage all customers and global settings",permissions:["view_issues","create_issues","edit_issues","delete_issues","view_project_status","manage_users","manage_permissions","access_linear_test","view_analytics","export_data","manage_system","manage_customers","manage_teams","view_admin","access_all_customers","manage_security"]},admin:{name:"Administrator",role:"admin",description:"Manage users and customers within assigned scope",permissions:["view_issues","create_issues","edit_issues","delete_issues","view_project_status","manage_users","manage_permissions","access_linear_test","view_analytics","export_data","manage_customers","manage_teams","view_admin"]},client_manager:{name:"Client Manager",role:"client_manager",description:"Manage team members and view analytics",permissions:["view_issues","create_issues","edit_issues","view_project_status","manage_permissions","view_analytics"]},client_user:{name:"Client User",role:"client_user",description:"Create and manage own issues",permissions:["view_issues","create_issues","edit_issues","view_project_status"]},tester:{name:"Tester",role:"tester",description:"Test features and report bugs",permissions:["view_issues","create_issues","view_project_status"]},viewer:{name:"Viewer",role:"viewer",description:"View-only access to assigned projects",permissions:["view_issues","view_project_status"]}}});var ne={};we(ne,{LinearTeamService:()=>X});import{createClient as Je}from"@supabase/supabase-js";var G,X,Z=ye(()=>{"use strict";G=Je(process.env.SUPABASE_URL,process.env.SUPABASE_SERVICE_ROLE_KEY),X=class{config;baseUrl="https://api.linear.app/graphql";constructor(e){this.config={apiKey:e||process.env.LINEAR_API_KEY||"",teamId:process.env.LINEAR_TEAM_ID||"",workspaceId:process.env.LINEAR_WORKSPACE_ID||""}}async testConnection(){if(console.log("Testing Linear connection..."),console.log("API Key present:",!!this.config.apiKey),console.log("API Key prefix:",this.config.apiKey?.substring(0,10)+"..."),!this.config.apiKey)return{success:!1,message:"Linear API key not configured. Please set LINEAR_API_KEY environment variable."};if(!this.config.apiKey.startsWith("lin_api_"))return{success:!1,message:'Invalid Linear API key format. API key should start with "lin_api_"'};let e=`
      query {
        viewer {
          id
          name
          email
        }
        organization {
          id
          name
        }
      }
    `;try{let t=await this.makeGraphQLRequest(e);return t.data?.viewer?{success:!0,message:"Linear API connection successful",data:{user:t.data.viewer,organization:t.data.organization,apiKeyPrefix:this.config.apiKey.substring(0,10)+"..."}}:{success:!1,message:"Linear API returned unexpected response",data:t}}catch(t){return{success:!1,message:`Linear API connection failed: ${t instanceof Error?t.message:"Unknown error"}`,data:{error:t.toString()}}}}async makeGraphQLRequest(e,t={},r={}){if(!this.config.apiKey)throw new Error("Linear API key not configured");let a=e.match(/(?:query|mutation)\s+(\w+)/),o=a?a[1]:"UnknownQuery";console.log(`[Linear TeamService] Executing ${o}`),console.log("[Linear TeamService] Variables:",JSON.stringify(t,null,2)),Object.entries(t).forEach(([i,u])=>{let m=typeof u,d=typeof u=="string"&&/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(u);console.log(`[Linear TeamService] Variable ${i}: ${m}${d?" (UUID)":""} = ${u}`)});let n=new AbortController,c=setTimeout(()=>n.abort(),15e3);try{console.log("Making Linear GraphQL request with API key:",this.config.apiKey?.substring(0,8)+"...");let i=await fetch(this.baseUrl,{method:"POST",headers:{Authorization:this.config.apiKey,"Content-Type":"application/json","public-file-urls-expire-in":"3600"},body:JSON.stringify({query:e,variables:t}),signal:n.signal});if(clearTimeout(c),!i.ok){let m=`Linear API HTTP error: ${i.status} ${i.statusText}`;try{let d=await i.text();console.error(`[Linear TeamService] HTTP Error for ${o}:`,d),m+=` - ${d}`}catch(d){console.error("Could not read error response body:",d)}throw new Error(m)}let u=await i.json();if(u.errors){console.error(`[Linear TeamService] GraphQL Errors for ${o}:`,u.errors),console.error(`[Linear TeamService] Failed Query: ${o}`),console.error("[Linear TeamService] Failed Variables:",JSON.stringify(t,null,2)),console.error("[Linear TeamService] Query Text:",e);let m=u.errors[0]?.message||"Unknown GraphQL error";if(m.includes("Variable")&&m.includes("type")&&m.includes("expecting"))throw console.error(`[Linear TeamService] TYPE MISMATCH ERROR in ${o}:`),console.error(`[Linear TeamService] Error: ${m}`),new Error(`Linear GraphQL Type Error in ${o}: ${m}`);let d=u.errors.find(f=>f.message?.includes("Entity not found: Team")||f.extensions?.userPresentableMessage?.includes("Could not find referenced Team"));if(d){if(console.log("Team not found error detected:",d),r.allowTeamNotFound)return{data:null,teamNotFound:!0,errors:u.errors};throw new Error(`Team not found: ${d.extensions?.userPresentableMessage||d.message}`)}let g=u.errors.find(f=>f.message?.includes("authentication")||f.message?.includes("Unauthorized")||f.message?.includes("Invalid token")||f.extensions?.code==="UNAUTHENTICATED");if(g)throw console.error("Linear authentication error:",g),new Error("Linear API authentication failed. Please check your API key.");let h=u.errors[0];throw new Error(`Linear API error in ${o}: ${h.message} (Code: ${h.extensions?.code||"Unknown"})`)}return console.log(`[Linear TeamService] Successfully executed ${o}`),u}catch(i){throw i instanceof Error&&i.name==="AbortError"?new Error("Linear API request timed out"):i}}async syncTeamHierarchy(){if(!this.config.apiKey)return{success:!1,message:"Linear API key not configured"};console.log("[LinearTeamService] Starting team hierarchy sync...");let e=`
      query GetTeamsWithHierarchy($after: String) {
        teams(first: 20, after: $after) {
          nodes {
            id
            name
            key
            description
            color
            icon
            createdAt
            updatedAt
            parent {
              id
              name
              key
            }
            organization {
              id
              name
            }
            states(first: 20) {
              nodes {
                id
                name
                type
                color
                position
              }
            }
            labels(first: 20) {
              nodes {
                id
                name
                color
                description
              }
            }
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    `;try{let t=[],r,a=0;for(;;){a++,console.log(`[Sync] Fetching teams page ${a}...`);let f=await this.makeGraphQLRequest(e,{after:r});if(f.data?.teams?.nodes){let y=f.data.teams.nodes;t=t.concat(y),console.log(`[Sync] Page ${a}: ${y.length} teams (total: ${t.length})`);let p=f.data.teams.pageInfo;if(!p.hasNextPage){console.log(`[Sync] Complete! Total teams: ${t.length}`);break}r=p.endCursor}else break}if(t.length===0)return console.warn("\uFE0F [Sync] No teams found in Linear workspace"),{success:!0,message:"No teams found in Linear workspace",data:{teamsCount:0,teams:[]}};console.log("[Sync] Building team hierarchy...");let o=new Date().toISOString();console.log("[Sync] Cleaning up old team entries...");let{data:n}=await G.from("kv_store_7f0d90fb").select("key").like("key","linear_teams:%").neq("key","linear_teams:all");n&&n.length>0&&(console.log(`[Sync] Found ${n.length} existing team entries`),await G.from("kv_store_7f0d90fb").delete().like("key","linear_teams:%").neq("key","linear_teams:all"),console.log(`[Sync] Deleted ${n.length} old team entries`)),console.log("[Sync] Storing new team entries...");for(let f of t){let y={...f,parent_id:f.parent?.id||null,parent_name:f.parent?.name||null,parent_key:f.parent?.key||null,syncedAt:o,source:"linear_api"};await G.from("kv_store_7f0d90fb").upsert({key:`linear_teams:${f.id}`,value:y})}console.log(`[Sync] Stored ${t.length} new team entries`);let i=(f=>{let y=new Map(f.map($=>[$.id,{...$,children:[],level:0,childCount:0}])),p=[];for(let $ of f){let I=y.get($.id);if(I)if($.parent?.id&&y.has($.parent.id)){let U=y.get($.parent.id);U&&(U.children.push(I),I.level=U.level+1)}else p.push(I)}let v=$=>{if($.children.length===0)return $.childCount=0,$.totalDescendants=0,0;let I=$.children.length;for(let U of $.children)I+=v(U);return $.childCount=$.children.length,$.totalDescendants=I,I};for(let $ of p)v($);return p})(t);console.log(`[Sync] Built hierarchy: ${i.length} root teams, ${t.length} total teams`);let u=t.map(f=>({id:f.id,name:f.name,key:f.key,description:f.description,color:f.color,icon:f.icon,parent_id:f.parent?.id||null,parent_name:f.parent?.name||null}));await G.from("kv_store_7f0d90fb").upsert({key:"linear_teams:all",value:{teams:u,hierarchy:i,rootTeamsCount:i.length,totalTeamsCount:u.length,count:u.length,syncedAt:o}}),t[0]?.organization&&await G.from("kv_store_7f0d90fb").upsert({key:"linear:organization",value:{...t[0].organization,teamsCount:t.length,syncedAt:o}}),console.log("[Sync] Team hierarchy successfully synced to KV"),console.log(`[Sync] Hierarchy stats: ${i.length} roots, ${t.length} total teams`),console.log("[Sync] Validating customer-team mappings...");let m=new Set(t.map(f=>f.id)),{data:d}=await G.from("kv_store_7f0d90fb").select("key, value").like("key","customer_teams:%"),g=0,h=[];if(d&&d.length>0){console.log(`[Sync] Checking ${d.length} customer mappings...`);for(let f of d){let y=f.key.replace("customer_teams:",""),v=(Array.isArray(f.value)?f.value:[]).filter($=>!m.has($));v.length>0&&(g+=v.length,h.push({customerId:y,teamIds:v}),console.log(`[Sync] Customer ${y} has ${v.length} orphaned team assignments:`,v))}}return g>0?(console.log(`[Sync] WARNING: Found ${g} orphaned team assignments across ${h.length} customers`),console.log("[Sync] These teams were deleted in Linear but still assigned to customers"),console.log("[Sync] Use /admin/cleanup-orphaned-mappings endpoint to clean up")):console.log("[Sync] All customer-team mappings are valid"),{success:!0,message:`Successfully synced ${t.length} teams (${i.length} root teams)`,data:{teamsCount:t.length,rootTeamsCount:i.length,teams:u,hierarchy:i,syncedAt:o,orphanedMappings:h.length>0?{count:g,customers:h.length,details:h}:null}}}catch(t){return console.error("[Sync] Team hierarchy sync error:",t),{success:!1,message:`Sync failed: ${t instanceof Error?t.message:"Unknown error"}`}}}async listTeams(){if(!this.config.apiKey)return{success:!1,message:"Linear API key not configured"};let e=`
      query GetTeamsPaginated($after: String) {
        teams(first: 250, after: $after) {
          nodes {
            id
            name
            key  
            description
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    `;try{console.log("Starting Linear teams query with pagination...");let t=[],r,a=0;for(;;){a++,console.log(`[Pagination] Fetching teams page ${a}`);let o=await this.makeGraphQLRequest(e,{after:r});if(o.data?.teams?.nodes){let n=o.data.teams.nodes;t=t.concat(n),console.log(`[Pagination] Page ${a}: Retrieved ${n.length} teams (total: ${t.length})`);let c=o.data.teams.pageInfo;if(!c.hasNextPage){console.log(`[Pagination] Complete! Total teams fetched: ${t.length} across ${a} page(s)`);break}r=c.endCursor}else break}return t.length>0?(console.log(`Found ${t.length} teams in Linear workspace`),{success:!0,teams:t,message:"Teams fetched successfully"}):{success:!1,message:"No teams found in Linear workspace"}}catch(t){return console.error("Linear listTeams error:",t),{success:!1,message:`Failed to fetch teams: ${t instanceof Error?t.message:"Unknown error"}`}}}isValidTeamId(e){if(!e||typeof e!="string")return!1;let t=e.trim();return t.length===0?!1:/^[a-zA-Z0-9\-_]{2,50}$/.test(t)}async getTeamById(e){if(!this.isValidTeamId(e))return console.log(`Invalid team ID format: ${e}`),null;let t=`
      query GetTeam($teamId: String!) {
  team(id: $teamId) {
    id
    name
    key
    description
    members {
      nodes {
        name
        email
        avatarUrl
      }
    }
    states {
      nodes {
        id
        name
        type
        color
        position
      }
    }
    labels {
      nodes {
        id
        name
        color
        description
      }
    }
    createdAt
    updatedAt
  }
}
    `;try{let r=await this.makeGraphQLRequest(t,{teamId:e},{allowTeamNotFound:!0});return r.teamNotFound?(console.log(`Team ${e} not found in Linear workspace`),null):r.data?.team?(console.log(`Fetched team: ${r.data.team.name}`),r.data.team):null}catch(r){return console.error("Failed to fetch team by ID:",r),r instanceof Error&&r.message.includes("Entity not found: Team")&&console.log(`Team ${e} does not exist in Linear workspace`),null}}async getTeamLabels(e){if(!this.isValidTeamId(e))return console.log(`Invalid team ID format for labels: ${e}`),[];let t=`
      query GetTeamLabels($teamId: String!) {
        team(id: $teamId) {
          id
          name
          labels {
            nodes {
              id
              name
              color
              description
              createdAt
            }
          }
        }
      }
    `;try{let r=await this.makeGraphQLRequest(t,{teamId:e},{allowTeamNotFound:!0});return r.teamNotFound?(console.log(`Team ${e} not found when fetching labels`),[]):r.data?.team?.labels?.nodes?(console.log(`Fetched ${r.data.team.labels.nodes.length} labels for team: ${r.data.team.name}`),r.data.team.labels.nodes):[]}catch(r){return console.error("Failed to fetch team labels:",r),r instanceof Error&&r.message.includes("Entity not found: Team")?(console.log(`Team ${e} does not exist when fetching labels`),[]):[]}}async authenticateUser(e){if(!e)throw new Error("Authorization token required");let{data:{user:t},error:r}=await G.auth.getUser(e);if(r||!t)throw new Error("Invalid or expired token");return{user:t,userEmail:t.email||"unknown"}}async getTeamsWithHierarchy(){if(!this.config.apiKey)throw new Error("Linear API key not configured");let e=`
      query GetTeamsPaginated($after: String) {
        teams(first: 250, after: $after) {
          nodes {
            id
            name
            key
            description
            parent { id name }
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    `,t=null,r=[],a=1;try{for(console.log("Fetching Linear teams with pagination...");;){console.log(`\uFE0F  Fetching page ${a} (after: ${t||"none"})`);let c=await this.makeGraphQLRequest(e,{after:t});if(!c.data?.teams?.nodes){console.warn("\uFE0F No team nodes in Linear response.");break}let{nodes:i,pageInfo:u}=c.data.teams;if(r.push(...i),console.log(`Page ${a}: fetched ${i.length} teams (total ${r.length})`),!u?.hasNextPage){console.log("All teams fetched from Linear.");break}t=u.endCursor,a++,await new Promise(m=>setTimeout(m,150))}let o=r.filter(c=>c.parent).length,n=r.filter(c=>!c.parent).length;return console.log("Linear Team Stats:",{total:r.length,rootTeams:n,withParent:o}),r}catch(o){throw console.error("Failed to fetch teams with hierarchy:",o),o}}buildHierarchyFromParents(e){console.log("Building hierarchy from parent relationships..."),console.log(`Processing ${e.length} teams`);let t=new Map(e.map(o=>[o.id,{id:o.id,name:o.name,key:o.key||o.id,description:o.description||"",parent:o.parent,children:[],level:0,childCount:0,totalDescendants:0}]));console.log(`Created teams map with ${t.size} entries`);for(let o of e)if(o.parent?.id&&t.has(o.parent.id)){let n=t.get(o.parent.id),c=t.get(o.id);n&&c&&(n.children.push(c),console.log(`  \u21B3 Attached "${c.name}" to parent "${n.name}"`))}let r=(o,n)=>{o.level=n,o.childCount=o.children.length;let c=o.children.length;for(let i of o.children)c+=r(i,n+1);return o.totalDescendants=c,c},a=e.filter(o=>!o.parent||!o.parent.id).map(o=>t.get(o.id)).filter(Boolean);console.log(`Found ${a.length} root teams`);for(let o of a)r(o,0),console.log(` Root: "${o.name}" [${o.key}] - ${o.childCount} direct children, ${o.totalDescendants} total descendants`);return a.sort((o,n)=>o.name.localeCompare(n.name)),console.log(`Built hierarchy: ${a.length} root teams with full tree structure`),a}buildHierarchyFromNested(e){return console.log("\uFE0F buildHierarchyFromNested is deprecated, using buildHierarchyFromParents instead"),this.buildHierarchyFromParents(e)}countAllTeams(e){return e.reduce((t,r)=>t+1+this.countAllTeams(r.children||[]),0)}async validateTeam(e){let t=Date.now(),r={success:!1,message:"",team:null,error:null,details:[],timestamp:new Date().toISOString(),responseTime:0};try{if(!e||typeof e!="string"||e.trim()==="")return r.error="Team ID is required and must be a non-empty string",r.details=["Provide a valid team ID (not empty, null, or whitespace)","Team ID should be a string format","Check if the team ID was passed correctly"],r;if(!this.isValidTeamId(e))return r.error="Invalid team ID format",r.details=["Team ID must be 2-50 characters with alphanumeric, hyphens, or underscores only",'Examples: "a1", "team-backend-dev", "eng_platform_123"',"Copy team ID directly from Linear interface",`Provided: "${e}" (${e.length} chars)`],r;if(!this.config.apiKey)return r.error="Linear API key not configured",r.details=["Set LINEAR_API_KEY environment variable","Generate API key from Linear Settings \u2192 API","Ensure API key has team read permissions"],r;let a=`
        query ValidateTeam($teamId: ID!) {
          team(id: $teamId) {
            id
            name
            key
            description
            createdAt
            updatedAt
          }
        }
      `;console.log(`Validating team ID: ${e}`);let o=await this.makeGraphQLRequest(a,{teamId:e},{allowTeamNotFound:!0});return o.teamNotFound?(r.error="Team not found in workspace",r.details=["Contact Linear admin if team should exist"],r):o.data?.team?(r.success=!0,r.message=`Team found: ${o.data.team.name} (${o.data.team.key})`,r.team=o.data.team,r.details=["Team validation successful","Team exists and is accessible"],r):(r.error="Unexpected response from Linear API",r.details=["Try again in a few moments"],r)}catch(a){return console.error("Team validation error:",a),a instanceof Error&&(a.message.includes("Entity not found: Team")?(r.error="Team entity not found",r.details=["Verify API key has sufficient permissions"]):a.message.includes("Unauthorized")?(r.error="API authentication failed",r.details=["Invalid or expired Linear API key"]):a.message.includes("timeout")?(r.error="Linear API request timeout",r.details=["Try again in a few moments"]):(r.error=a.message,r.details=["Check server logs for details"])),r}finally{r.responseTime=Date.now()-t}}async getSingleTeam(e){if(!this.isValidTeamId(e))return console.log(`Invalid team ID format: ${e}`),null;let t=`
      query GetSingleTeam($teamId: ID!) {
        team(id: $teamId) {
          id
          name
          key
          description
          parent {
            id
            name
            key
          }
          members {
            nodes {
              id
              name
              email
              avatarUrl
            }
          }
          states {
            nodes {
              id
              name
              type
              color
              position
            }
          }
          labels {
            nodes {
              id
              name
              color
              description
            }
          }
          createdAt
          updatedAt
        }
      }
    `;try{let r=await this.makeGraphQLRequest(t,{teamId:e},{allowTeamNotFound:!0});return r.teamNotFound?(console.log(`Team ${e} not found in Linear workspace`),null):r.data?.team?(console.log(`Fetched single team: ${r.data.team.name} (${r.data.team.key})`),r.data.team):null}catch(r){return console.error("Failed to fetch single team:",r),null}}async getTeamsBatch(e,t=!1){if(!e||e.length===0)return[];let r=10,a=[];for(let n=0;n<e.length;n+=r)a.push(e.slice(n,n+r));console.log(`Processing ${e.length} teams in ${a.length} batches`);let o=[];for(let n of a){let c=await Promise.all(n.map(async i=>{try{return t?await this.getSingleTeam(i):(await this.makeGraphQLRequest(`
                query GetTeamBasic($teamId: String!) {
                  team(id: $teamId) {
                    id
                    name
                    key
                    description
                    parent {
                      id
                      name
                      key
                    }
                  }
                }
              `,{teamId:i})).data?.team||null}catch(u){return console.warn(`Failed to fetch team ${i}:`,u.message),null}}));o.push(...c.filter(Boolean)),a.length>1&&await new Promise(i=>setTimeout(i,100))}return console.log(`Successfully fetched ${o.length}/${e.length} teams`),o}async getProcessedTeamsHierarchy(e=1,t=50){let r=await this.getTeamsWithHierarchy();if(!r||r.length===0)throw new Error("No teams data available from Linear API");let a=this.buildHierarchyFromNested(r),o=this.countAllTeams(a),n=(e-1)*t,c=n+t,i=a.slice(n,c),u={totalTeams:o,rootTeams:a.length,currentPage:e,pageSize:t,totalPages:Math.ceil(a.length/t),hierarchy:i,hasMore:c<a.length};return console.log("Paginated team hierarchy response:",{totalTeams:u.totalTeams,rootTeams:u.rootTeams,currentPage:u.currentPage,totalPages:u.totalPages,returnedRootTeams:i.length}),u}buildTeamHierarchyResponse(e){let t=this.buildHierarchyFromNested(e),a={totalTeams:this.countAllTeams(t),rootTeams:t.length,hierarchy:t};return console.log("Team hierarchy response:",{totalTeams:a.totalTeams,rootTeams:a.rootTeams,rootTeamNames:a.hierarchy.map(o=>`${o.name} [${o.key}] (${o.totalDescendants} descendants)`)}),a}async determineTeamAssignment(e,t){console.log(`Determining team assignment for feature: ${e}`,t);let r=await this.getTeamsWithHierarchy();if(e.toLowerCase().includes("inventory")){let a=r.find(o=>o.name.toLowerCase().includes("inventory")||o.key.toLowerCase().includes("inv"));if(a)return console.log(`Assigned to inventory team: ${a.name}`),a.id}if(r.length>0)return console.log(`Default assignment to: ${r[0].name}`),r[0].id;throw new Error("No teams available for assignment")}async autoAssignEpicOwner(e){console.log(`Auto-assigning epic owner for: ${e}`);try{if((await this.getTeamsWithHierarchy()).length>0){console.log(`Epic ${e} assignment logic not yet implemented`);return}return}catch(t){console.error("Error in autoAssignEpicOwner:",t);return}}async syncTeamsToKV(){console.log("Starting Linear teams sync to KV store...");try{let e=await Promise.resolve().then(()=>(M(),C));console.log("Fetching all teams from Linear API...");let t=await this.getTeamsWithHierarchy();if(!t||t.length===0)throw new Error("No teams found in Linear workspace");console.log(`Fetched ${t.length} teams from Linear`);let r=[],a=Date.now();for(let n of t){let c={id:n.id,name:n.name,key:n.key,description:n.description||null,parent:n.parent||null,createdAt:n.createdAt||new Date().toISOString(),updatedAt:n.updatedAt||new Date().toISOString(),syncedAt:new Date().toISOString()};await e.set(`linear_teams:${n.id}`,c),r.push(n.id),console.log(` Synced team: ${n.name} [${n.key}]`)}await e.set("linear_teams:all",r);let o={lastSync:new Date().toISOString(),teamCount:t.length,syncDuration:Date.now()-a,source:"Linear API"};return await e.set("linear_teams:metadata",o),console.log(`Successfully synced ${t.length} teams to KV store`),console.log(`Sync duration: ${o.syncDuration}ms`),{success:!0,teamCount:t.length,syncMetadata:o,teams:t}}catch(e){throw console.error("Failed to sync teams to KV:",e),e}}async getTeamsFromKV(){console.log("Fetching teams from KV store...");try{let e=await Promise.resolve().then(()=>(M(),C)),t=await e.get("linear_teams:all");if(!t||!Array.isArray(t))return console.warn("\uFE0F No teams found in KV store. Need to sync from Linear first."),{success:!1,message:"No teams synced yet. Please sync from Linear first.",teams:[],metadata:null};console.log(`Found ${t.length} team IDs in KV store`);let r=[];for(let o of t){let n=await e.get(`linear_teams:${o}`);n&&r.push(n)}let a=await e.get("linear_teams:metadata");return console.log(`Retrieved ${r.length} teams from KV store`),a&&console.log(`\u2139\uFE0F  Last sync: ${a.lastSync}`),{success:!0,teams:r,metadata:a}}catch(e){throw console.error("Failed to get teams from KV:",e),e}}async getTeamsHierarchyFromKV(){console.log("Building teams hierarchy from KV store...");let e=await this.getTeamsFromKV();if(!e.success||!e.teams||e.teams.length===0)return{success:!1,message:e.message||"No teams available",hierarchy:[],totalTeams:0,rootTeams:0,metadata:null};let t=this.buildHierarchyFromParents(e.teams),r=this.countAllTeams(t);return console.log(`Built hierarchy: ${t.length} root teams, ${r} total teams`),{success:!0,hierarchy:t,totalTeams:r,rootTeams:t.length,metadata:e.metadata}}async getTeamFromKV(e){console.log(`Fetching team ${e} from KV store...`);try{let r=await(await Promise.resolve().then(()=>(M(),C))).get(`linear_teams:${e}`);return r?(console.log(`Found team in KV: ${r.name} [${r.key}]`),r):(console.warn(`\uFE0F Team ${e} not found in KV store`),null)}catch(t){return console.error(`Failed to get team ${e} from KV:`,t),null}}}});import{handle as ws}from"@hono/node-server/vercel";import"dotenv/config";import{Hono as gs}from"hono";import{cors as fs}from"hono/cors";import{logger as ps}from"hono/logger";import{serve as hs}from"@hono/node-server";V();V();import{Hono as We}from"hono";M();var Te=class{async migrateToV2(){try{console.log("[Migration] Starting v2.0 schema migration...");let e={users_migrated:0,customer_memberships_created:0,team_assignments_created:0,indexes_created:0,errors:[]};console.log("[Migration] Step 1: Migrating user permissions...");let t=await this.migrateUserPermissions();e.users_migrated=t.count,e.customer_memberships_created=t.memberships,t.errors&&e.errors.push(...t.errors),console.log("[Migration] Step 2: Building customer member indexes...");let r=await this.buildCustomerMemberIndexes();e.indexes_created=r.count,r.errors&&e.errors.push(...r.errors),console.log("[Migration] Step 3: Creating team-customer mappings...");let a=await this.createTeamCustomerMappings();return e.team_assignments_created=a.count,a.errors&&e.errors.push(...a.errors),console.log("[Migration] Migration completed!"),console.log("[Migration] Report:",e),{success:!0,report:e}}catch(e){return console.error("[Migration] Migration failed:",e),{success:!1,report:{},error:e instanceof Error?e.message:"Unknown error"}}}async migrateUserPermissions(){let e=[],t=0,r=0;try{let a=await S("user_permissions:");console.log(`[Migration] Found ${a.length} user permission keys`);for(let o of a)try{let n=await l(o);if(!n)continue;let c=o.replace("user_permissions:","");if(n.customer_id&&n.customer_id!=="global"){console.log(`[Migration] Migrating user ${n.email}: ${n.customer_id}`);let i={user_id:c,customer_id:n.customer_id,role:n.role,status:n.status||"active",created_at:n.created_at||new Date().toISOString(),updated_at:new Date().toISOString(),assigned_by:n.created_by||"system-migration"};await w(`user_customer:${c}:${n.customer_id}`,i),r++;let u={...n};delete u.customer_id,n.email?.includes("@teifi.com")||n.email?.includes("@teifi.ca")||delete u.role,await w(o,u),console.log(`[Migration] Migrated user ${n.email}`)}t++}catch(n){let c=`Error migrating user ${o}: ${n}`;console.error(`[Migration] ${c}`),e.push(c)}return console.log(`[Migration] Processed ${t} users, created ${r} memberships`),{count:t,memberships:r,errors:e}}catch(a){return console.error("[Migration] User permissions migration failed:",a),{count:t,memberships:r,errors:[String(a)]}}}async buildCustomerMemberIndexes(){let e=[],t=0;try{let r=await S("user_customer:");console.log(`[Migration] Found ${r.length} user-customer mappings`);let a=new Map;for(let o of r)try{let n=await l(o);if(!n||!n.customer_id)continue;let c=o.split(":")[1],i=n.customer_id;a.has(i)||a.set(i,[]);let u=a.get(i);u.includes(c)||u.push(c)}catch(n){let c=`Error processing ${o}: ${n}`;console.error(`[Migration] ${c}`),e.push(c)}for(let[o,n]of a.entries())try{await w(`customer_members:${o}`,n),t++,console.log(`[Migration] Created index for customer ${o}: ${n.length} members`)}catch(c){let i=`Error creating index for ${o}: ${c}`;console.error(`[Migration] ${i}`),e.push(i)}return console.log(`[Migration] Created ${t} customer member indexes`),{count:t,errors:e}}catch(r){return console.error("[Migration] Index building failed:",r),{count:t,errors:[String(r)]}}}async createTeamCustomerMappings(){let e=[],t=0;try{let r=await S("customer:");console.log(`[Migration] Found ${r.length} customer keys`);for(let a of r)try{let o=a.replace("customer:","");if(o.includes(":"))continue;let n=await l(`customer:${o}:assigned_teams`);if(!Array.isArray(n)||n.length===0)continue;let c=await l(a);if(!c)continue;console.log(`[Migration] Processing customer ${c.name}: ${n.length} teams`);for(let i of n)try{await w(`team_customer:${i}`,o);let u=await l(`linear_teams:${i}`);await w(`customer_teams:${o}:${i}`,{customer_id:o,team_id:i,team_name:u?.name||"Unknown Team",assigned_at:new Date().toISOString(),assigned_by:"system-migration"}),t++,console.log(`[Migration] Mapped team ${i} -> customer ${o}`)}catch(u){let m=`Error mapping team ${i}: ${u}`;console.error(`[Migration] ${m}`),e.push(m)}}catch(o){let n=`Error processing customer ${a}: ${o}`;console.error(`[Migration] ${n}`),e.push(n)}return console.log(`[Migration] Created ${t} team-customer mappings`),{count:t,errors:e}}catch(r){return console.error("[Migration] Team mapping creation failed:",r),{count:t,errors:[String(r)]}}}async validateSchema(){let e=[];try{console.log("[Migration] Validating schema consistency...");let t=await S("user_customer:");for(let n of t){let c=n.split(":")[1];await l(`user_permissions:${c}`)||e.push(`Orphaned membership: ${n} - user not found`)}let r=await S("customer_members:");for(let n of r){let c=n.replace("customer_members:","");await l(`customer:${c}`)||e.push(`Orphaned index: ${n} - customer not found`)}let a=await S("team_customer:");for(let n of a){let c=n.replace("team_customer:",""),i=await l(n);await l(`linear_teams:${c}`)||e.push(`Invalid team mapping: ${n} - team not found`),await l(`customer:${i}`)||e.push(`Invalid team mapping: ${n} - customer not found`)}let o=e.length===0;return console.log(o?"[Migration] Schema validation passed":`\uFE0F [Migration] Found ${e.length} issues`),{valid:o,issues:e}}catch(t){return console.error("[Migration] Schema validation failed:",t),{valid:!1,issues:[String(t)]}}}async getMigrationStatus(){try{let e=await S("user_permissions:"),t=0;for(let n of e){let c=await l(n);c?.customer_id&&c.customer_id!=="global"&&t++}let r=await S("user_customer:"),a=await S("customer_members:"),o=await S("team_customer:");return{old_style_users:t,new_style_memberships:r.length,customer_indexes:a.length,team_mappings:o.length,migration_needed:t>0,migration_complete:t===0&&r.length>0}}catch(e){return console.error("[Migration] Status check failed:",e),{error:String(e)}}}},Re=new Te;M();var F=new We;F.post("/auth/user-login",async s=>{try{let t=s.req.header("Authorization")?.split(" ")[1];if(!t)return console.error("[Auth] Missing authorization header"),s.json({success:!1,error:"No access token provided"},{status:401});let r=await W(t);if(!r.authorized||!r.user)return console.error("[Auth] Authentication failed:",r.error),s.json({success:!1,error:r.error||"Authentication failed"},{status:401});let{user:a,userPermissions:o,role:n,isSuperAdmin:c}=r,i=a.email||"",u=a.user_metadata?.name||a.user_metadata?.full_name||i.split("@")[0],m=a.user_metadata?.avatar_url||null,d=a.id,g=await l(`user:${d}`),h=!g;g?(g.name=u,g.avatar_url=m,g.updatedAt=new Date().toISOString(),g.lastLoginAt=new Date().toISOString(),await w(`user:${d}`,g)):(g={id:d,email:i.toLowerCase(),name:u,avatar_url:m,role:n,status:"active",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),lastLoginAt:new Date().toISOString(),metadata:{name:u}},await w(`user:${d}`,g),await w(`user:${d}:customers`,[]));let f=g.role,p=ae[f]?.permissions||[];return s.json({success:!0,data:{user:{id:d,email:i.toLowerCase(),name:u,avatar_url:m,role:f,status:g.status||"active"},permission:{role:f,status:g.status||"active",customer_id:null},permissions:p},message:h?"Welcome! Access granted.":"Welcome back!"})}catch(e){return console.error("[Auth] Login error:",e),s.json({success:!1,error:"Authentication failed",message:e instanceof Error?e.message:"Unknown error"},{status:500})}});F.get("/health",async s=>{try{let e=new Date().toISOString(),t=!0;try{await l("_health_check_ping"),t=!0}catch{t=!1}return s.json({success:!0,message:"Server is healthy",timestamp:e,version:"2.1.0",environment:"production",services:{server:"operational",kv_store:t?"operational":"degraded",endpoints:{auth:"available",admin:"available",teams:"available",issues:"available"}}})}catch(e){return console.error("[System] Health check failed:",e),s.json({success:!1,message:"Health check failed",error:e instanceof Error?e.message:"Unknown error",timestamp:new Date().toISOString()},{status:503})}});F.get("/status",async s=>s.json({success:!0,status:"online",version:"2.0.0",schema:"v2.0",timestamp:new Date().toISOString(),endpoints:{auth:"available",admin:"available",teams:"available",issues:"available"}}));F.get("/debug/kv/:key",async s=>{try{let e=s.req.param("key"),t=decodeURIComponent(e),r=await l(t);return r?s.json({success:!0,key:t,value:r,type:Array.isArray(r)?"array":typeof r}):s.json({success:!1,error:"Key not found"},{status:404})}catch(e){return console.error("[Debug] Get KV key error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to get KV key"},{status:500})}});F.put("/debug/kv/:key",async s=>{try{let e=s.req.param("key"),t=decodeURIComponent(e),{value:r}=await s.req.json();return await w(t,r),s.json({success:!0,key:t,message:"Key updated successfully"})}catch(e){return console.error("[Debug] Update KV key error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to update KV key"},{status:500})}});F.delete("/debug/kv/:key",async s=>{try{let e=s.req.param("key"),t=decodeURIComponent(e);return await T(t),s.json({success:!0,key:t,message:"Key deleted successfully"})}catch(e){return console.error("[Debug] Delete KV key error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to delete KV key"},{status:500})}});F.get("/debug/kv-all",async s=>{try{let e=["user:","customer:","team:","linear_","user_permissions:","admin_"],t=[];for(let a of e){let o=await S(a);Array.isArray(o)&&t.push(...o.map(n=>typeof n=="string"?n:n.key||"").filter(Boolean))}let r=[...new Set(t)];return s.json({success:!0,keys:r,count:r.length})}catch(e){return console.error("[Debug] Get all keys error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to get all keys"},{status:500})}});F.get("/debug/kv-check",async s=>{try{let e=s.req.query("key")||"linear_teams:all",t=await l(e),r=t,a=typeof t,o=null;if(typeof t=="string")try{r=JSON.parse(t)}catch(n){o=n instanceof Error?n.message:"Parse error",console.error("[Debug] Failed to parse:",n)}return s.json({success:!0,key:e,exists:!!t,rawType:a,rawPreview:typeof t=="string"?t.substring(0,200)+"...":t,parsed:r?{type:typeof r,hasTeams:!!r?.teams,teamsCount:r?.teams?.length||0,teamsPreview:r?.teams?.slice(0,2)||[],hasHierarchy:!!r?.hierarchy,hierarchyCount:r?.hierarchy?.length||0,keys:r?Object.keys(r):[]}:null,parseError:o})}catch(e){return console.error("[Debug] KV check error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Unknown error"},{status:500})}});F.post("/migrate/schema-v2",async s=>{try{let e=s.req.header("Authorization");if(!e||!e.startsWith("Bearer "))return s.json({success:!1,error:"Missing authorization header"},{status:401});let t=e.split(" ")[1],{data:{user:r},error:a}=await D.auth.getUser(t);if(!r||a)return s.json({success:!1,error:"Authentication failed"},{status:401});let{isSuperAdminUser:o}=await Promise.resolve().then(()=>(V(),oe));if(!await o(r.email||""))return s.json({success:!1,error:"Superadmin access required"},{status:403});let c=await Re.migrateToSchemaV2();return c.success?s.json({success:!0,message:"Schema v2 migration completed successfully",data:c.data}):s.json({success:!1,error:c.error},{status:500})}catch(e){return console.error("[Migration] Migration failed:",e),s.json({success:!1,error:"Migration failed"},{status:500})}});F.get("/migrate/status",async s=>{try{let e=s.req.header("Authorization");if(!e||!e.startsWith("Bearer "))return s.json({success:!1,error:"Missing authorization header"},{status:401});let t=e.split(" ")[1],{data:{user:r},error:a}=await D.auth.getUser(t);if(!r||a)return s.json({success:!1,error:"Authentication failed"},{status:401});let o=await l("migration_status");return s.json({success:!0,data:{current_schema:"v2.0",migration_completed:!0,last_migration:o||null}})}catch(e){return console.error("[Migration] Get status failed:",e),s.json({success:!1,error:"Failed to get migration status"},{status:500})}});F.get("/diagnostics",async s=>{try{let e=s.req.header("Authorization");if(!e||!e.startsWith("Bearer "))return s.json({success:!1,error:"Missing authorization header"},{status:401});let t=e.split(" ")[1],r=await W(t);if(!r.authorized||!r.user)return s.json({success:!1,error:"Authentication failed"},{status:401});let{role:a}=r;if(a!=="admin"&&a!=="superadmin")return s.json({success:!1,error:"Admin access required"},{status:403});let o=await S("user:"),n=await S("customer:"),c=await S("team:");return s.json({success:!0,data:{timestamp:new Date().toISOString(),kv_storage:{users:o.length,customers:n.length,teams:c.length},database:{connected:!0},schema_version:"v2.0"}})}catch(e){return console.error("[System] Diagnostics failed:",e),s.json({success:!1,error:"Failed to get diagnostics"},{status:500})}});M();V();import{Hono as Ye}from"hono";M();var R=class{static async getAllUsers(e){try{console.log("[UserMethods.v2] Fetching all users (OPTIMIZED)...");let t=Date.now(),{data:r,error:a}=await e.auth.admin.listUsers();if(a)return console.error("[UserMethods.v2] Auth users fetch failed:",a),{success:!1,error:`Failed to fetch auth users: ${a.message}`};console.log(`[UserMethods.v2] Found ${r.users?.length||0} users in Supabase Auth`);let o=await l("superadmin:emails")||[];console.log(`[UserMethods.v2] Loaded ${o.length} superadmin emails`);let n=(r.users||[]).map(y=>y.id);console.log(`[UserMethods.v2] Batch fetching ${n.length} user objects...`);let[c,i]=await Promise.all([Promise.all(n.map(async y=>{try{let p=await l(`user:${y}`);return{userId:y,userObj:p}}catch(p){return console.warn(`[UserMethods.v2] Failed to fetch user:${y}:`,p),{userId:y,userObj:null}}})),Promise.all(n.map(async y=>{try{let p=await l(`user:${y}:customers`)||[];return{userId:y,customerIds:p}}catch(p){return console.warn(`[UserMethods.v2] Failed to fetch user:${y}:customers:`,p),{userId:y,customerIds:[]}}}))]),u=new Map(c.map(({userId:y,userObj:p})=>[y,p])),m=new Map(i.map(({userId:y,customerIds:p})=>[y,p]));console.log("[UserMethods.v2] Batch fetch complete. Processing users...");let d=new Set;i.forEach(({customerIds:y})=>{y.forEach(p=>d.add(p))}),console.log(`[UserMethods.v2] Batch fetching ${d.size} unique customers...`);let g=await Promise.all(Array.from(d).map(async y=>{try{let p=await l(`customer:${y}`);return{customerId:y,customer:p}}catch(p){return console.warn(`[UserMethods.v2] Failed to fetch customer:${y}:`,p),{customerId:y,customer:null}}})),h=new Map(g.map(({customerId:y,customer:p})=>[y,p]));console.log("[UserMethods.v2] Customer data loaded. Building user list...");let f=[];for(let y of r.users||[])try{let p=y.id,v=y.email||"",$=u.get(p),I=o.includes(v.toLowerCase()),U=v.includes("@teifi.com")||v.includes("@teifi.ca");$||($={id:p,email:v,role:I?"superadmin":U?"admin":"viewer",status:"active",createdAt:y.created_at,updatedAt:y.created_at,metadata:{name:y.user_metadata?.name||v.split("@")[0]||"User"}},await w(`user:${p}`,$),await w(`user:${p}:customers`,[])),I&&$.role!=="superadmin"&&($.role="superadmin",await w(`user:${p}`,$));let Me=m.get(p)||[],Ne=await Promise.all(Me.map(async N=>{try{let O=await l(`customer:${N}:member:${p}`);return{customerId:N,membership:O}}catch(O){return console.warn(`[UserMethods.v2] Failed to fetch membership for user:${p}, customer:${N}:`,O),{customerId:N,membership:null}}})),Be=new Map(Ne.map(({customerId:N,membership:O})=>[N,O])),he=[];for(let N of Me){let O=h.get(N);if(O){let je=Be.get(N);he.push({id:O.id,name:O.name,status:O.status,assignedAt:je?.assignedAt||je?.assigned_at})}}f.push({id:p,email:v,name:$.metadata?.name||v.split("@")[0]||"User",role:$.role,status:$.status,createdAt:y.created_at,updatedAt:$.updatedAt||$.updated_at||y.created_at,lastSignInAt:y.last_sign_in_at,customers:he,customerCount:he.length})}catch(p){console.warn(`[UserMethods.v2] Error processing user ${y.id}:`,p)}return console.log(`[UserMethods.v2] Processed ${f.length} users with customer memberships in ${Date.now()-t}ms`),{success:!0,data:{users:f,count:f.length}}}catch(t){return console.error("[UserMethods.v2] Get all users error:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error occurred"}}}static async getUserById(e,t){try{console.log(`[UserMethods.v2] Fetching user: ${e}`);let{data:r,error:a}=await t.auth.admin.getUserById(e);if(a||!r.user)return console.error("[UserMethods.v2] User not found in auth:",a),{success:!1,error:"User not found"};let o=r.user.email||"",n=await l(`user:${e}`),i=(await l("superadmin:emails")||[]).includes(o.toLowerCase()),u=o.includes("@teifi.com")||o.includes("@teifi.ca");n||(n={id:e,email:o,role:i?"superadmin":u?"admin":"viewer",status:i||u?"active":"pending",createdAt:r.user.created_at,updatedAt:r.user.created_at,metadata:{name:r.user.user_metadata?.name||o.split("@")[0]||"User"}},await w(`user:${e}`,n),await w(`user:${e}:customers`,[])),i&&(n.role="superadmin",await w(`user:${e}`,n));let g=await l(`user:${e}:customers`)||[],h=[];for(let y of g){let p=await l(`customer:${y}`);if(p){let v=await l(`customer:${y}:member:${e}`);h.push({id:p.id,name:p.name,status:p.status,assignedAt:v?.assignedAt||v?.assigned_at})}}let f={id:e,email:o,name:n.metadata?.name||o.split("@")[0]||"User",role:n.role,status:n.status,createdAt:r.user.created_at,updatedAt:n.updatedAt||n.updated_at||r.user.created_at,lastSignInAt:r.user.last_sign_in_at,customers:h,customerCount:h.length};return console.log(`[UserMethods.v2] Retrieved user with ${h.length} customers`),{success:!0,data:{user:f}}}catch(r){return console.error("[UserMethods.v2] Get user by ID error:",r),{success:!1,error:r instanceof Error?r.message:"Failed to fetch user"}}}static async createUser(e,t,r){try{if(console.log(`[UserMethods.v2] Creating user: ${e.email}`),!e.email||!e.email.trim())return{success:!1,error:"Email is required"};let a=e.email.trim().toLowerCase(),{data:o,error:n}=await t.auth.admin.createUser({email:a,password:e.password,user_metadata:{name:e.name||a.split("@")[0]},email_confirm:!0});if(n||!o.user)return console.error("[UserMethods.v2] Failed to create user in auth:",n),{success:!1,error:n?.message||"Failed to create user in authentication system"};let c=o.user.id,i=e.role||"viewer",u={id:c,email:a,role:i,status:e.status||"active",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),createdBy:r,metadata:{name:e.name||a.split("@")[0]}};await w(`user:${c}`,u);let m=e.customers||[];if(await w(`user:${c}:customers`,m),m.length>0){console.log(`[UserMethods.v2] Assigning user to ${m.length} customers`);for(let d of m){let g=await l(`customer:${d}:members`)||[];g.includes(c)||(g.push(c),await w(`customer:${d}:members`,g),await w(`customer:${d}:member:${c}`,{userId:c,customerId:d,assignedAt:new Date().toISOString(),assignedBy:r,role:i}),console.log(`  \u2192 Assigned to customer: ${d}`))}}if(i==="superadmin"){let d=await l("superadmin:emails")||[];d.includes(a)||(console.log(`  \u2192 Adding ${a} to superadmin list`),d.push(a),await w("superadmin:emails",d))}return console.log(`[UserMethods.v2] User created successfully: ${c}`),{success:!0,data:{user:{id:c,email:a,name:u.metadata.name,role:u.role,status:u.status,customers:m,customerCount:m.length}}}}catch(a){return console.error("[UserMethods.v2] Create user error:",a),{success:!1,error:a instanceof Error?a.message:"Failed to create user"}}}static async updateUser(e,t,r,a){try{console.log(`[UserMethods.v2] Updating user: ${e}`,t);let o=await l(`user:${e}`);if(!o)return{success:!1,error:"User not found"};let n={};t.name&&(o.metadata=o.metadata||{},o.metadata.name=t.name.trim(),n.user_metadata={name:t.name.trim()});let c=o.role;if(t.role&&(console.log(`  \u2192 Role change: ${o.role} \u2192 ${t.role}`),o.role=t.role,n.user_metadata=n.user_metadata||{},n.user_metadata.role=t.role),t.status&&(console.log(`  \u2192 Status change: ${o.status} \u2192 ${t.status}`),o.status=t.status),o.updatedAt=new Date().toISOString(),o.updatedBy=r,await w(`user:${e}`,o),t.role&&c!==t.role){let i=await l("superadmin:emails")||[],u=o.email?.toLowerCase().trim();if(t.role==="superadmin"&&!i.includes(u))console.log(`  \u2192 Adding ${u} to superadmin list`),i.push(u),await w("superadmin:emails",i);else if(t.role!=="superadmin"&&c==="superadmin"&&i.includes(u)){console.log(`  \u2192 Removing ${u} from superadmin list`);let m=i.filter(d=>d!==u);await w("superadmin:emails",m)}}if(a&&Object.keys(n).length>0){console.log("  \u2192 Updating Supabase Auth metadata:",n);let{error:i}=await a.auth.admin.updateUserById(e,n);i?console.error("[UserMethods.v2] Failed to update Supabase Auth:",i):console.log("[UserMethods.v2] Supabase Auth metadata updated")}return console.log(`[UserMethods.v2] User updated: ${e}`),{success:!0,data:{message:"User updated successfully",user:o}}}catch(o){return console.error("[UserMethods.v2] Update user error:",o),{success:!1,error:o instanceof Error?o.message:"Failed to update user"}}}static async deleteUser(e,t){try{console.log(`\uFE0F [UserMethods.v2] Deleting user: ${e}`);let r=await l(`user:${e}:customers`)||[];for(let c of r){let u=(await l(`customer:${c}:members`)||[]).filter(m=>m!==e);await w(`customer:${c}:members`,u),await T(`customer:${c}:member:${e}`),console.log(` Removed from customer: ${c}`)}let a=await l(`user:${e}`),o=a?.email?.toLowerCase().trim(),{error:n}=await t.auth.admin.deleteUser(e);if(n&&console.warn("\uFE0F [UserMethods.v2] Failed to delete from auth (may already be deleted):",n),await T(`user:${e}`),await T(`user:${e}:customers`),a?.role==="superadmin"&&o){let c=await l("superadmin:emails")||[];if(c.includes(o)){console.log(`  \u2192 Removing ${o} from superadmin list`);let i=c.filter(u=>u!==o);await w("superadmin:emails",i)}}return console.log(`[UserMethods.v2] User ${e} deleted successfully`),{success:!0,data:{message:"User deleted successfully",removed_from_customers:r.length}}}catch(r){return console.error("[UserMethods.v2] Delete user error:",r),{success:!1,error:r instanceof Error?r.message:"Failed to delete user"}}}static async assignUserToCustomer(e,t,r){try{if(console.log(`[UserMethods.v2] Assigning user ${e} to customer ${t}`),!await l(`user:${e}`))return{success:!1,error:"User not found"};if(!await l(`customer:${t}`))return{success:!1,error:"Customer not found"};let n=await l(`user:${e}:customers`)||[];n.includes(t)||(n.push(t),await w(`user:${e}:customers`,n));let c=await l(`customer:${t}:members`)||[];c.includes(e)||(c.push(e),await w(`customer:${t}:members`,c));let i={userId:e,customerId:t,assignedAt:new Date().toISOString(),assignedBy:r};return await w(`customer:${t}:member:${e}`,i),console.log("[UserMethods.v2] User assigned to customer successfully"),{success:!0,data:{message:"User assigned to customer successfully",membership:i}}}catch(a){return console.error("[UserMethods.v2] Assign user to customer error:",a),{success:!1,error:a instanceof Error?a.message:"Failed to assign user to customer"}}}static async removeUserFromCustomer(e,t,r){try{console.log(`[UserMethods.v2] Removing user ${e} from customer ${t}`);let a=await l(`customer:${t}:teams`)||[],o=0;console.log(` Cleaning up ${a.length} potential team memberships`);for(let m of a){let d=`customer:${t}:team:${m}:members`,g=await l(d)||[];if(g.includes(e)){let h=g.filter(f=>f!==e);await w(d,h),o++,console.log(`   Removed from team: ${m}`)}}console.log(` Cleaned up ${o} team memberships`);let c=(await l(`user:${e}:customers`)||[]).filter(m=>m!==t);await w(`user:${e}:customers`,c);let u=(await l(`customer:${t}:members`)||[]).filter(m=>m!==e);return await w(`customer:${t}:members`,u),await T(`customer:${t}:member:${e}`),console.log(`[UserMethods.v2] User removed from customer successfully (${o} teams cleaned)`),{success:!0,data:{message:"User removed from customer successfully",teamsCleanedUp:o}}}catch(a){return console.error("[UserMethods.v2] Remove user from customer error:",a),{success:!1,error:a instanceof Error?a.message:"Failed to remove user from customer"}}}static async syncCustomerAssignments(e,t,r){try{console.log(`[UserMethods.v2] Syncing customer assignments for user: ${e}`),console.log("  New customer IDs:",t);let a=await l(`user:${e}:customers`)||[];console.log("  Current customer IDs:",a);let o=t.filter(m=>!a.includes(m)),n=a.filter(m=>!t.includes(m));console.log(" Adding customers:",o),console.log(" Removing customers:",n);let c=0,i=0,u=0;for(let m of o){let d=await this.assignUserToCustomer(e,m,r);d.success?c++:console.warn(`\uFE0F Failed to add customer ${m}:`,d.error)}for(let m of n){let d=await l(`customer:${m}:teams`)||[];console.log(` Cleaning up ${d.length} team memberships for customer ${m}`);for(let h of d){let f=`customer:${m}:team:${h}:members`,y=await l(f)||[];if(y.includes(e)){let p=y.filter(v=>v!==e);await w(f,p),u++,console.log(`   Removed from team: ${h}`)}}let g=await this.removeUserFromCustomer(e,m,r);g.success?i++:console.warn(`\uFE0F Failed to remove customer ${m}:`,g.error)}return console.log("[UserMethods.v2] Customer sync complete:"),console.log(` Added: ${c} customers`),console.log(` Removed: ${i} customers`),console.log(` Cleaned up: ${u} team memberships`),{success:!0,data:{added:c,removed:i,teamsCleanedUp:u,finalCustomers:t}}}catch(a){return console.error("[UserMethods.v2] Sync customer assignments error:",a),{success:!1,error:a instanceof Error?a.message:"Failed to sync customer assignments"}}}static async getUserCustomers(e){try{console.log(`[UserMethods.v2] Getting customers for user: ${e}`);let t=await l(`user:${e}:customers`)||[],r=[];for(let a of t){let o=await l(`customer:${a}`);if(o){let n=await l(`customer:${a}:member:${e}`);r.push({...o,membership:n})}}return console.log(`[UserMethods.v2] Found ${r.length} customers for user`),{success:!0,data:{customers:r,count:r.length}}}catch(t){return console.error("[UserMethods.v2] Get user customers error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to get user customers"}}}};M();var Ae=class{async getAllCustomers(){try{console.log("[CustomerMethodsV2] Fetching all customers...");let e=await S("customer:");console.log(`[CustomerMethodsV2] Found ${e.length} customer keys`);let t=[],r=new Set;for(let a of e)try{let o=a.replace("customer:","");if(o.includes(":")||r.has(o))continue;r.add(o);let n=await l(a);if(!n||!n.id){console.warn(`\uFE0F [CustomerMethodsV2] Invalid customer at ${a}`);continue}let c=await l(`customer:${o}:members`)||[],i=await l(`customer:${o}:teams`)||[];t.push({id:n.id,name:n.name,description:n.description||"",contactEmail:n.contactEmail||n.contact_email,google_domain:n.google_domain,project:n.project,epic:n.epic,environment:n.environment||"UAT",status:n.status||"active",createdAt:n.createdAt||n.created_at||new Date().toISOString(),updatedAt:n.updatedAt||n.updated_at||new Date().toISOString(),usersCount:c.length,teamsCount:i.length})}catch(o){console.warn(`\uFE0F [CustomerMethodsV2] Error processing customer ${a}:`,o)}return console.log(`[CustomerMethodsV2] Processed ${t.length} customers`),{success:!0,data:{customers:t,count:t.length}}}catch(e){return console.error("[CustomerMethodsV2] Get all customers error:",e),{success:!1,error:e instanceof Error?e.message:"Failed to fetch customers"}}}async getCustomerById(e){try{console.log(`[CustomerMethodsV2] Fetching customer: ${e}`);let t=await l(`customer:${e}`);if(!t)return{success:!1,error:"Customer not found"};let r=await l(`customer:${e}:members`)||[],a=[];for(let c of r){let i=await l(`customer:${e}:member:${c}`),u=await l(`user:${c}`);u&&i&&a.push({userId:c,email:u.email,name:u.metadata?.name||u.email.split("@")[0],role:u.role,status:u.status,assignedAt:i.assignedAt||i.assigned_at,assignedBy:i.assignedBy||i.assigned_by})}let o=await l(`customer:${e}:teams`)||[],n=[];for(let c of o){let i=await l(`linear_teams:${c}`);i&&n.push({id:c,name:i.name,key:i.key,description:i.description})}return{success:!0,data:{customer:{...t,members:a,teams:n,usersCount:a.length,teamsCount:n.length}}}}catch(t){return console.error("[CustomerMethodsV2] Get customer error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to fetch customer"}}}async createCustomer(e,t){try{if(console.log(`[CustomerMethodsV2] Creating customer: ${e.name}`),!e.name||!e.name.trim())return{success:!1,error:"Customer name is required"};let r=crypto.randomUUID(),a={id:r,name:e.name.trim(),description:e.description?.trim()||"",contactEmail:e.contactEmail?.trim()||null,google_domain:e.google_domain?.trim()||null,project:e.project?.trim()||null,epic:e.epic?.trim()||null,environment:e.environment||"UAT",status:e.status||"active",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),createdBy:t};return await w(`customer:${r}`,a),await w(`customer:${r}:members`,[]),await w(`customer:${r}:teams`,[]),console.log(`[CustomerMethodsV2] Customer created: ${r}`),{success:!0,data:{customer:{...a,usersCount:0,teamsCount:0}}}}catch(r){return console.error("[CustomerMethodsV2] Create customer error:",r),{success:!1,error:r instanceof Error?r.message:"Failed to create customer"}}}async updateCustomer(e,t,r){try{console.log(`[CustomerMethodsV2] Updating customer: ${e}`);let a=await l(`customer:${e}`);if(!a)return{success:!1,error:"Customer not found"};let o={...a,...Object.fromEntries(Object.entries(t).filter(([n,c])=>c!==void 0)),updatedAt:new Date().toISOString(),updatedBy:r};return await w(`customer:${e}`,o),console.log(`[CustomerMethodsV2] Customer updated: ${e}`),{success:!0,data:{customer:o,message:"Customer updated successfully"}}}catch(a){return console.error("[CustomerMethodsV2] Update customer error:",a),{success:!1,error:a instanceof Error?a.message:"Failed to update customer"}}}async deleteCustomer(e){try{console.log(`[CustomerMethodsV2] Deleting customer: ${e}`);let t=await l(`customer:${e}:members`)||[];for(let r of t){let o=(await l(`user:${r}:customers`)||[]).filter(n=>n!==e);await w(`user:${r}:customers`,o),await T(`customer:${e}:member:${r}`),console.log(` Removed from user: ${r}`)}return await T(`customer:${e}`),await T(`customer:${e}:members`),await T(`customer:${e}:teams`),console.log(`[CustomerMethodsV2] Customer deleted: ${e}`),{success:!0,data:{message:"Customer deleted successfully",removedMembers:t.length}}}catch(t){return console.error("[CustomerMethodsV2] Delete customer error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to delete customer"}}}async getCustomerMembers(e){try{if(console.log(`[CustomerMethodsV2] Getting members for customer: ${e}`),!await l(`customer:${e}`))return{success:!1,error:"Customer not found"};let r=await l(`customer:${e}:members`)||[],a=[];for(let o of r){let n=await l(`user:${o}`),c=await l(`customer:${e}:member:${o}`);n&&a.push({userId:o,email:n.email,name:n.metadata?.name||n.email.split("@")[0],role:n.role,status:n.status,assignedAt:c?.assignedAt||n.createdAt,assignedBy:c?.assignedBy})}return console.log(`[CustomerMethodsV2] Found ${a.length} members`),{success:!0,data:{members:a,count:a.length}}}catch(t){return console.error("[CustomerMethodsV2] Get customer members error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to fetch customer members"}}}async getCustomerTeams(e){try{if(console.log(`[CustomerMethodsV2] Getting teams for customer: ${e}`),!await l(`customer:${e}`))return{success:!1,error:"Customer not found"};let r=await l(`customer:${e}:teams`)||[];console.log("[CustomerMethodsV2] Customer team IDs:",r);let a=await l("linear_teams:all");console.log("[CustomerMethodsV2] Linear cache loaded:",a?"YES":"NO");let o=[];if(a&&a.teams&&Array.isArray(a.teams)){console.log(`[CustomerMethodsV2] Found ${a.teams.length} teams in Linear cache`);let n=new Map,c=i=>{for(let u of i)n.set(u.id,u),u.children&&u.children.length>0&&c(u.children)};c(a.teams),console.log(`[CustomerMethodsV2] Built team map with ${n.size} entries`);for(let i of r){let u=n.get(i);u?(console.log(`[CustomerMethodsV2] Mapped team ${i}: ${u.name} (${u.key})`),o.push({id:u.id,name:u.name,key:u.key,description:u.description||`${u.name} team`,state:"active",color:u.color,icon:u.icon,parentId:u.parent?.id,parentName:u.parent?.name,parentKey:u.parent?.key})):(console.warn(`\uFE0F [CustomerMethodsV2] Team ${i} not found in Linear cache - using fallback`),o.push({id:i,name:`Team ${i.substring(0,8)}`,key:i.substring(0,8),description:"Team not synced from Linear. Please sync teams.",state:"unknown"}))}}else{console.warn("\uFE0F [CustomerMethodsV2] No Linear cache found - using fallback names");for(let n of r)o.push({id:n,name:`Team ${n.substring(0,8)}`,key:n.substring(0,8),description:"Linear cache not available. Please sync teams in Admin \u2192 Teams \u2192 Linear Sync.",state:"unknown"})}return console.log(`[CustomerMethodsV2] Returning ${o.length} teams:`,o.map(n=>({id:n.id,name:n.name,key:n.key}))),{success:!0,data:{teams:o,count:o.length}}}catch(t){return console.error("[CustomerMethodsV2] Get customer teams error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to fetch customer teams"}}}async assignTeamToCustomer(e,t,r){try{if(console.log(`[CustomerMethodsV2] Assigning team ${t} to customer ${e}`),!await l(`customer:${e}`))return{success:!1,error:"Customer not found"};let o=!1,n=t,c=await l(`linear_teams:${t}`);if(typeof c=="string")try{c=JSON.parse(c)}catch{console.warn(`\uFE0F [CustomerMethodsV2] Failed to parse team ${t} from cache`),c=null}if(c?.id===t)o=!0,n=c.name||t,console.log(`[CustomerMethodsV2] Team found in individual cache: ${n}`);else{let m=await l("linear_teams:all");if(m&&m.teams&&Array.isArray(m.teams)){let d=h=>{for(let f of h){if(f.id===t)return f;if(f.children&&f.children.length>0){let y=d(f.children);if(y)return y}}return null},g=d(m.teams);g&&(o=!0,n=g.name||t,console.log(`[CustomerMethodsV2] Team found in hierarchy cache: ${n}`),await w(`linear_teams:${t}`,g))}if(!o)try{console.log("[CustomerMethodsV2] Team not in cache, fetching from Linear API...");let{LinearTeamService:d}=await Promise.resolve().then(()=>(Z(),ne)),h=await new d().getTeamById(t);h?.id===t&&(o=!0,n=h.name||t,console.log(`[CustomerMethodsV2] Team found via Linear API: ${n}`),await w(`linear_teams:${t}`,h))}catch(d){console.error("[CustomerMethodsV2] Failed to fetch team from Linear API:",d)}}if(!o)return console.warn(`[CustomerMethodsV2] Team ${t} not found in any source (cache or API)`),{success:!1,error:"Team not found. Please sync Linear teams in Admin > Teams > Linear Sync."};let i=await l(`team:${t}:customer`);if(i&&i!==e){let d=(await l(`customer:${i}`))?.name||"Unknown Customer";return console.warn(`[CustomerMethodsV2] Team ${n} (${t}) is already assigned to customer ${d}`),{success:!1,error:`Team "${n}" is already assigned to customer "${d}". A team can only belong to one customer at a time. Please unassign it from the other customer first.`}}let u=await l(`customer:${e}:teams`)||[];if(u.includes(t))console.log(`[CustomerMethodsV2] Team ${n} (${t}) already assigned to customer`);else{u.push(t),console.log("[CustomerMethodsV2] Writing team assignment to KV store:",{customerTeamsKey:`customer:${e}:teams`,teamOwnershipKey:`team:${t}:customer`,customerId:e,linearTeamId:t,teamName:n});let m=await w(`customer:${e}:teams`,u);console.log("[CustomerMethodsV2] Customer teams list write result:",m!==void 0?"SUCCESS":"FAILED");let d=await w(`team:${t}:customer`,e);console.log("[CustomerMethodsV2] Team ownership mapping write result:",d!==void 0?"SUCCESS":"FAILED");let g=await l(`customer:${e}:teams`),h=await l(`team:${t}:customer`);if(console.log("[CustomerMethodsV2] VERIFICATION - Data written successfully:",{customerTeamsVerified:Array.isArray(g)&&g.includes(t),ownershipVerified:h===e,verifyCustomerTeams:g,verifyOwnership:h}),!h||h!==e)throw new Error(`CRITICAL: Team ownership mapping write FAILED - Expected "${e}", got "${h}"`);console.log(`[CustomerMethodsV2] Team ${n} (${t}) assigned to customer - VERIFIED`)}return await T("team_ownership_map:all"),console.log("[CustomerMethodsV2] Invalidated team ownership cache"),{success:!0,data:{message:`Team "${n}" assigned successfully`,teamId:t,teamName:n}}}catch(a){return console.error("[CustomerMethodsV2] Assign team to customer error:",a),{success:!1,error:a instanceof Error?a.message:"Failed to assign team to customer"}}}async removeTeamFromCustomer(e,t,r){try{console.log(`[CustomerMethodsV2] Removing team ${t} from customer ${e}`);let a=`customer:${e}:team:${t}:members`,o=await l(a)||[];o.length>0&&(console.log(` Cleaning up ${o.length} team member assignments`),await T(a));let c=(await l(`customer:${e}:teams`)||[]).filter(m=>m!==t);console.log("[CustomerMethodsV2] Removing team ownership from KV store:",{customerTeamsKey:`customer:${e}:teams`,teamOwnershipKey:`team:${t}:customer`,customerId:e,linearTeamId:t}),await w(`customer:${e}:teams`,c);let i=await T(`team:${t}:customer`);console.log("[CustomerMethodsV2] Team ownership deletion result:",i!==void 0?"SUCCESS":"FAILED");let u=await l(`team:${t}:customer`);return console.log("[CustomerMethodsV2] VERIFICATION - Ownership deleted:",{ownershipDeleted:u==null,verifyOwnership:u}),console.log(`[CustomerMethodsV2] Team removed from customer (cleaned ${o.length} member assignments) - VERIFIED`),await T("team_ownership_map:all"),console.log("[CustomerMethodsV2] Invalidated team ownership cache"),{success:!0,data:{message:"Team removed from customer successfully",cleanedMembers:o.length}}}catch(a){return console.error("[CustomerMethodsV2] Remove team from customer error:",a),{success:!1,error:a instanceof Error?a.message:"Failed to remove team from customer"}}}async getCustomerTeamMembers(e,t){try{console.log(`[CustomerMethodsV2] Getting team members for customer ${e}, team ${t}`);let r=await l(`customer:${e}:team:${t}:members`)||[],a=[];for(let o of r){let n=await l(`user:${o}`);n&&a.push({userId:o,email:n.email,name:n.metadata?.name||n.email.split("@")[0],role:n.role||"viewer"})}return console.log(`[CustomerMethodsV2] Loaded ${a.length} team members`),{success:!0,data:{members:a,count:a.length}}}catch(r){return console.error("[CustomerMethodsV2] Get customer team members error:",r),{success:!1,error:r instanceof Error?r.message:"Failed to get team members"}}}async addMemberToCustomerTeam(e,t,r,a){try{if(console.log(`[CustomerMethodsV2] Adding user ${r} to customer ${e}, team ${t}`),!await l(`customer:${e}`))return{success:!1,error:"Customer not found"};if(!(await l(`customer:${e}:teams`)||[]).includes(t))return{success:!1,error:"Team not assigned to customer"};if(!(await l(`customer:${e}:members`)||[]).includes(r))return{success:!1,error:"User not a member of this customer. Please add user to customer first."};if(!await l(`customer:${e}:member:${r}`))return console.warn(`\uFE0F [CustomerMethodsV2] Data inconsistency: User ${r} in members list but no membership record`),{success:!1,error:"User membership record missing. Please re-assign user to customer to fix."};let u=await l(`customer:${e}:team:${t}:members`)||[];return u.includes(r)||(u.push(r),await w(`customer:${e}:team:${t}:members`,u)),console.log("[CustomerMethodsV2] User added to team"),{success:!0,data:{message:"User added to team successfully"}}}catch(o){return console.error("[CustomerMethodsV2] Add member to team error:",o),{success:!1,error:o instanceof Error?o.message:"Failed to add member to team"}}}async removeMemberFromCustomerTeam(e,t,r,a){try{console.log(`[CustomerMethodsV2] Removing user ${r} from customer ${e}, team ${t}`);let n=(await l(`customer:${e}:team:${t}:members`)||[]).filter(c=>c!==r);return await w(`customer:${e}:team:${t}:members`,n),console.log("[CustomerMethodsV2] User removed from team"),{success:!0,data:{message:"User removed from team successfully"}}}catch(o){return console.error("[CustomerMethodsV2] Remove member from team error:",o),{success:!1,error:o instanceof Error?o.message:"Failed to remove member from team"}}}},q=new Ae;M();var _e=class{async getDashboardStats(e){try{console.log("[AdminHelpers] Fetching dashboard stats...");let{data:t}=await e.auth.admin.listUsers(),r=t?.users?.length||0,o=(await S("customer:")).filter(d=>!d.includes(":")).length,c=(await S("linear_teams:")).length,u=(await S("admin_activity:")).slice(0,10).length,m={users:r,customers:o,teams:c,recentActivity:u,timestamp:new Date().toISOString()};return console.log("[AdminHelpers] Dashboard stats:",m),{success:!0,data:{stats:m}}}catch(t){return console.error("[AdminHelpers] Get dashboard stats error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to fetch dashboard stats"}}}async getActivityLogs(e={}){try{console.log("[AdminHelpers] Fetching activity logs...");let{limit:t=50,offset:r=0}=e,a=await S("admin_activity:"),n=a.sort().reverse().slice(r,r+t),c=[];for(let i of n){let u=await l(i);u&&c.push(u)}return console.log(`[AdminHelpers] Retrieved ${c.length} activity logs`),{success:!0,data:{logs:c,total:a.length,limit:t,offset:r}}}catch(t){return console.error("[AdminHelpers] Get activity logs error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to fetch activity logs"}}}async getRoleDefinitions(){try{console.log("[AdminHelpers] Fetching role definitions...");let e={superadmin:{name:"Super Administrator",description:"Complete system access, manage all customers and global settings",permissions:["view_issues","create_issues","edit_issues","delete_issues","view_project_status","manage_users","manage_permissions","access_linear_test","view_analytics","export_data","manage_system","manage_customers","manage_teams","view_admin","access_all_customers","manage_security"]},admin:{name:"Administrator",description:"Manage users and customers within assigned scope",permissions:["view_issues","create_issues","edit_issues","delete_issues","view_project_status","manage_users","manage_permissions","access_linear_test","view_analytics","export_data","manage_customers","manage_teams","view_admin"]},client_manager:{name:"Client Manager",description:"Manage client team and oversee project issues",permissions:["view_issues","create_issues","edit_issues","delete_issues","view_project_status","view_analytics","export_data","manage_teams"]},client_user:{name:"Client User",description:"Standard client access for testing and issue reporting",permissions:["view_issues","create_issues","edit_issues","view_project_status"]},tester:{name:"Tester",description:"Specialized testing role with enhanced bug reporting capabilities",permissions:["view_issues","create_issues","edit_issues","view_project_status","access_linear_test"]},viewer:{name:"Viewer",description:"Read-only access to dashboard and project status",permissions:["view_issues","view_project_status"]}};return console.log("[AdminHelpers] Role definitions retrieved"),{success:!0,data:{roles:e}}}catch(e){return console.error("[AdminHelpers] Get role definitions error:",e),{success:!1,error:e instanceof Error?e.message:"Failed to fetch role definitions"}}}async getMemberPermissions(e,t){try{if(console.log(`[AdminHelpers] Getting permissions for user ${t} in customer ${e}`),!(await l(`customer:${e}:members`)||[]).includes(t))return{success:!1,error:"User is not a member of this customer"};let a=await l(`user:${t}`);if(!a)return{success:!1,error:"User not found"};let o=await l(`customer:${e}:member:${t}`),i=((await this.getRoleDefinitions()).data?.roles||{})[a.role]?.permissions||[];return{success:!0,data:{user_id:t,customer_id:e,role:a.role,permissions:i,assigned_at:o?.assigned_at,assigned_by:o?.assigned_by}}}catch(r){return console.error("[AdminHelpers] Get member permissions error:",r),{success:!1,error:r instanceof Error?r.message:"Failed to get member permissions"}}}async updateMemberPermissions(e,t,r,a){try{if(console.log(`[AdminHelpers] Updating role for user ${t} in customer ${e} to ${r}`),!(await l(`customer:${e}:members`)||[]).includes(t))return{success:!1,error:"User is not a member of this customer"};let n=await l(`user:${t}`);if(!n)return{success:!1,error:"User not found"};n.role=r,n.updated_at=new Date().toISOString(),n.updated_by=a,await w(`user:${t}`,n);let c=await l(`customer:${e}:member:${t}`)||{};return c.role_updated_at=new Date().toISOString(),c.role_updated_by=a,await w(`customer:${e}:member:${t}`,c),console.log("[AdminHelpers] Role updated successfully"),{success:!0,data:{message:"Member permissions updated successfully",user_id:t,customer_id:e,new_role:r}}}catch(o){return console.error("[AdminHelpers] Update member permissions error:",o),{success:!1,error:o instanceof Error?o.message:"Failed to update member permissions"}}}async getOrganizationPermissionMatrix(e){try{console.log(`[AdminHelpers] Getting permission matrix for customer ${e}`);let t=await l(`customer:${e}`);if(!t)return{success:!1,error:"Customer not found"};let r=await l(`customer:${e}:members`)||[],o=(await this.getRoleDefinitions()).data?.roles||{},n=[];for(let c of r){let i=await l(`user:${c}`),u=await l(`customer:${e}:member:${c}`);if(i){let m=o[i.role]?.permissions||[];n.push({user_id:c,email:i.email,name:i.metadata?.name||i.email.split("@")[0],role:i.role,permissions:m,assigned_at:u?.assigned_at,assigned_by:u?.assigned_by})}}return console.log(`[AdminHelpers] Permission matrix retrieved for ${n.length} members`),{success:!0,data:{customer_id:e,customer_name:t.name,members:n,roles:o}}}catch(t){return console.error("[AdminHelpers] Get permission matrix error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to get permission matrix"}}}async checkUserPermission(e,t,r){try{let a=await l(`user:${e}`);if(!a)return{success:!1,error:"User not found"};let n=(await this.getRoleDefinitions()).data?.roles||{};if(a.role==="superadmin")return{success:!0,data:{hasPermission:!0,reason:"superadmin_role"}};let i=(n[a.role]?.permissions||[]).includes(t);return{success:!0,data:{hasPermission:i,role:a.role,permission:t,reason:i?"role_permission":"no_permission"}}}catch(a){return console.error("[AdminHelpers] Check user permission error:",a),{success:!1,error:a instanceof Error?a.message:"Failed to check user permission"}}}async getMyRoleInCustomer(e,t,r){try{console.log(`[AdminHelpers] Getting role for user ${t} in customer ${r}`);let{isSuperAdminUser:a}=await Promise.resolve().then(()=>(V(),oe));if(await a(t))return{success:!0,data:{role:"superadmin",isMember:!0,canManage:!0}};if(!(await l(`customer:${r}:members`)||[]).includes(e))return{success:!0,data:{role:null,isMember:!1,canManage:!1}};let i=await l(`user:${e}`);if(!i)return{success:!1,error:"User not found"};let u=i.role==="superadmin"||i.role==="admin"||i.role==="client_manager";return{success:!0,data:{role:i.role,isMember:!0,canManage:u}}}catch(a){return console.error("[AdminHelpers] Get my role in customer error:",a),{success:!1,error:a instanceof Error?a.message:"Failed to get role in customer"}}}async getTeamMembersWithPermissions(e,t){try{if(console.log(`[AdminHelpers] Getting team members with permissions for team ${t} in customer ${e}`),!await l(`customer:${e}`))return{success:!1,error:"Customer not found"};if(!await l(`linear_teams:${t}`))return{success:!1,error:"Team not found"};let o=await l(`team:${t}:members`)||[],c=(await this.getRoleDefinitions()).data?.roles||{},i=[];for(let u of o){let m=await l(`user:${u}`),d=await l(`team:${t}:member:${u}`);if(m){let g=c[m.role]?.permissions||[];i.push({user_id:u,email:m.email,name:m.metadata?.name||m.email.split("@")[0],role:m.role,status:m.status,permissions:g,assigned_at:d?.assigned_at,assigned_by:d?.assigned_by})}}return console.log(`[AdminHelpers] Found ${i.length} team members with permissions`),{success:!0,data:{members:i,count:i.length}}}catch(r){return console.error("[AdminHelpers] Get team members with permissions error:",r),{success:!1,error:r instanceof Error?r.message:"Failed to get team members with permissions"}}}async addMemberToTeam(e,t,r,a){try{if(console.log(`[AdminHelpers] Adding user ${r} to team ${t} in customer ${e}`),!(await l(`customer:${e}:members`)||[]).includes(r))return{success:!1,error:"User must be a member of the customer first"};if(!(await l(`customer:${e}:teams`)||[]).includes(t))return{success:!1,error:"Team must be assigned to customer first"};let c=await l(`team:${t}:members`)||[];if(c.includes(r))return{success:!1,error:"User is already a member of this team"};c.push(r),await w(`team:${t}:members`,c);let i={user_id:r,team_id:t,customer_id:e,assigned_at:new Date().toISOString(),assigned_by:a};await w(`team:${t}:member:${r}`,i);let u=await l(`user:${r}:teams`)||[];return u.includes(t)||(u.push(t),await w(`user:${r}:teams`,u)),console.log("[AdminHelpers] User added to team successfully"),{success:!0,data:{message:"Member added to team successfully",membership:i}}}catch(o){return console.error("[AdminHelpers] Add member to team error:",o),{success:!1,error:o instanceof Error?o.message:"Failed to add member to team"}}}async removeMemberFromTeam(e,t,r,a){try{console.log(`[AdminHelpers] Removing user ${r} from team ${t} in customer ${e}`);let n=(await l(`team:${t}:members`)||[]).filter(u=>u!==r);await w(`team:${t}:members`,n),await T(`team:${t}:member:${r}`);let i=(await l(`user:${r}:teams`)||[]).filter(u=>u!==t);return await w(`user:${r}:teams`,i),console.log("[AdminHelpers] User removed from team successfully"),{success:!0,data:{message:"Member removed from team successfully"}}}catch(o){return console.error("[AdminHelpers] Remove member from team error:",o),{success:!1,error:o instanceof Error?o.message:"Failed to remove member from team"}}}},ie=new _e;M();var Ee=class{CACHE_TTL_MS=30*1e3;ENRICHED_CACHE_KEY="linear_teams:enriched";OWNERSHIP_CACHE_KEY="team_ownership_map:all";OWNERSHIP_CACHE_TTL_MS=300*1e3;async getAvailableTeamsForCustomer(e){try{console.log(`[TeamMethodsV2] Getting available teams for customer: ${e}`);let t=Date.now(),r=await this.getAllTeams(!1);if(!r.success||!r.data?.teams)return{success:!1,error:"Failed to fetch teams from cache"};let a=r.data.teams;console.log(`[TeamMethodsV2] Loaded ${a.length} teams from cache`);let o=await l(`customer:${e}:teams`)||[],n=new Map,c=!1,i=await l(this.OWNERSHIP_CACHE_KEY);if(i&&typeof i=="object"){let g=Date.now()-(i.timestamp||0);g<this.OWNERSHIP_CACHE_TTL_MS?(console.log(`[TeamMethodsV2] Using cached ownership mappings (age: ${g}ms)`),n=new Map(i.data||[]),c=!0):(console.log(`[TeamMethodsV2] Ownership cache expired (age: ${g}ms > ${this.OWNERSHIP_CACHE_TTL_MS}ms)`),await T(this.OWNERSHIP_CACHE_KEY))}if(!c){console.log("[TeamMethodsV2] Cache miss - fetching ownership mappings from database");try{let g=await S("team:");console.log(`[TeamMethodsV2] Found ${g.length} team-related keys from KV`);let h=g.filter(f=>f.endsWith(":customer"));console.log(`[TeamMethodsV2] Filtered to ${h.length} ownership records`);for(let f of h){let y=f.split(":");if(y.length===3&&y[0]==="team"&&y[2]==="customer"){let p=y[1],v=await l(f);v&&typeof v=="string"?n.set(p,v):console.warn(`[TeamMethodsV2] Invalid ownership record: key=${f}, value=${typeof v}`)}}console.log(`[TeamMethodsV2] Built ownership map with ${n.size} assigned teams from ${h.length} KV records`)}catch(g){console.error("[TeamMethodsV2] Error fetching from KV store:",g),console.log("[TeamMethodsV2] Falling back to showing all teams as available")}await w(this.OWNERSHIP_CACHE_KEY,{data:Array.from(n.entries()),timestamp:Date.now()}),console.log(`[TeamMethodsV2] Cached ownership mappings for ${this.OWNERSHIP_CACHE_TTL_MS/1e3}s`)}if(n.size>0){let g=Array.from(n.entries()).slice(0,3);console.log("[TeamMethodsV2] Sample ownership mappings:",g.map(([h,f])=>`${h} \u2192 ${f}`).join(", "))}else console.log("[TeamMethodsV2] WARNING: No ownership mappings found - all teams will appear available");console.log(`[TeamMethodsV2] Filtering teams for customer: ${e}`);let u=[],m=[];for(let g of a){let h=n.get(g.id);!h||h===e?u.push({id:g.id,name:g.name,key:g.key,description:g.description,state:g.state,color:g.color,isAssignedToThisCustomer:o.includes(g.id)}):m.push({teamId:g.id,teamName:g.name,assignedTo:h})}m.length>0?console.log(`[TeamMethodsV2] Excluded ${m.length} teams already assigned to other customers:`,m.slice(0,3).map(g=>`${g.teamName} \u2192 ${g.assignedTo}`).join(", ")):console.log("[TeamMethodsV2] No teams excluded - all teams are available");let d=Date.now()-t;return console.log(`[TeamMethodsV2] Found ${u.length} available teams (out of ${a.length} total) in ${d}ms - OPTIMIZED`),{success:!0,data:{teams:u,count:u.length,totalTeams:a.length}}}catch(t){return console.error("[TeamMethodsV2] Get available teams error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to get available teams"}}}async getAllTeams(e=!1){try{if(console.log("[TeamMethodsV2] Fetching all Linear teams (includeHierarchy:",e,")"),e){let p=await l(this.ENRICHED_CACHE_KEY);if(p&&typeof p=="object"){let v=Date.now()-(p.timestamp||0);if(v<this.CACHE_TTL_MS)return console.log(`[TeamMethodsV2] Using enriched KV cache (age: ${v}ms)`),{success:!0,data:{...p.data,cached:!0,cacheAge:v,source:"enriched-cache"}};console.log(`[TeamMethodsV2] Enriched cache expired (age: ${v}ms > ${this.CACHE_TTL_MS}ms)`),await T(this.ENRICHED_CACHE_KEY)}}if(e){console.log("[TeamMethodsV2] Checking KV for cached hierarchy...");let p=await l("linear_teams:all");if(typeof p=="string"){console.log("[TeamMethodsV2] Parsing JSON string from KV...");try{p=JSON.parse(p)}catch(v){console.error("[TeamMethodsV2] Failed to parse cached hierarchy:",v),p=null}}if(console.log("[TeamMethodsV2] Cache check:",{exists:!!p,type:typeof p,hasTeams:!!p?.teams,teamsCount:p?.teams?.length||0,hasHierarchy:!!p?.hierarchy,hierarchyCount:p?.hierarchy?.length||0}),p&&(p.teams||p.hierarchy)){console.log("[TeamMethodsV2] Using KV cached team data");let v=p.hierarchy?await this.enrichTeamHierarchy(p.hierarchy):[],$={teams:p.teams||[],hierarchy:v,rootTeamsCount:p.rootTeamsCount||0,totalTeamsCount:p.totalTeamsCount||0,count:p.count||p.teams?.length||0,syncedAt:p.syncedAt,source:"kv-cache"};return await w(this.ENRICHED_CACHE_KEY,{data:$,timestamp:Date.now()}),console.log("[TeamMethodsV2] Cached enriched hierarchy for 30s"),{success:!0,data:$}}console.warn("[TeamMethodsV2] No cached hierarchy found, falling back to individual fetch")}console.log("[TeamMethodsV2] Fallback to individual team fetching (optimized)...");let t=Date.now(),r=await S("linear_teams:");console.log(`[TeamMethodsV2] Found ${r.length} team keys`);let a=[],o=new Set,n=[];for(let p of r)try{if(p==="linear_teams:all")continue;let v=p.replace("linear_teams:","");if(o.has(v))continue;o.add(v),n.push(v);let $=await l(p);if(typeof $=="string")try{$=JSON.parse($)}catch(I){console.warn(`\uFE0F [TeamMethodsV2] Failed to parse team at ${p}:`,I);continue}if(!$||!$.id){console.warn(`\uFE0F [TeamMethodsV2] Invalid team at ${p}`);continue}a.push({id:$.id,name:$.name,key:$.key,description:$.description||"",state:$.state||"active",color:$.color,icon:$.icon,timezone:$.timezone,cyclesEnabled:$.cyclesEnabled,issueCount:$.issueCount||0,parentId:$.parentId||$.parent_id||null,parentName:$.parentName||$.parent_name||null,parentKey:$.parentKey||$.parent_key||null,createdAt:$.createdAt||$.created_at,updatedAt:$.updatedAt||$.updated_at,membersCount:0,customersCount:0})}catch(v){console.warn(`\uFE0F [TeamMethodsV2] Error processing team ${p}:`,v)}console.log(`[TeamMethodsV2] Batch fetching metadata for ${a.length} teams...`);let c=a.map(async p=>{let v=await l(`team:${p.id}:members`)||[];return{teamId:p.id,count:v.length}}),i=await Promise.all(c),u=new Map(i.map(p=>[p.teamId,p.count])),g=(await S("customer:")).filter(p=>!p.includes(":")).map(p=>p.replace("customer:","")).map(async p=>await l(`customer:${p}:teams`)||[]),h=await Promise.all(g),f=new Map;for(let p of h)for(let v of p)f.set(v,(f.get(v)||0)+1);for(let p of a)p.membersCount=u.get(p.id)||0,p.customersCount=f.get(p.id)||0;let y=Date.now()-t;return console.log(`[TeamMethodsV2] Processed ${a.length} teams in ${y}ms (optimized)`),{success:!0,data:{teams:a,count:a.length,source:"flat-optimized"}}}catch(t){return console.error("[TeamMethodsV2] Get all teams error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to fetch teams"}}}async enrichTeamHierarchy(e){if(!e||e.length===0)return[];console.log(`[TeamMethodsV2] Enriching ${e.length} team nodes (optimized)...`);let t=Date.now(),r=this.extractAllTeamIds(e);console.log(`[TeamMethodsV2] Found ${r.size} unique teams to enrich`);let a=new Map,o=Array.from(r).map(async f=>{let y=await l(`team:${f}:members`)||[];a.set(f,y.length)});await Promise.all(o);let c=(await S("customer:")).filter(f=>!f.includes(":")).map(f=>f.replace("customer:",""));console.log(`[TeamMethodsV2] Found ${c.length} customers to check`);let i=new Map,u=c.map(async f=>{let y=await l(`customer:${f}:teams`)||[];i.set(f,y)});await Promise.all(u);let m=new Map;for(let[f,y]of i.entries())for(let p of y)m.set(p,(m.get(p)||0)+1);let d=f=>{let y=f.id,p=a.get(y)||0,v=m.get(y)||0,$=f.children&&f.children.length>0?f.children.map(d):[];return{...f,membersCount:p,customersCount:v,children:$}},g=e.map(d),h=Date.now()-t;return console.log(`[TeamMethodsV2] Enrichment complete in ${h}ms (${r.size} teams, ${c.length} customers)`),g}extractAllTeamIds(e){let t=new Set,r=a=>{for(let o of a)o.id&&t.add(o.id),o.children&&o.children.length>0&&r(o.children)};return r(e),t}async invalidateCache(){console.log("\uFE0F [TeamMethodsV2] Invalidating enriched hierarchy cache"),await T(this.ENRICHED_CACHE_KEY)}async getCacheStats(){let e=await l(this.ENRICHED_CACHE_KEY);return!e||typeof e!="object"?{cached:!1,ttl:this.CACHE_TTL_MS}:{cached:!0,age:Date.now()-(e.timestamp||0),ttl:this.CACHE_TTL_MS}}async getTeamById(e,t=!0){try{console.log(`[TeamMethodsV2] Fetching team: ${e} (hierarchy: ${t})`);let r=await l(`linear_teams:${e}`);if(typeof r=="string")try{r=JSON.parse(r)}catch(m){return console.error(`[TeamMethodsV2] Failed to parse team ${e}:`,m),{success:!1,error:"Failed to parse team data"}}if(!r)return{success:!1,error:"Team not found"};let a=await l(`team:${e}:members`)||[],o=[];for(let m of a){let d=await l(`user:${m}`),g=await l(`team:${e}:member:${m}`);if(typeof d=="string")try{d=JSON.parse(d)}catch(h){console.warn(`\uFE0F [TeamMethodsV2] Failed to parse user ${m}:`,h);continue}if(typeof g=="string")try{g=JSON.parse(g)}catch(h){console.warn("\uFE0F [TeamMethodsV2] Failed to parse membership:",h),g=null}d&&o.push({user_id:m,email:d.email,name:d.metadata?.name||d.email.split("@")[0],role:d.role,status:d.status,assigned_at:g?.assigned_at,assigned_by:g?.assigned_by})}let n=await S("customer:"),c=[];for(let m of n){if(m.includes(":"))continue;let d=m.replace("customer:","");if((await l(`customer:${d}:teams`)||[]).includes(e)){let h=await l(`customer:${d}`);if(typeof h=="string")try{h=JSON.parse(h)}catch(f){console.warn(`\uFE0F [TeamMethodsV2] Failed to parse customer ${d}:`,f);continue}h&&c.push({id:h.id,name:h.name,status:h.status})}}let i=null,u=[];if(t){let m=r.parentId||r.parent_id;if(m){let g=await l(`linear_teams:${m}`);if(typeof g=="string")try{g=JSON.parse(g)}catch(h){console.warn("\uFE0F [TeamMethodsV2] Failed to parse parent team:",h),g=null}g&&(i={id:g.id,name:g.name,key:g.key,description:g.description,color:g.color,icon:g.icon})}let d=await l("linear_teams:all");if(typeof d=="string")try{d=JSON.parse(d)}catch(g){console.warn("\uFE0F [TeamMethodsV2] Failed to parse all teams data:",g),d=null}d?.teams&&(u=d.teams.filter(g=>(g.parentId||g.parent_id)===e).map(g=>({id:g.id,name:g.name,key:g.key,description:g.description,color:g.color,icon:g.icon})))}return{success:!0,data:{team:{...r,parent:i,children:u,childCount:u.length,hasParent:!!(r.parentId||r.parent_id),hasChildren:u.length>0,members:o,membersCount:o.length,customers:c,customersCount:c.length}}}}catch(r){return console.error("[TeamMethodsV2] Get team error:",r),{success:!1,error:r instanceof Error?r.message:"Failed to fetch team"}}}async getTeamMembers(e){try{if(console.log(`[TeamMethodsV2] Getting members for team: ${e}`),!await l(`linear_teams:${e}`))return{success:!1,error:"Team not found"};let r=await l(`team:${e}:members`)||[],a=[];for(let o of r){let n=await l(`user:${o}`),c=await l(`team:${e}:member:${o}`);n&&a.push({userId:o,email:n.email,name:n.metadata?.name||n.email.split("@")[0],role:n.role,status:n.status,assignedAt:c?.assignedAt||c?.assigned_at,assignedBy:c?.assignedBy||c?.assigned_by})}return console.log(`[TeamMethodsV2] Found ${a.length} members with team access`),{success:!0,data:{members:a,count:a.length}}}catch(t){return console.error("[TeamMethodsV2] Get team members error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to fetch team members"}}}async assignUserToTeam(e,t,r){try{if(console.log(`[TeamMethodsV2] Assigning user ${e} to team ${t}`),!await l(`user:${e}`))return{success:!1,error:"User not found"};if(!await l(`linear_teams:${t}`))return{success:!1,error:"Team not found"};let n=await l(`user:${e}:teams`)||[];n.includes(t)||(n.push(t),await w(`user:${e}:teams`,n));let c=await l(`team:${t}:members`)||[];c.includes(e)||(c.push(e),await w(`team:${t}:members`,c));let i={userId:e,teamId:t,assignedAt:new Date().toISOString(),assignedBy:r};return await w(`team:${t}:member:${e}`,i),console.log("[TeamMethodsV2] User assigned to team successfully"),{success:!0,data:{message:"User assigned to team successfully",membership:i}}}catch(a){return console.error("[TeamMethodsV2] Assign user to team error:",a),{success:!1,error:a instanceof Error?a.message:"Failed to assign user to team"}}}async removeUserFromTeam(e,t,r){try{console.log(`[TeamMethodsV2] Removing user ${e} from team ${t}`);let o=(await l(`user:${e}:teams`)||[]).filter(i=>i!==t);await w(`user:${e}:teams`,o);let c=(await l(`team:${t}:members`)||[]).filter(i=>i!==e);return await w(`team:${t}:members`,c),await T(`team:${t}:member:${e}`),console.log("[TeamMethodsV2] User removed from team successfully"),{success:!0,data:{message:"User removed from team successfully"}}}catch(a){return console.error("[TeamMethodsV2] Remove user from team error:",a),{success:!1,error:a instanceof Error?a.message:"Failed to remove user from team"}}}async getTeamsByCustomer(e){try{if(console.log(`[TeamMethodsV2] Getting teams for customer: ${e}`),!await l(`customer:${e}`))return{success:!1,error:"Customer not found"};let r=await l(`customer:${e}:teams`)||[],a=[];for(let o of r){let n=await l(`linear_teams:${o}`);n&&a.push({id:n.id,name:n.name,key:n.key,description:n.description,state:n.state,color:n.color,issueCount:n.issueCount||0})}return console.log(`[TeamMethodsV2] Found ${a.length} teams for customer`),{success:!0,data:{teams:a,count:a.length}}}catch(t){return console.error("[TeamMethodsV2] Get teams by customer error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to fetch teams for customer"}}}async checkUserTeamAccess(e,t){try{console.log(`[TeamMethodsV2] Checking team access for user ${e} on team ${t}`);let r=await l(`user:${e}`);if(!r)return{success:!1,error:"User not found"};if(r.role==="superadmin"||r.role==="admin")return{success:!0,data:{hasAccess:!0,reason:"admin_role"}};let a=await l(`user:${e}:customers`)||[];for(let o of a)if((await l(`customer:${o}:teams`)||[]).includes(t))return{success:!0,data:{hasAccess:!0,reason:"customer_member_access",customerId:o}};return{success:!0,data:{hasAccess:!1,reason:"no_access"}}}catch(r){return console.error("[TeamMethodsV2] Check user team access error:",r),{success:!1,error:r instanceof Error?r.message:"Failed to check team access"}}}async getUserAccessibleTeams(e){try{console.log(`[TeamMethodsV2] Getting accessible teams for user: ${e}`);let t=await l(`user:${e}`);if(!t)return{success:!1,error:"User not found"};if(t.role==="superadmin"||t.role==="admin"){let n=await this.getAllTeams();if(n.success)return{success:!0,data:{teams:n.data.teams,count:n.data.count,access_reason:"admin_role"}}}let r=new Set,a=await l(`user:${e}:customers`)||[];for(let n of a){let c=await l(`customer:${n}:teams`)||[];for(let i of c)r.add(i)}let o=[];for(let n of Array.from(r)){let c=await l(`linear_teams:${n}`);c&&o.push({id:c.id,name:c.name,key:c.key,description:c.description,state:c.state,color:c.color,issueCount:c.issueCount||0})}return console.log(`[TeamMethodsV2] Found ${o.length} accessible teams for user`),{success:!0,data:{teams:o,count:o.length}}}catch(t){return console.error("[TeamMethodsV2] Get user accessible teams error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to fetch accessible teams"}}}async getTeamHierarchy(e,t){try{console.log(`\uFE0F [TeamMethodsV2] Getting team hierarchy for user: ${e}, superadmin: ${t}`);let r=[];if(t)console.log("[TeamMethodsV2] Superadmin - fetching all teams"),r=(await S("linear_teams:")).filter(c=>!c.includes(":all")).map(c=>c.replace("linear_teams:",""));else{console.log("[TeamMethodsV2] Loading teams for regular user...");let n=await l(`user:${e}:customers`)||[];console.log(`[TeamMethodsV2] User belongs to ${n.length} customers`);let c=new Set;for(let i of n){let u=await l(`customer:${i}:teams`)||[];console.log(`[TeamMethodsV2] Customer ${i} has ${u.length} teams`);for(let m of u)c.add(m),console.log(`[TeamMethodsV2] User has access to team ${m} via customer ${i}`)}r=Array.from(c),console.log(`[TeamMethodsV2] User has ${r.length} accessible teams (via customer membership)`)}if(r.length===0)return console.log("\uFE0F [TeamMethodsV2] No accessible teams found"),{success:!0,data:[]};let a=new Map;for(let n of r){let c=await l(`linear_teams:${n}`);if(typeof c=="string")try{c=JSON.parse(c)}catch(u){console.warn(`\uFE0F [TeamMethodsV2] Failed to parse team ${n}:`,u);continue}if(!c){console.warn(`\uFE0F [TeamMethodsV2] Team ${n} not found in cache`);continue}let i=await S("customer:");for(let u of i){let m=u.replace("customer:","");if(m.includes(":"))continue;let d=m;if((await l(`customer:${d}:teams`)||[]).includes(n)){if(!a.has(d)){let f=await l(`customer:${d}`);if(typeof f=="string")try{f=JSON.parse(f)}catch(y){console.warn(`\uFE0F [TeamMethodsV2] Failed to parse customer ${d}:`,y);continue}f&&a.set(d,{id:d,name:f.name,key:f.name.substring(0,3).toUpperCase(),children:[]})}let h=a.get(d);h&&h.children.push({id:c.id,name:c.name,key:c.key,description:c.description||"",level:1,children:[]})}}}let o=Array.from(a.values());return console.log(`[TeamMethodsV2] Built hierarchy: ${o.length} customers, ${r.length} teams`),{success:!0,data:o}}catch(r){return console.error("[TeamMethodsV2] Get team hierarchy error:",r),console.error("[TeamMethodsV2] Error details:",{message:r instanceof Error?r.message:"Unknown error",stack:r instanceof Error?r.stack:void 0,type:typeof r,userId:e}),{success:!1,error:r instanceof Error?r.message:"Failed to fetch team hierarchy"}}}async getTeamCustomer(e){try{console.log(`[TeamMethodsV2] Getting customer for team: ${e}`);let t=await l(`team:${e}:customer`);if(!t)return{success:!0,data:{teamId:e,customerId:null,customerName:null,isAssigned:!1}};let r=await l(`customer:${t}`);return{success:!0,data:{teamId:e,customerId:t,customerName:r?.name||"Unknown Customer",isAssigned:!0}}}catch(t){return console.error("[TeamMethodsV2] Get team customer error:",t),{success:!1,error:t instanceof Error?t.message:"Failed to get team customer"}}}},_=new Ee;var k=new Ye;k.use("/admin/*",ke);k.get("/admin/stats",async s=>{try{let e=s.get("user"),t=await ie.getDashboardStats(D);return t.success?s.json({success:!0,data:t.data,timestamp:new Date().toISOString()}):s.json({success:!1,error:t.error},{status:500})}catch(e){return console.error("[Admin] Get stats error:",e),s.json({success:!1,error:"Failed to fetch dashboard stats"},{status:500})}});k.get("/admin/users",async s=>{try{let e=s.get("user"),t=await R.getAllUsers(D);return t.success?s.json({success:!0,data:t.data,timestamp:new Date().toISOString()}):s.json({success:!1,error:t.error},{status:500})}catch(e){return console.error("[Admin] Get users error:",e),s.json({success:!1,error:"Failed to fetch users"},{status:500})}});k.post("/admin/users",async s=>{try{let e=s.get("user"),t=await s.req.json(),{email:r,password:a,name:o,role:n,status:c,customers:i}=t;if(!r||!a)return s.json({success:!1,error:"Email and password are required"},{status:400});let u=await R.createUser({email:r,password:a,name:o,role:n,status:c,customers:i},D,e.id);return u.success?s.json({success:!0,data:u.data,message:"User created successfully"}):s.json({success:!1,error:u.error},{status:500})}catch(e){return console.error("[Admin] Create user error:",e),s.json({success:!1,error:"Failed to create user"},{status:500})}});k.get("/admin/users/:userId",async s=>{try{let e=s.get("user"),t=s.req.param("userId"),r=await R.getUserById(t,D);return r.success?s.json({success:!0,data:r.data,timestamp:new Date().toISOString()}):s.json({success:!1,error:r.error},{status:r.error?.includes("not found")?404:500})}catch(e){return console.error("[Admin] Get user error:",e),s.json({success:!1,error:"Failed to fetch user"},{status:500})}});k.put("/admin/users/:userId",async s=>{try{let e=s.get("user"),t=s.req.param("userId"),r=await s.req.json(),{name:a,role:o,status:n,customers:c}=r,i=await R.updateUser(t,{name:a,role:o,status:n},e.id,D);if(!i.success)return s.json({success:!1,error:i.error},{status:500});if(Array.isArray(c)){let u=await R.syncCustomerAssignments(t,c,e.id);u.success||console.warn("\uFE0F [Admin] Customer sync failed:",u.error)}return s.json({success:!0,data:i.data,message:"User updated successfully"})}catch(e){return console.error("[Admin] Update user error:",e),s.json({success:!1,error:"Failed to update user"},{status:500})}});k.delete("/admin/users/:userId",async s=>{try{let e=s.get("user"),t=s.req.param("userId"),r=await R.deleteUser(t,D);return r.success?s.json({success:!0,message:"User deleted successfully"}):s.json({success:!1,error:r.error},{status:500})}catch(e){return console.error("[Admin] Delete user error:",e),s.json({success:!1,error:"Failed to delete user"},{status:500})}});k.get("/admin/users/:userId/customers",async s=>{try{let e=s.req.param("userId"),t=await R.getUserCustomers(e);return t.success?s.json({success:!0,data:t.data}):s.json({success:!1,error:t.error},{status:500})}catch(e){return console.error("[Admin] Get user customers error:",e),s.json({success:!1,error:"Failed to fetch user customers"},{status:500})}});k.post("/admin/users/:userId/customers/:customerId",async s=>{try{let e=s.get("user"),t=s.req.param("userId"),r=s.req.param("customerId"),a=await R.assignUserToCustomer(t,r,e.id);return a.success?s.json({success:!0,message:"User assigned to customer successfully"}):s.json({success:!1,error:a.error},{status:500})}catch(e){return console.error("[Admin] Assign user to customer error:",e),s.json({success:!1,error:"Failed to assign user to customer"},{status:500})}});k.delete("/admin/users/:userId/customers/:customerId",async s=>{try{let e=s.get("user"),t=s.req.param("userId"),r=s.req.param("customerId"),a=await R.removeUserFromCustomer(t,r,e.id);return a.success?s.json({success:!0,message:"User removed from customer successfully"}):s.json({success:!1,error:a.error},{status:500})}catch(e){return console.error("[Admin] Remove user from customer error:",e),s.json({success:!1,error:"Failed to remove user from customer"},{status:500})}});k.get("/admin/customers",async s=>{try{let e=s.get("user"),t=await q.getAllCustomers();return t.success?s.json({success:!0,data:t.data,timestamp:new Date().toISOString()}):s.json({success:!1,error:t.error},{status:500})}catch(e){return console.error("[Admin] Get customers error:",e),s.json({success:!1,error:"Failed to fetch customers"},{status:500})}});k.post("/admin/customers",async s=>{try{let e=s.get("user"),t=await s.req.json(),{name:r,status:a,metadata:o}=t;if(!r)return s.json({success:!1,error:"Customer name is required"},{status:400});let n=await q.createCustomer({name:r,status:a,metadata:o},e.id);return n.success?s.json({success:!0,data:n.data,message:"Customer created successfully"}):s.json({success:!1,error:n.error},{status:500})}catch(e){return console.error("[Admin] Create customer error:",e),s.json({success:!1,error:"Failed to create customer"},{status:500})}});k.put("/admin/customers/:customerId",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=await s.req.json(),{name:a,status:o,metadata:n}=r,c=await q.updateCustomer(t,{name:a,status:o,metadata:n},e.id);return c.success?s.json({success:!0,data:c.data,message:"Customer updated successfully"}):s.json({success:!1,error:c.error},{status:500})}catch(e){return console.error("[Admin] Update customer error:",e),s.json({success:!1,error:"Failed to update customer"},{status:500})}});k.delete("/admin/customers/:customerId",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=await q.deleteCustomer(t,e.id);return r.success?s.json({success:!0,message:"Customer deleted successfully"}):s.json({success:!1,error:r.error},{status:500})}catch(e){return console.error("[Admin] Delete customer error:",e),s.json({success:!1,error:"Failed to delete customer"},{status:500})}});k.get("/admin/customers/:customerId/teams",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=await q.getCustomerTeams(t);return r.success?s.json({success:!0,data:r.data,timestamp:new Date().toISOString()}):s.json({success:!1,error:r.error},{status:500})}catch(e){return console.error("[Admin] Get customer teams error:",e),s.json({success:!1,error:"Failed to fetch customer teams"},{status:500})}});k.post("/admin/customers/:customerId/teams",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=await s.req.json(),{linearTeamId:a,linear_team_id:o}=r,n=a||o;if(!n)return s.json({success:!1,error:"Team ID is required"},{status:400});let c=await q.assignTeamToCustomer(t,n,e.id);return c.success?s.json({success:!0,message:"Team assigned to customer successfully",data:c.data,timestamp:new Date().toISOString()}):s.json({success:!1,error:c.error},{status:500})}catch(e){return console.error("[Admin] Assign team to customer error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to assign team to customer"},{status:500})}});k.delete("/admin/customers/:customerId/teams/:teamId",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=s.req.param("teamId"),a=await q.removeTeamFromCustomer(t,r);return a.success?s.json({success:!0,message:"Team removed from customer successfully",timestamp:new Date().toISOString()}):s.json({success:!1,error:a.error},{status:500})}catch(e){return console.error("[Admin] Remove team from customer error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to remove team from customer"},{status:500})}});k.get("/admin/customers/:customerId/teams/:teamId/members",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=s.req.param("teamId"),a=await q.getCustomerTeamMembers(t,r);return a.success?s.json({success:!0,data:a.data,timestamp:new Date().toISOString()}):s.json({success:!1,error:a.error},{status:500})}catch(e){return console.error("[Admin] Get customer team members error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to fetch team members"},{status:500})}});k.post("/admin/customers/:customerId/teams/:teamId/members",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=s.req.param("teamId"),a=await s.req.json(),{userId:o}=a;if(!o)return s.json({success:!1,error:"User ID is required"},{status:400});let n=await q.addMemberToCustomerTeam(t,r,o,e.id);return n.success?s.json({success:!0,message:"Member added to team successfully",data:n.data,timestamp:new Date().toISOString()}):s.json({success:!1,error:n.error},{status:500})}catch(e){return console.error("[Admin] Add member to team error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to add member to team"},{status:500})}});k.delete("/admin/customers/:customerId/teams/:teamId/members/:userId",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=s.req.param("teamId"),a=s.req.param("userId"),o=await q.removeMemberFromCustomerTeam(t,r,a,e.id);return o.success?s.json({success:!0,message:"Member removed from team successfully",timestamp:new Date().toISOString()}):s.json({success:!1,error:o.error},{status:500})}catch(e){return console.error("[Admin] Remove member from team error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to remove member from team"},{status:500})}});k.get("/admin/customers/:customerId/members",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=await l(`customer:${t}:members`)||[],a=[];for(let o of r){let n=await l(`user:${o}`),c=await l(`customer:${t}:member:${o}`);if(n){let i=typeof n=="string"?JSON.parse(n):n,u=typeof c=="string"?JSON.parse(c):c;a.push({userId:i.id,email:i.email,name:i.metadata?.name||i.email.split("@")[0],role:i.role||"viewer",status:i.status||"active",assignedAt:u?.assignedAt||i.createdAt,assignedBy:u?.assignedBy})}}return s.json({success:!0,data:{members:a,count:a.length,customerId:t},timestamp:new Date().toISOString()})}catch(e){return console.error("[Admin] Get customer members error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to fetch customer members"},{status:500})}});k.post("/admin/customers/:customerId/members",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=await s.req.json(),{userId:a}=r;if(!a)return s.json({success:!1,error:"User ID is required"},{status:400});if((await l(`customer:${t}:members`)||[]).includes(a))return s.json({success:!0,message:"User already assigned to customer",data:{customerId:t,userId:a}});let n=await R.assignUserToCustomer(a,t,e.id);return n.success?s.json({success:!0,message:"User added to customer successfully",data:{customerId:t,userId:a}}):s.json({success:!1,error:n.error},{status:500})}catch(e){return console.error("[Admin] Add customer member error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to add customer member"},{status:500})}});k.delete("/admin/customers/:customerId/members/:userId",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=s.req.param("userId"),o=(await l(`customer:${t}:members`)||[]).filter(i=>i!==r);await w(`customer:${t}:members`,o);let c=(await l(`user:${r}:customers`)||[]).filter(i=>i!==t);return await w(`user:${r}:customers`,c),s.json({success:!0,message:"User removed from customer successfully"})}catch(e){return console.error("[Admin] Remove customer member error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to remove customer member"},{status:500})}});k.get("/admin/teams/:teamId/customer",async s=>{try{let e=s.get("user"),t=s.req.param("teamId"),r=await _.getTeamCustomer(t);return r.success?s.json({success:!0,data:r.data,timestamp:new Date().toISOString()}):s.json({success:!1,error:r.error},{status:500})}catch(e){return console.error("[Admin] Get team customer error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to get team customer"},{status:500})}});k.get("/admin/customers/:customerId/available-teams",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=await _.getAvailableTeamsForCustomer(t);return r.success?s.json({success:!0,data:r.data,timestamp:new Date().toISOString()}):s.json({success:!1,error:r.error},{status:500})}catch(e){return console.error("[Admin] Get available teams error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to get available teams"},{status:500})}});k.get("/admin/customers/:customerId/teams/:teamId/members",async s=>{try{let e=s.get("user"),t=s.req.param("customerId"),r=s.req.param("teamId"),a=await q.getCustomerTeamMembers(t,r);return a.success?s.json({success:!0,data:a.data,timestamp:new Date().toISOString()}):s.json({success:!1,error:a.error},{status:500})}catch(e){return console.error("[Admin] Get customer team members error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to fetch team members"},{status:500})}});k.get("/admin/activity",async s=>{try{let e=s.get("user"),t=parseInt(s.req.query("limit")||"50"),r=parseInt(s.req.query("offset")||"0"),a=await ie.getActivityLogs({limit:t,offset:r});return a.success?s.json({success:!0,data:a.data}):s.json({success:!1,error:a.error},{status:500})}catch(e){return console.error("[Admin] Get activity logs error:",e),s.json({success:!1,error:"Failed to fetch activity logs"},{status:500})}});k.get("/admin/roles",async s=>{try{let e=s.get("user"),t=await ie.getRoleDefinitions();return t.success?s.json({success:!0,data:t.data}):s.json({success:!1,error:t.error},{status:500})}catch(e){return console.error("[Admin] Get role definitions error:",e),s.json({success:!1,error:"Failed to fetch role definitions"},{status:500})}});V();M();import{Hono as Xe}from"hono";var z=new Xe;z.get("/user/teams",E,async s=>{try{let e=s.get("userId"),t=s.get("userEmail"),r=s.get("role"),a=s.get("isSuperAdmin");if(a||r==="admin"){let u=await l("linear_teams:all"),m=[];return u&&(m=(typeof u=="string"?JSON.parse(u):u).teams||[]),s.json({success:!0,data:{teams:m,count:m.length,access:"all",reason:a?"superadmin":"admin"}})}let o=await l(`user:${e}:customers`)||[];if(o.length===0)return s.json({success:!0,data:{teams:[],count:0,access:"none",reason:"no_customer_assignment"}});let n=new Set,c=new Map;for(let u of o){let m=await l(`customer:${u}:teams`)||[];if(m.length===0){console.warn("   \uFE0F No teams assigned to this customer");continue}for(let d of m){let g=`customer:${u}:team:${d}:members`;(await l(g)||[]).includes(e)&&(n.add(d),c.set(d,u))}}if(n.size===0){console.error(`
========== NO TEAMS ACCESSIBLE! ==========`),console.error("Possible causes:"),console.error("  1. User not assigned to any customer"),console.error("  2. Customer has no teams assigned"),console.error("  3. User not added to team-level members (Schema V2.0)"),console.error("  4. Empty KV keys for team members"),console.error(`
Next Steps:`),console.error("  1. Check backend logs for detailed info"),console.error("  2. Verify KV storage keys:"),console.error("     - user:{userId}:customers"),console.error("     - customer:{customerId}:teams"),console.error("     - customer:{customerId}:team:{teamId}:members"),console.error("  3. Admin: Open Team Assignment \u2192 Manage Team Members \u2192 Add user"),console.error(`===============================================
`);let u=0;for(let m of o){let d=await l(`customer:${m}:teams`)||[];u+=d.length}console.error("Diagnostic Summary:"),console.error(`  - User ID: ${e}`),console.error(`  - Email: ${t}`),console.error(`  - Customers assigned: ${o.length}`),console.error(`  - Total teams across customers: ${u}`),console.error("  - Teams user is member of: 0")}let i=[];for(let u of n){let m=await l(`linear_teams:${u}`);if(typeof m=="string")try{m=JSON.parse(m)}catch{console.warn(`\uFE0F [UserRoutes] Failed to parse team ${u}`);continue}m&&m.id&&i.push({id:m.id,name:m.name,key:m.key,description:m.description})}return s.json({success:!0,data:{teamIds:Array.from(n),teams:i,count:i.length,permissionModel:"team-level",customerCount:o.length}})}catch(e){return console.error("[UserRoutes] Error fetching user teams:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to fetch user teams"},{status:500})}});z.get("/user/teams/:teamId/access",E,async s=>{try{let e=s.get("userId"),t=s.get("userEmail"),r=s.get("role"),a=s.get("isSuperAdmin"),o=s.req.param("teamId"),n=async i=>{let u=await l(`linear_teams:${i}`);if(typeof u=="string")try{u=JSON.parse(u)}catch{console.warn(`\uFE0F [UserRoutes] Failed to parse team ${i} from cache`),u=null}if(u?.name)return u.name;try{let{LinearTeamService:m}=await Promise.resolve().then(()=>(Z(),ne)),g=await new m().getTeamById(i);if(g?.name)return await w(`linear_teams:${i}`,g),g.name}catch(m){console.error("[UserRoutes] Failed to fetch team from Linear API:",m)}return console.warn(`\uFE0F [UserRoutes] Could not get team name for ${i}, using ID as fallback`),i};if(a||r==="admin"){let i=await n(o);return s.json({success:!0,hasAccess:!0,accessType:"customer-level",role:a?"superadmin":"admin",teamName:i,teamId:o})}let c=await l(`user:${e}:customers`)||[];for(let i of c)if((await l(`customer:${i}:teams`)||[]).includes(o)){let m=await n(o);return s.json({success:!0,hasAccess:!0,accessType:"customer-level",role:r,teamName:m,customerId:i,teamId:o})}return s.json({success:!0,hasAccess:!1,accessType:null,teamId:o})}catch(e){return console.error("[UserRoutes] Error checking team access:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to check team access"},{status:500})}});z.get("/user/teams/:teamId/kanban-settings",E,async s=>{try{let e=s.get("userId"),t=s.req.param("teamId"),r=`user:${e}:team:${t}:kanban_settings`,a=await l(r);return a?s.json({success:!0,data:a}):s.json({success:!0,data:null},{status:404})}catch(e){return console.error("[UserRoutes] Error fetching Kanban settings:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to fetch Kanban settings"},{status:500})}});z.put("/user/teams/:teamId/kanban-settings",E,async s=>{try{let e=s.get("userId"),t=s.req.param("teamId"),r=await s.req.json();if(!r.columnsOrder||!Array.isArray(r.columnsOrder))return s.json({success:!1,error:"Invalid settings: columnsOrder is required and must be an array"},{status:400});let a={...r,teamId:t,userId:e,updatedAt:new Date().toISOString()},o=`user:${e}:team:${t}:kanban_settings`;return await w(o,a),s.json({success:!0,message:"Kanban settings saved successfully"})}catch(e){return console.error("[UserRoutes] Error saving Kanban settings:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to save Kanban settings"},{status:500})}});z.delete("/user/teams/:teamId/kanban-settings",E,async s=>{try{let e=s.get("userId"),t=s.req.param("teamId"),r=`user:${e}:team:${t}:kanban_settings`;return await T(r),s.json({success:!0,message:"Kanban settings deleted successfully"})}catch(e){return console.error("[UserRoutes] Error deleting Kanban settings:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to delete Kanban settings"},{status:500})}});V();import{Hono as Ze}from"hono";M();var P=new Ze;P.use("*",E);P.get("/teams/my-teams",async s=>{try{let e=s.get("user"),t=await _.getUserTeams(e.id);return t.success?s.json({success:!0,data:t.data}):s.json({success:!1,error:t.error},{status:500})}catch(e){return console.error("[Teams] Get user teams error:",e),s.json({success:!1,error:"Failed to fetch user teams"},{status:500})}});P.get("/teams/hierarchy",async s=>{try{let e=s.get("user"),t=s.get("role"),r=s.get("isSuperAdmin"),a=s.get("userPermissions");if(!e||!e.id)return console.error("[Teams] Missing user context in request"),s.json({success:!1,error:"Authentication required"},{status:401});let o=await _.getTeamHierarchy(e.id,r);return o.success?s.json({success:!0,data:o.data}):(console.error("[Teams] getTeamHierarchy failed:",o.error),s.json({success:!1,error:o.error},{status:500}))}catch(e){return console.error("[Teams] Get hierarchy error:",e),s.json({success:!1,error:"Failed to fetch team hierarchy"},{status:500})}});P.get("/teams/:teamId/access",async s=>{try{let e=s.get("user"),t=s.req.param("teamId"),r=await _.checkUserTeamAccess(e.id,t);return r.success?s.json({success:!0,data:r.data}):s.json({success:!1,error:r.error},{status:403})}catch(e){return console.error("[Teams] Check team access error:",e),s.json({success:!1,error:"Failed to check team access"},{status:500})}});P.get("/teams/:teamId",async s=>{try{let e=s.get("user"),t=s.req.param("teamId"),r=s.req.query("includeHierarchy")!=="false";if(!(await _.checkUserTeamAccess(e.id,t)).success)return s.json({success:!1,error:"Access denied"},{status:403});let o=await _.getTeamById(t,r);return o.success?s.json({success:!0,data:o.data}):s.json({success:!1,error:o.error},{status:o.error==="Team not found"?404:500})}catch(e){return console.error("[Teams] Get team error:",e),s.json({success:!1,error:"Failed to fetch team"},{status:500})}});P.get("/teams",async s=>{try{let e=s.get("user"),t=s.get("role"),r=s.req.query("includeHierarchy")==="true",a=await _.getAllTeams(r);return a.success?s.json({success:!0,data:a.data}):s.json({success:!1,error:a.error},{status:500})}catch(e){return console.error("[Teams] Get all teams error:",e),s.json({success:!1,error:"Failed to fetch teams"},{status:500})}});P.post("/teams",async s=>{try{let e=s.get("user"),t=s.get("role");if(t!=="admin"&&t!=="superadmin")return s.json({success:!1,error:"Admin access required"},{status:403});let r=await s.req.json(),{customer_id:a,name:o,linear_team_id:n,linear_team_key:c}=r;if(!a||!o)return s.json({success:!1,error:"customer_id and name are required"},{status:400});let i=await _.createTeam({customer_id:a,name:o,linear_team_id:n,linear_team_key:c},e.id);return i.success?s.json({success:!0,data:i.data,message:"Team created successfully"}):s.json({success:!1,error:i.error},{status:500})}catch(e){return console.error("[Teams] Create team error:",e),s.json({success:!1,error:"Failed to create team"},{status:500})}});P.put("/teams/:teamId",async s=>{try{let e=s.get("user"),t=s.get("role"),r=s.req.param("teamId");if(t!=="admin"&&t!=="superadmin")return s.json({success:!1,error:"Admin access required"},{status:403});let a=await s.req.json(),{name:o,linear_team_id:n,linear_team_key:c,status:i}=a,u=await _.updateTeam(r,{name:o,linear_team_id:n,linear_team_key:c,status:i},e.id);return u.success?s.json({success:!0,data:u.data,message:"Team updated successfully"}):s.json({success:!1,error:u.error},{status:500})}catch(e){return console.error("[Teams] Update team error:",e),s.json({success:!1,error:"Failed to update team"},{status:500})}});P.delete("/teams/:teamId",async s=>{try{let e=s.get("user"),t=s.get("role"),r=s.req.param("teamId");if(t!=="admin"&&t!=="superadmin")return s.json({success:!1,error:"Admin access required"},{status:403});let a=await _.deleteTeam(r,e.id);return a.success?s.json({success:!0,message:"Team deleted successfully"}):s.json({success:!1,error:a.error},{status:500})}catch(e){return console.error("[Teams] Delete team error:",e),s.json({success:!1,error:"Failed to delete team"},{status:500})}});P.post("/teams/sync-from-linear",async s=>{try{let e=s.get("user"),t=s.get("role");if(t!=="admin"&&t!=="superadmin")return s.json({success:!1,error:"Admin access required"},{status:403});let{LinearTeamService:r}=await Promise.resolve().then(()=>(Z(),ne)),o=await new r().listTeams();if(!o.success||!o.teams)return console.error("[Teams] Failed to fetch teams from Linear:",o.message),s.json({success:!1,error:o.message||"Failed to fetch teams from Linear"},{status:500});let n=o.teams,c=0,i=0;for(let u of n)try{let m=`linear_teams:${u.id}`;await w(m,{id:u.id,name:u.name,key:u.key,description:u.description||"",state:"active",created_at:new Date().toISOString(),updated_at:new Date().toISOString(),synced_from_linear:!0,last_sync:new Date().toISOString()}),c++}catch(m){i++,console.error(`[Teams] Failed to sync team ${u.name}:`,m)}return s.json({success:!0,data:{total:n.length,synced:c,errors:i},message:`Successfully synced ${c} teams from Linear`})}catch(e){return console.error("[Teams] Sync from Linear error:",e),s.json({success:!1,error:"Failed to sync teams from Linear"},{status:500})}});P.get("/teams/:teamId/members",async s=>{try{let e=s.get("user"),t=s.req.param("teamId");if(!(await _.checkUserTeamAccess(e.id,t)).success)return s.json({success:!1,error:"Access denied to this team"},{status:403});let a=await _.getTeamMembers(t);return a.success?s.json({success:!0,data:a.data}):s.json({success:!1,error:a.error},{status:500})}catch(e){return console.error("[Teams] Get team members error:",e),s.json({success:!1,error:"Failed to fetch team members"},{status:500})}});P.post("/teams/:teamId/members/:userId",async s=>{try{let e=s.get("user"),t=s.get("role"),r=s.req.param("teamId"),a=s.req.param("userId");if(t!=="admin"&&t!=="superadmin"&&t!=="client_manager")return s.json({success:!1,error:"Insufficient permissions"},{status:403});let o=await _.addMemberToTeam(r,a,e.id);return o.success?s.json({success:!0,message:"Member added to team successfully"}):s.json({success:!1,error:o.error},{status:500})}catch(e){return console.error("[Teams] Add member error:",e),s.json({success:!1,error:"Failed to add member to team"},{status:500})}});P.delete("/teams/:teamId/members/:userId",async s=>{try{let e=s.get("user"),t=s.get("role"),r=s.req.param("teamId"),a=s.req.param("userId");if(t!=="admin"&&t!=="superadmin"&&t!=="client_manager")return s.json({success:!1,error:"Insufficient permissions"},{status:403});let o=await _.removeMemberFromTeam(r,a,e.id);return o.success?s.json({success:!0,message:"Member removed from team successfully"}):s.json({success:!1,error:o.error},{status:500})}catch(e){return console.error("[Teams] Remove member error:",e),s.json({success:!1,error:"Failed to remove member from team"},{status:500})}});V();Z();import{Hono as us}from"hono";import{createClient as Ce}from"@supabase/supabase-js";import{createClient as ss}from"@supabase/supabase-js";var b={USER_FIELDS:`
    id
    name
    email
    avatarUrl
  `,USER_WITH_ACTIVE:`
    id
    name
    email
    avatarUrl
    active
  `,STATE_BASIC:`
    id
    name
    type
  `,STATE_FULL:`
    id
    name
    type
    position
    color
    description
  `,LABEL_BASIC:`
    id
    name
    color
  `,LABEL_FULL:`
    id
    name
    color
    description
  `,PROJECT_BASIC:`
    id
    name
    icon
    color
  `,PROJECT_FULL:`
    id
    name
    description
    state
    color
    icon
    startedAt
    targetDate
  `,COMMENT_WITH_USER:`
    id
    body
    createdAt
    user {
      id
      name
      avatarUrl
    }
  `,ATTACHMENT_FIELDS:`
    id
    title
    url
    createdAt
  `,ISSUE_CORE:`
    id
    identifier
    title
    description
    url
    priority
    createdAt
    updatedAt
  `},es={TEAM_CONFIG:`
    id
    name
    key
    description
    timezone
    states {
      nodes {
        ${b.STATE_FULL}
      }
    }
    labels {
      nodes {
        ${b.LABEL_FULL}
      }
    }
    projects {
      nodes {
        ${b.PROJECT_FULL}
      }
    }
    members {
      nodes {
        ${b.USER_WITH_ACTIVE}
      }
    }
  `},ee={GET_TEAM_CONFIG:`
    query GetTeamConfig($teamId: String!) {
      team(id: $teamId) {
        ${es.TEAM_CONFIG}
      }
    }
  `,GET_ALL_TEAM_ISSUES:`
    query GetAllTeamIssues($teamId: ID!, $after: String) {
      issues(
        filter: { 
          team: { id: { eq: $teamId } } 
        }
        first: 200
        after: $after
        orderBy: updatedAt
      ) {
        nodes {
          ${b.ISSUE_CORE}
          priority
          priorityLabel
          estimate
          dueDate
          state {
            ${b.STATE_FULL}
          }
          assignee {
            ${b.USER_FIELDS}
          }
          creator {
            ${b.USER_FIELDS}
          }
          project {
            ${b.PROJECT_BASIC}
          }
          labels {
            nodes {
              ${b.LABEL_BASIC}
            }
          }
          completedAt
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
  `,GET_ISSUES_IN_STATE:`
    query GetIssuesInState($teamId: ID!, $stateId: ID!, $after: String) {
      issues(
        filter: { 
          team: { id: { eq: $teamId } }, 
          state: { id: { eq: $stateId } } 
        }
        first: 100
        after: $after
      ) {
        nodes {
          ${b.ISSUE_CORE}
          parent {
            id
            identifier
            title
          }
          state {
            ${b.STATE_BASIC}
          }
          assignee {
            ${b.USER_FIELDS}
          }
          project {
            ${b.PROJECT_BASIC}
          }
          labels {
            nodes {
              ${b.LABEL_BASIC}
            }
          }
          children {
            nodes {
              id
              identifier
              title
              url
              state {
                ${b.STATE_FULL}
              }
              assignee {
                ${b.USER_FIELDS}
              }
              labels {
                nodes {
                  ${b.LABEL_BASIC}
                }
              }
              priority
              priorityLabel
            }
          }
          priority
          priorityLabel
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
  `,GET_ISSUE_DETAIL:`
    query GetIssueDetail($issueId: String!) {
      issue(id: $issueId) {
        ${b.ISSUE_CORE}
        estimate
        dueDate
        completedAt
        priorityLabel
        state {
          ${b.STATE_FULL}
        }
        team {
          id
          name
          key
        }
        project {
          id
          name
          description
          color
          icon
        }
        assignee {
          ${b.USER_WITH_ACTIVE}
        }
        creator {
          ${b.USER_FIELDS}
        }
        parent {
          id
          identifier
          title
        }
        labels {
          nodes {
            ${b.LABEL_FULL}
          }
        }
        comments(first: 50, orderBy: createdAt) {
          nodes {
            ${b.COMMENT_WITH_USER}
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
        attachments {
          nodes {
            ${b.ATTACHMENT_FIELDS}
          }
        }
        children(first: 50) {
          nodes {
            id
            identifier
            title
            description
            url
            priority
            priorityLabel
            state {
              ${b.STATE_FULL}
            }
            assignee {
              ${b.USER_FIELDS}
            }
          }
        }
      }
    }
  `,GET_CUSTOMER_DELIVERABLES:`
    query GetCustomerDeliverables($teamId: ID!, $projectName: String!, $states: [String!], $after: String) {
      issues(
        filter: {
          team: { id: { eq: $teamId } },
          project: { name: { eq: $projectName } },
          state: { name: { in: $states } }
        }
        orderBy: updatedAt
        first: 100
        after: $after
      ) {
        nodes {
          ${b.ISSUE_CORE}
          state {
            ${b.STATE_BASIC}
          }
          assignee {
            ${b.USER_FIELDS}
          }
          project {
            ${b.PROJECT_BASIC}
          }
          labels {
            nodes {
              ${b.LABEL_BASIC}
            }
          }
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
  `},zs={UPDATE_ISSUE_STATE:`
    mutation UpdateIssueState($issueId: String!, $stateId: String!) {
      issueUpdate(id: $issueId, input: { stateId: $stateId }) {
        success
        issue {
          id
          identifier
          state {
            ${b.STATE_BASIC}
          }
        }
      }
    }
  `,ADD_COMMENT:`
    mutation AddComment($issueId: String!, $body: String!) {
      commentCreate(input: { issueId: $issueId, body: $body }) {
        success
        comment {
          ${b.COMMENT_WITH_USER}
        }
      }
    }
  `,CREATE_ISSUE:`
    mutation CreateIssue($teamId: String!, $title: String!, $description: String, $stateId: String, $priority: Int, $assigneeId: String, $labelIds: [String!]) {
      issueCreate(input: {
        teamId: $teamId,
        title: $title,
        description: $description,
        stateId: $stateId,
        priority: $priority,
        assigneeId: $assigneeId,
        labelIds: $labelIds
      }) {
        success
        issue {
          ${b.ISSUE_CORE}
          state {
            ${b.STATE_BASIC}
          }
          priority
          assignee {
            ${b.USER_FIELDS}
          }
          labels {
            nodes {
              ${b.LABEL_BASIC}
            }
          }
        }
      }
    }
  `,DELETE_ISSUE:`
    mutation DeleteIssue($issueId: String!) {
      issueDelete(id: $issueId) {
        success
      }
    }
  `,UPDATE_ISSUE:`
    mutation UpdateIssue($issueId: String!, $title: String, $description: String, $priority: Int, $assigneeId: String, $stateId: String, $labelIds: [String!]) {
      issueUpdate(id: $issueId, input: {
        title: $title,
        description: $description,
        priority: $priority,
        assigneeId: $assigneeId,
        stateId: $stateId,
        labelIds: $labelIds
      }) {
        success
        issue {
          ${b.ISSUE_CORE}
          priority
          state {
            ${b.STATE_BASIC}
          }
          assignee {
            ${b.USER_FIELDS}
          }
          labels {
            nodes {
              ${b.LABEL_BASIC}
            }
          }
          updatedAt
        }
      }
    }
  `};M();var ts="https://api.linear.app/graphql";async function rs(){let s=process.env.LINEAR_API_KEY;if(s)return s;try{let e=ss(process.env.SUPABASE_URL,process.env.SUPABASE_SERVICE_ROLE_KEY),{data:t,error:r}=await e.from("kv_store_7f0d90fb").select("value").eq("key","linear_api_key").single();if(r||!t?.value)throw new Error("Linear API key not found in environment or KV store");return t.value}catch(e){throw console.error("Failed to get Linear API key:",e),new Error("Linear API key not configured")}}async function j(s,e={}){let t=Math.random().toString(36).substr(2,9),r=Date.now();try{let a=await rs(),o=s.match(/(?:query|mutation)\s+(\w+)/),n=o?o[1]:"UnknownQuery",c={query:s,variables:e},i=new AbortController,u=setTimeout(()=>i.abort(),1e4),m=await fetch(ts,{method:"POST",headers:{Authorization:a,"Content-Type":"application/json","User-Agent":"Teifi-Digital-Client-Portal/1.0","public-file-urls-expire-in":"3600"},body:JSON.stringify(c),signal:i.signal});clearTimeout(u);let d=Date.now()-r;if((d>1e3||!m.ok)&&console.log(`[${t}] [Linear API] ${n} - ${d}ms (${m.status})`),!m.ok){let h=await m.text();throw console.error(`[${t}] [Linear API] HTTP Error for ${n}:`,{status:m.status,statusText:m.statusText,responseBody:h,headers:Object.fromEntries(m.headers.entries())}),new Error(`Linear API HTTP Error: ${m.status} ${m.statusText} - ${h}`)}let g=await m.json();if(g.errors&&g.errors.length>0){console.error(`[${t}] [Linear API] GraphQL Errors for ${n}:`,{errors:g.errors,query:n,variables:e,fullResponse:g}),console.error(`[${t}] [Linear API] Failed Query Details:`),console.error(`[${t}] [Linear API] Query Name: ${n}`),console.error(`[${t}] [Linear API] Variables: ${JSON.stringify(e,null,2)}`),console.error(`[${t}] [Linear API] Query Text: ${s}`);let h=g.errors[0]?.message||"Unknown GraphQL error";if(h.includes("Variable")&&h.includes("type")&&h.includes("expecting"))throw console.error(`[${t}] [Linear API] TYPE MISMATCH ERROR in ${n}:`),console.error(`[${t}] [Linear API] Error: ${h}`),console.error(`[${t}] [Linear API] This indicates variable type doesn't match GraphQL schema`),new Error(`Linear GraphQL Type Error in ${n}: ${h}`);if(h.includes("Entity not found: Team")){let f=e.teamId,y=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;throw console.warn(`\uFE0F [${t}] [Linear API] Team entity not found:`,{teamId:f,isUUID:f&&y.test(f),queryName:n}),f&&y.test(f)?(console.warn(`\uFE0F [${t}] [Linear API] UUID team ${f} not found in Linear workspace`),new Error(`UUID team not found in Linear workspace: ${f}`)):(console.warn(`\uFE0F [${t}] [Linear API] Team ${f} not found in Linear workspace`),new Error(`Team not found in Linear workspace: ${f}`))}throw new Error(`Linear GraphQL Error in ${n}: ${h}`)}if(!g.data)throw console.error(`\uFE0F [${t}] [Linear API] No data in response for ${n}:`,{fullResponse:g,queryName:n,variables:e}),new Error(`No data returned from Linear GraphQL query: ${n}`);return d>1e3&&console.log(`[${t}] [Linear API] ${n} completed in ${d}ms`),g.data}catch(a){let o=Date.now()-r;throw console.error(`[${t}] [Linear API] Request failed:`,{error:a instanceof Error?a.message:String(a),errorType:a?.constructor?.name,responseTime:`${o}ms`,stack:a instanceof Error?a.stack:void 0}),a}}async function Q(s){try{let e=await j(ee.GET_TEAM_CONFIG,{teamId:s});if(!e||!e.team)return console.warn(`\uFE0F [getTeamConfig] No team data returned for teamId: ${s}`),null;let t=e.team;return{id:t.id,name:t.name,key:t.key,description:t.description,timezone:t.timezone,states:t.states?.nodes||[],labels:t.labels?.nodes||[],members:t.members?.nodes||[],projects:t.projects?.nodes||[],createdAt:t.createdAt,updatedAt:t.updatedAt}}catch(e){let t=e instanceof Error?e.message:String(e);if(t.includes("team not found")||t.includes("Entity not found: Team"))return console.warn(`\uFE0F [getTeamConfig] Team not found in Linear: ${s}`),null;throw e}}async function as(s){let e=[],t,r=0;for(console.log(`[Pagination] Starting to fetch all issues for team ${s}`);;){r++,console.log(`[Pagination] Fetching page ${r}${t?` (cursor: ${t.substring(0,10)}...)`:""}`);let a=await j(ee.GET_ALL_TEAM_ISSUES,{teamId:s,after:t}),o=a.issues.nodes;e=e.concat(o),console.log(`[Pagination] Page ${r}: Retrieved ${o.length} issues (total: ${e.length})`);let n=a.issues.pageInfo;if(!n.hasNextPage){console.log(`[Pagination] Complete! Total issues fetched: ${e.length} across ${r} page(s)`);break}t=n.endCursor}return e}async function os(s,e){let t=[],r;for(;;){let a=await j(ee.GET_ISSUES_IN_STATE,{teamId:s,stateId:e,after:r}),o=a.issues.nodes;t=t.concat(o);let n=a.issues.pageInfo;if(!n.hasNextPage)break;r=n.endCursor}return t}async function ns(s,e){let t=await os(s,e);console.log(`[Parent-Child] Processing ${t.length} issues for grouping`);let r=d=>{let g=d.children?.nodes||[];if(g.length===0)return 0;let h=g.length;return g.forEach(f=>{h+=r(f)}),h},a=d=>{let g=d.children?.nodes||[],h={level1:0,level2:0,level3Plus:0,byState:{},total:0};return h.level1=g.length,g.forEach(f=>{let y=f.state?.name||"unknown";h.byState[y]=(h.byState[y]||0)+1;let p=f.children?.nodes||[];h.level2+=p.length,p.forEach(v=>{let $=v.state?.name||"unknown";h.byState[$]=(h.byState[$]||0)+1;let I=r(v);h.level3Plus+=I})}),h.total=h.level1+h.level2+h.level3Plus,h};console.log(`[Hierarchy Counter] Processing ${t.length} issues to count descendants...`),t.forEach(d=>{let g=r(d),h=a(d),f=d.children?.nodes?.length||0;if(d._originalSubIssueCount=f,d._hierarchyBreakdown=h,console.log(`[Hierarchy] ${d.identifier}: ${f} direct children from API (total descendants: ${g}, L1:${h.level1}, L2:${h.level2}, L3+:${h.level3Plus})`),g>0){let y=Object.entries(h.byState).map(([v,$])=>`${v}:${$}`).join(", ");console.log(`   \u2514\u2500Distribution: ${y}`),(d.children?.nodes||[]).forEach(v=>{let $=r(v),I=$>0?`${v.identifier} (${v.state?.name}, +${$} nested)`:`${v.identifier} (${v.state?.name})`;console.log(`   \u2514\u2500 ${I}`)})}});let o=Object.fromEntries(t.map(d=>[d.id,{...d,subIssues:[],_originalSubIssueCount:d._originalSubIssueCount,_hierarchyBreakdown:d._hierarchyBreakdown}])),n=[],c=0,i={};t.forEach(d=>{d.parent?.id&&(i[d.id]=d.parent)});let u=d=>{if(!d.parent?.id||!o[d.parent.id])return!1;let h=t.find(f=>f.id===d.parent.id);if(h?.parent?.id){let f=o[h.parent.id];if(f)return console.log(`[Hierarchy] ${d.identifier} is nested: parent=${h.identifier}, grandparent=${f.identifier}`),!0}return!1};for(let d of t)if(d.parent?.id){let g=o[d.parent.id];g?u(d)?console.log(`[Hierarchy] ${d.identifier} is nested sub-issue \u2192 HIDDEN from Kanban`):(c++,g.subIssues.push(d),console.log(`[Hierarchy] ${d.identifier} \u2192 parent ${g.identifier} (direct child)`)):(console.log(`[Parent-Child] ${d.identifier} has parent ${d.parent.identifier} in different state - showing as root`),n.push(o[d.id]))}else n.push(o[d.id]);console.log(`[Parent-Child] Grouped into ${n.length} root issues with ${c} sub-issues`),console.log(`[SubIssue Count] Verifying _originalSubIssueCount for ${n.length} root issues:`),n.forEach(d=>{d._originalSubIssueCount!==void 0?console.log(`  ${d.identifier}._originalSubIssueCount = ${d._originalSubIssueCount}`):console.log(`  [DEBUG] ${d.identifier}._originalSubIssueCount = UNDEFINED (this is a BUG!)`)});let m=n.filter(d=>d.subIssues.length>0);return m.length>0&&(console.log(`[Parent-Child] ${m.length} issues have sub-issues:`),m.forEach(d=>{console.log(`   ${d.identifier}: ${d.subIssues.length} sub-issue(s)`)})),n}async function ce(s){let e=`linear:issue-detail:${s}`,t=120,r=Date.now();try{let i=await l(e);if(i){if(i.data&&i.expiresAt)if(i.expiresAt>Date.now()){let u=Date.now()-r;return console.log(`[getIssueDetail] Cache HIT for ${s} (${u}ms)`),i.data}else console.log(`[getIssueDetail] Cache EXPIRED for ${s}`);else if(i.expiresAt&&i.expiresAt>Date.now()){let u=Date.now()-r;return console.log(`[getIssueDetail] Cache HIT (legacy) for ${s} (${u}ms)`),i}}}catch(i){console.log(`[getIssueDetail] Cache MISS for ${s}:`,i instanceof Error?i.message:"Unknown error")}console.log(`[getIssueDetail] Fetching from Linear API for ${s}...`);let a=Date.now(),o=await j(ee.GET_ISSUE_DETAIL,{issueId:s}),n=Date.now()-a;console.log(`[getIssueDetail] Linear API response for ${s}: ${n}ms`),o.issue&&o.issue.children&&(o.issue.subIssues=o.issue.children.nodes||[],delete o.issue.children);try{await w(e,{data:o.issue,expiresAt:Date.now()+t*1e3}),console.log(`[getIssueDetail] Cached ${s} for ${t}s`)}catch(i){console.warn(`[getIssueDetail] Failed to cache ${s}:`,i instanceof Error?i.message:"Unknown error")}let c=Date.now()-r;return console.log(`[getIssueDetail] Total time for ${s}: ${c}ms (API: ${n}ms)`),o.issue}async function J(s){console.log(`[IssuesByState] Fetching team ${s} with issues grouped by state`);try{let e=await Q(s);if(!e)throw new Error(`Team ${s} not found or has no configuration`);console.log(`[IssuesByState] Team: ${e.name} (${e.key}) - ${e.states?.length||0} states`);let t=e.states||[],r=await Promise.all(t.map(async o=>{let n=await ns(s,o.id),c=n.reduce((i,u)=>i+(u.subIssues?.length||0),0);return{state:{id:o.id,name:o.name,type:o.type,color:o.color,position:o.position},issues:n,totalCount:n.length+c,rootCount:n.length,subIssueCount:c}})),a=r.reduce((o,n)=>o+n.totalCount,0);return console.log(`[IssuesByState] Total: ${a} issues across ${t.length} states`),r.forEach(o=>{o.rootCount>0&&console.log(`  ${o.state.name}: ${o.rootCount} root, ${o.subIssueCount} sub-issues`)}),{team:{id:e.id,name:e.name,key:e.key},states:r,totalIssues:a,timestamp:new Date().toISOString()}}catch(e){throw console.error(`[IssuesByState] Error fetching team ${s}:`,e),e}}async function ue(s,e){let r=await j(`
    mutation UpdateIssueState($issueId: String!, $stateId: String!) {
      issueUpdate(id: $issueId, input: { stateId: $stateId }) {
        success
        issue {
          id
          identifier
          state {
            id
            name
            type
          }
        }
      }
    }
  `,{issueId:s,stateId:e});try{await T(`linear:issue-detail:${s}`)}catch{}return r.issueUpdate}async function is(s,e,t){console.log(`[Linear] Requesting upload credentials for: ${e} (${t} bytes)`);let a=await j(`
    mutation FileUpload($contentType: String!, $filename: String!, $size: Int!) {
      fileUpload(contentType: $contentType, filename: $filename, size: $size) {
        success
        uploadFile {
          uploadUrl
          assetUrl
          headers {
            key
            value
          }
        }
      }
    }
  `,{contentType:s,filename:e,size:t});if(!a.fileUpload?.success||!a.fileUpload?.uploadFile)throw console.error("[Linear] Invalid fileUpload response:",a),new Error("Failed to request upload URL from Linear");return console.log(`[Linear] Got upload credentials for: ${e}`),console.log(`[Linear] Asset URL: ${a.fileUpload.uploadFile.assetUrl}`),a.fileUpload.uploadFile}async function cs(s){console.log(`[Linear] Starting file upload: ${s.name}`);let e=await is(s.type||"application/octet-stream",s.name,s.size),t=e.uploadUrl,r=e.assetUrl,a=new Headers;a.set("Content-Type",s.type||"application/octet-stream"),a.set("Cache-Control","public, max-age=31536000"),e.headers&&Array.isArray(e.headers)&&e.headers.forEach(n=>{a.set(n.key,n.value)}),console.log("[Linear] Uploading to Linear storage...");let o=await fetch(t,{method:"PUT",headers:a,body:s});if(!o.ok){let n=await o.text();throw console.error("[Linear] Upload failed:",{status:o.status,error:n}),new Error(`Failed to upload file to Linear: ${o.status}`)}return console.log(`[Linear] File uploaded successfully: ${s.name}`),console.log(`[Linear] Asset URL: ${r}`),r}async function me(s,e,t){console.log(`[Linear] Creating sub-issue for parent: ${s}`);let a=await j(`
    query GetParentIssue($issueId: String!) {
      issue(id: $issueId) {
        id
        identifier
        title
        cycle {
          id
          name
        }
        team {
          id
          name
        }
      }
    }
  `,{issueId:s});if(!a?.issue)throw new Error(`Parent issue not found: ${s}`);let o=a.issue.team?.id;if(!o)throw new Error(`Parent issue ${s} has no team assigned`);let n=a.issue.cycle?.id;console.log(`[Linear] Parent team: ${a.issue.team.name}, cycle: ${n?a.issue.cycle.name:"none"}`);let m=(await j(`
    query GetTeamStates($teamId: String!) {
      team(id: $teamId) {
        states {
          nodes {
            id
            name
            type
          }
        }
      }
    }
  `,{teamId:o}))?.team?.states?.nodes?.find(U=>U.name.toLowerCase()==="triage")?.id;console.log(m?`[Linear] Found Triage state: ${m}`:`[Linear] Warning: Triage state not found for team ${o}`);let h=(await j(`
    query GetTeamLabels($teamId: String!) {
      team(id: $teamId) {
        labels {
          nodes {
            id
            name
          }
        }
      }
    }
  `,{teamId:o}))?.team?.labels?.nodes||[],f=h.find(U=>U.name.toLowerCase()==="uat"),y=h.find(U=>U.name.toLowerCase()==="client-submitted"),p=[];f&&(p.push(f.id),console.log(`[Linear] Found UAT label: ${f.id}`)),y&&(p.push(y.id),console.log(`[Linear] Found Client-Submitted label: ${y.id}`));let $=await j(`
    mutation CreateSubIssue(
      $title: String!, 
      $description: String, 
      $teamId: String!, 
      $parentId: String!,
      $cycleId: String,
      $stateId: String,
      $labelIds: [String!]
    ) {
      issueCreate(input: { 
        title: $title
        description: $description
        teamId: $teamId
        parentId: $parentId
        cycleId: $cycleId
        stateId: $stateId
        labelIds: $labelIds
      }) {
        success
        issue {
          id
          identifier
          title
          description
          url
          parent {
            id
            identifier
            title
          }
          cycle {
            id
            name
          }
          state {
            id
            name
          }
          labels {
            nodes {
              id
              name
            }
          }
          team {
            id
            name
          }
        }
      }
    }
  `,{title:e,description:t||"",teamId:o,parentId:s,cycleId:n||null,stateId:m||null,labelIds:p.length>0?p:null});if(!$.issueCreate?.success)throw new Error("Failed to create sub-issue in Linear");let I=$.issueCreate.issue;return console.log(`[Linear] Sub-issue created: ${I.identifier}`,{parentId:s,cycleId:I.cycle?.id,stateId:I.state?.id,stateName:I.state?.name,labels:I.labels?.nodes?.map(U=>U.name).join(", ")||"none"}),I}async function De(s,e){if(console.log(`[Linear] Starting uploadFilesToIssue for issue: ${s}`),console.log(`[Linear] Files count: ${e.length}`),console.log("[Linear] Files details:",e.map(n=>({name:n.name,size:n.size,type:n.type}))),!e||e.length===0)throw new Error("No files provided to upload");let t=[],r=[];for(let n=0;n<e.length;n++){let c=e[n];try{console.log(`[Linear] Processing file ${n+1}/${e.length}: ${c.name}`);let i=await cs(c);t.push(i),console.log(`[Linear] File uploaded: ${c.name}`)}catch(i){let u=`Failed to upload ${c.name}: ${i instanceof Error?i.message:String(i)}`;console.error(`[Linear] ${u}`),console.error("[Linear] Error stack:",i instanceof Error?i.stack:"No stack"),r.push(u)}}if(t.length===0){let n=r.length>0?`Failed to upload any files to Linear. Errors: ${r.join("; ")}`:"Failed to upload any files to Linear. No errors captured.";throw console.error(`[Linear] ${n}`),new Error(n)}console.log(`[Linear] Successfully uploaded ${t.length}/${e.length} files to Linear storage`),r.length>0&&console.warn(`[Linear] ${r.length} files failed:`,r);let a=[],o=[];for(let n=0;n<t.length;n++){let c=t[n],i=e[n].name;try{console.log(`[Linear] Attaching ${n+1}/${t.length}: ${i}`);let m=await j(`
        mutation AttachUrl($issueId: String!, $url: String!, $title: String!) {
          attachmentCreate(input: { issueId: $issueId, url: $url, title: $title }) {
            success
            attachment {
              id
              title
              url
            }
          }
        }
      `,{issueId:s,url:c,title:i});if(!m.attachmentCreate?.success)throw new Error("attachmentCreate returned success: false");a.push({id:m.attachmentCreate.attachment.id,title:m.attachmentCreate.attachment.title,url:m.attachmentCreate.attachment.url}),console.log(`[Linear] Attached to issue: ${i}`)}catch(u){let m=`Failed to attach ${i}: ${u instanceof Error?u.message:String(u)}`;console.error(`[Linear] ${m}`),o.push(m)}}if(a.length===0){let n=`Failed to attach any files to issue. Errors: ${o.join("; ")}`;throw console.error(`[Linear] ${n}`),new Error(n)}return console.log(`[Linear] Successfully attached ${a.length}/${t.length} files to issue`),o.length>0&&console.warn(`[Linear] ${o.length} attachments failed:`,o),a}async function Ve(s,e){try{console.log(`[Linear] Finding state ID for: "${e}" in team ${s}`);let r=await j(`
      query GetTeamWorkflowStates($teamId: String!) {
        team(id: $teamId) {
          id
          states {
            nodes {
              id
              name
              type
            }
          }
        }
      }
    `,{teamId:s});if(!r?.team?.states?.nodes)return console.error("[Linear] No states found in team"),null;let a=r.team.states.nodes;console.log(`[Linear] Found ${a.length} workflow states`);let o=a.find(n=>n.name.toLowerCase()===e.toLowerCase());return o?(console.log(`[Linear] Found state: ${o.name} \u2192 ${o.id}`),o.id):(console.warn(`\uFE0F [Linear] State "${e}" not found in team ${s}`),console.log("Available states:",a.map(n=>n.name).join(", ")),null)}catch(t){return console.error("[Linear] Error fetching state ID:",t),null}}async function le(s){let{teamId:e,title:t,description:r,priority:a,assigneeId:o,stateId:n,labelIds:c,parentId:i}=s,{cycleId:u}=s,m=i?"sub-issue":"parent issue";if(console.log(`[Linear] Creating ${m}:`,{teamId:e,title:t,hasPriority:a!==void 0,hasAssignee:!!o,hasState:!!n,labelCount:c?.length||0,cycleIdProvided:!!u,hasParent:!!i}),!u){console.log("[Linear] No cycleId provided, fetching active UAT cycle...");let y=`
      query GetActiveCycle($teamId: String!) {
        team(id: $teamId) {
          cycles(
            filter: { 
              isActive: { eq: true }
            }
            first: 10
          ) {
            nodes {
              id
              name
              startsAt
              endsAt
            }
          }
        }
      }
    `;try{let v=(await j(y,{teamId:e})).team?.cycles?.nodes||[],$=v.find(I=>I.name.toLowerCase().includes("uat"));$?(u=$.id,console.log("[Linear] Found active UAT cycle:",{id:$.id,name:$.name})):v.length>0?(u=v[0].id,console.log("[Linear] Using first active cycle:",{id:v[0].id,name:v[0].name})):console.log("[Linear] No active cycle found, proceeding without cycle")}catch(p){console.error("[Linear] Failed to fetch active cycle:",p),console.log("[Linear] Proceeding without cycle")}}let d=`
    mutation CreateIssue(
      $teamId: String!
      $title: String!
      $description: String
      $priority: Int
      $assigneeId: String
      $stateId: String
      $labelIds: [String!]
      $cycleId: String
      $parentId: String
    ) {
      issueCreate(input: {
        teamId: $teamId
        title: $title
        description: $description
        priority: $priority
        assigneeId: $assigneeId
        stateId: $stateId
        labelIds: $labelIds
        cycleId: $cycleId
        parentId: $parentId
      }) {
        success
        issue {
          id
          identifier
          title
          description
          url
          priority
          priorityLabel
          state {
            id
            name
            type
          }
          assignee {
            id
            name
            email
            avatarUrl
          }
          labels {
            nodes {
              id
              name
              color
            }
          }
          cycle {
            id
            name
          }
          team {
            id
            name
            key
          }
          createdAt
          updatedAt
        }
      }
    }
  `,g={teamId:e,title:t};r&&(g.description=r),a!==void 0&&(g.priority=a),o&&(g.assigneeId=o),n&&(g.stateId=n),c&&c.length>0&&(g.labelIds=c),u&&(g.cycleId=u),i&&(g.parentId=i);let h=await j(d,g);if(!h.issueCreate?.success)throw new Error("Failed to create issue in Linear");let f=h.issueCreate.issue;return console.log(`[Linear] ${m} created:`,{identifier:f.identifier,id:f.id,state:f.state?.name,priority:f.priorityLabel,labels:f.labels?.nodes?.map(y=>y.name).join(", ")||"none",parentId:i||"none"}),{success:!0,data:f}}async function de(s){return await J(s)}async function ge(s){try{let t=(await as(s)).map(r=>`linear:issue-detail:${r.id}`);for(let r of t)try{await T(r)}catch{}return{success:!0,message:`Invalidated cache for ${t.length} issues in team ${s}`,invalidatedCount:t.length}}catch(e){return console.error(`[invalidateCache] Error invalidating cache for team ${s}:`,e),{success:!1,error:e instanceof Error?e.message:"Failed to invalidate cache"}}}async function fe(){try{let s=await S("linear:issue-detail:"),e=0,t=0,r=0;for(let a of s)try{let o=await l(a);o&&(o.expiresAt&&o.expiresAt>Date.now()?t++:r++,e+=JSON.stringify(o).length)}catch{}return{success:!0,data:{totalCaches:s.length,validCaches:t,expiredCaches:r,estimatedSize:e,estimatedSizeKB:Math.round(e/1024)}}}catch(s){return console.error("[getCacheStats] Error getting cache stats:",s),{success:!1,error:s instanceof Error?s.message:"Failed to get cache stats"}}}var A=new us;A.use("*",E);var se=new X;A.get("/linear/test",async s=>{try{let e=s.get("user"),t=await se.testConnection();return s.json({success:t.success,message:t.message,data:t.data||null})}catch(e){return console.error("[Linear] Test connection error:",e),s.json({success:!1,error:"Failed to test Linear connection",message:e instanceof Error?e.message:"Unknown error"},{status:500})}});A.get("/linear/hierarchy",async s=>{try{let e=s.get("user"),{data:t,error:r}=await Ce(process.env.SUPABASE_URL,process.env.SUPABASE_SERVICE_ROLE_KEY).from("kv_store_7f0d90fb").select("value").eq("key","linear_teams:all").single();if(!r&&t?.value){let o=typeof t.value=="string"?JSON.parse(t.value):t.value;if(!o.teams||!Array.isArray(o.teams))console.error("[Linear] Invalid KV cache data structure:",{hasTeams:!!o.teams,isArray:Array.isArray(o.teams),keys:Object.keys(o)});else return s.json({success:!0,data:o,source:"cache"})}let a=await se.listTeams();return a.success?s.json({success:!0,data:{teams:a.teams||[],count:a.teams?.length||0,syncedAt:new Date().toISOString()},source:"api"}):s.json({success:!1,error:a.message||"Failed to fetch teams"},{status:500})}catch(e){return console.error("[Linear] Get hierarchy error:",e),s.json({success:!1,error:"Failed to fetch team hierarchy",message:e instanceof Error?e.message:"Unknown error"},{status:500})}});A.get("/linear/teams",async s=>{try{let e=s.get("user"),t=await se.listTeams();return t.success?s.json({success:!0,data:t.teams||[]}):s.json({success:!1,error:t.message||"Failed to fetch teams"},{status:500})}catch(e){return console.error("[Linear] Get teams error:",e),s.json({success:!1,error:"Failed to fetch Linear teams",message:e instanceof Error?e.message:"Unknown error"},{status:500})}});A.post("/linear/clear-cache",async s=>{try{let e=s.get("user"),t=s.get("role"),r=s.get("isSuperAdmin");if(!["superadmin","admin"].includes(t)&&!r)return s.json({success:!1,error:"Unauthorized. Only admins can clear cache."},{status:403});let a=Ce(process.env.SUPABASE_URL,process.env.SUPABASE_SERVICE_ROLE_KEY),o=["linear:organization","linear_teams:all","team_ownership_map:all"],n=0;for(let i of o){let{error:u}=await a.from("kv_store_7f0d90fb").delete().eq("key",i);u||n++}let c=["cache:linear-teams","linear:","team:"];for(let i of c){let{error:u}=await a.from("kv_store_7f0d90fb").delete().like("key",`${i}%`)}return await _.invalidateCache(),s.json({success:!0,message:"All Linear cache data cleared successfully",deletedKeys:n,clearedPrefixes:c})}catch(e){return console.error("[Linear Cache Clear] Error:",e),s.json({success:!1,error:"Failed to clear cache",message:e instanceof Error?e.message:"Unknown error"},{status:500})}});A.post("/linear/sync-hierarchy",async s=>{try{let e=s.get("user"),t=s.get("role"),r=s.get("isSuperAdmin");if(await _.invalidateCache(),await Ce(process.env.SUPABASE_URL,process.env.SUPABASE_SERVICE_ROLE_KEY).from("kv_store_7f0d90fb").delete().or("key.eq.linear:organization,key.eq.team_ownership_map:all,key.like.cache:linear-teams%"),!["superadmin","admin"].includes(t)&&!r)return s.json({success:!1,error:"Unauthorized. Only admins can sync team hierarchy."},{status:403});let o=await se.syncTeamHierarchy();return o.success?s.json({success:!0,message:o.message,data:o.data}):s.json({success:!1,error:o.message||"Failed to sync team hierarchy"},{status:500})}catch(e){return console.error("[Linear] Sync hierarchy error:",e),s.json({success:!1,error:"Failed to sync team hierarchy",message:e instanceof Error?e.message:"Unknown error"},{status:500})}});A.get("/linear/teams/:teamId",async s=>{let e=s.req.param("teamId");try{let t=s.get("user"),r=await se.getTeamById(e);return r?s.json({success:!0,data:r}):s.json({success:!1,error:"Team not found",teamId:e},{status:404})}catch(t){console.error("[Linear] Get team error:",t);let r=t instanceof Error?t.message:String(t);return r.includes("not found in Linear workspace")?s.json({success:!1,error:"Team not found in Linear workspace",message:"This team may have been deleted from Linear or you don't have access to it.",teamId:e},{status:404}):s.json({success:!1,error:"Failed to fetch Linear team",message:r},{status:500})}});A.get("/linear/teams/:teamId/config",async s=>{let e=s.req.param("teamId");try{let t=s.get("user"),r=await Q(e);return r?s.json({success:!0,data:r}):s.json({success:!1,error:"Team config not found"},{status:404})}catch(t){console.error("[Linear] Get team config error:",t);let r=t instanceof Error?t.message:String(t);return r.includes("not found in Linear workspace")?s.json({success:!1,error:"Team not found in Linear workspace",message:"This team may have been deleted from Linear or you don't have access to it.",teamId:e},{status:404}):s.json({success:!1,error:"Failed to fetch team config",message:r},{status:500})}});A.get("/linear/teams/:teamId/state-by-name",async s=>{let e=s.req.param("teamId"),t=s.req.query("name");try{let r=s.get("user");if(!t)return s.json({success:!1,error:"Missing required query parameter: name"},{status:400});let a=await Ve(e,t);return a?s.json({success:!0,data:{stateId:a,stateName:t}}):s.json({success:!1,error:`State "${t}" not found in team`},{status:404})}catch(r){console.error("[Linear] Get state by name error:",r);let a=r instanceof Error?r.message:String(r);return s.json({success:!1,error:"Failed to fetch state by name",message:a},{status:500})}});A.get("/linear/teams/:teamId/issues-by-state",async s=>{let e=s.req.param("teamId");try{let t=s.get("user"),r=await J(e);return r?s.json({success:!0,data:r,timestamp:new Date().toISOString()}):s.json({success:!1,error:"Failed to fetch team issues by state"},{status:500})}catch(t){console.error("[Linear] Get team issues by state error:",t);let r=t instanceof Error?t.message:String(t);return r.includes("not found in Linear workspace")?s.json({success:!1,error:"Team not found in Linear workspace",message:"This team may have been deleted from Linear or you don't have access to it.",teamId:e},{status:404}):s.json({success:!1,error:t instanceof Error?t.message:"Failed to fetch team issues by state",message:r},{status:500})}});A.get("/linear/teams/:teamId/issues",async s=>{let e=s.req.param("teamId");try{let t=s.get("user"),r=await de(e);return r?s.json({success:!0,data:r}):s.json({success:!1,error:"Failed to fetch team issues"},{status:500})}catch(t){console.error("[Linear] Get team issues error:",t);let r=t instanceof Error?t.message:String(t);return r.includes("not found in Linear workspace")?s.json({success:!1,error:"Team not found in Linear workspace",message:"This team may have been deleted from Linear or you don't have access to it.",teamId:e},{status:404}):s.json({success:!1,error:"Failed to fetch team issues",message:r},{status:500})}});A.get("/linear/teams/:teamId/issues/by-state",async s=>{try{let e=s.get("user"),t=s.req.param("teamId"),r=await J(t);return r?s.json({success:!0,data:r}):s.json({success:!1,error:"Failed to fetch issues by state"},{status:500})}catch(e){return console.error("[Linear] Get issues by state error:",e),s.json({success:!1,error:"Failed to fetch issues by state"},{status:500})}});A.post("/linear/graphql",async s=>{try{let e=s.get("user"),t=await s.req.json(),{query:r,variables:a}=t;if(!r)return s.json({success:!1,error:"GraphQL query is required"},{status:400});let o=await j(r,a||{});return s.json({success:!0,data:o})}catch(e){return console.error("[Linear] GraphQL execution error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Failed to execute GraphQL query"},{status:500})}});A.get("/linear/issues/:issueId",async s=>{try{let e=s.get("user"),t=s.req.param("issueId"),r=await ce(t);return r?s.json({success:!0,data:r}):s.json({success:!1,error:"Issue not found"},{status:404})}catch(e){return console.error("[Linear] Get issue error:",e),s.json({success:!1,error:"Failed to fetch issue"},{status:500})}});A.post("/linear/issues/:parentIssueId/sub-issues",async s=>{try{let e=s.get("user"),t=s.req.param("parentIssueId"),r=await s.req.json(),{title:a,description:o}=r;if(!a||!a.trim())return s.json({success:!1,error:"Title is required"},{status:400});let n=await me(t,a.trim(),o?.trim());return n?s.json({success:!0,data:n}):s.json({success:!1,error:"Failed to create sub-issue"},{status:500})}catch(e){console.error("[Linear] Create sub-issue error:",e);let t=e instanceof Error?e.message:String(e);return s.json({success:!1,error:"Failed to create sub-issue",message:t},{status:500})}});A.put("/linear/issues/:issueId/state",async s=>{try{let e=s.get("user"),t=s.req.param("issueId"),r=await s.req.json(),{stateId:a}=r;if(!a)return s.json({success:!1,error:"stateId is required"},{status:400});let o=await ue(t,a);return o?s.json({success:!0,data:o,message:"Issue state updated successfully"}):s.json({success:!1,error:"Failed to update issue state"},{status:500})}catch(e){return console.error("[Linear] Update issue state error:",e),s.json({success:!1,error:"Failed to update issue state"},{status:500})}});A.post("/linear/issues/create",async s=>{try{let e=s.get("user"),t=await s.req.json(),{teamId:r,title:a,description:o,priority:n,stateId:c,assigneeId:i,labelIds:u,cycleId:m}=t;if(!r||!a)return s.json({success:!1,error:"teamId and title are required"},{status:400});if(!(await _.checkUserTeamAccess(e.id,r)).success)return s.json({success:!1,error:"Access denied to this team"},{status:403});let g=await le({teamId:r,title:a,description:o,priority:n,stateId:c,assigneeId:i,labelIds:u,cycleId:m});return!g||!g.data?s.json({success:!1,error:"Failed to create issue"},{status:500}):s.json({success:!0,data:g.data})}catch(e){console.error("[Linear] Create issue error:",e);let t=e instanceof Error?e.message:String(e);return s.json({success:!1,error:"Failed to create issue",message:t},{status:500})}});A.post("/linear/cache/invalidate",async s=>{try{let e=s.get("user"),t=await s.req.json(),{teamId:r}=t,a=await ge(r);return s.json({success:!0,message:"Cache invalidated successfully"})}catch(e){return console.error("[Linear] Invalidate cache error:",e),s.json({success:!1,error:"Failed to invalidate cache"},{status:500})}});A.get("/linear/cache/stats",async s=>{try{let e=s.get("user"),t=s.get("role");if(t!=="admin"&&t!=="superadmin")return s.json({success:!1,error:"Admin access required"},{status:403});let r=await fe();return s.json({success:!0,data:r.data||{}})}catch(e){return console.error("[Linear] Get cache stats error:",e),s.json({success:!1,error:"Failed to fetch cache stats"},{status:500})}});A.get("/linear/teams/:teamId/states",async s=>{try{let e=s.get("user"),t=s.req.param("teamId"),r=await Q(t);return r?s.json({success:!0,data:{states:r.states||[],team:{id:r.id,name:r.name,key:r.key}}}):s.json({success:!1,error:"Team config not found"},{status:404})}catch(e){return console.error("[Linear] Get states error:",e),s.json({success:!1,error:"Failed to fetch team states"},{status:500})}});A.get("/linear/teams/:teamId/labels",async s=>{try{let e=s.get("user"),t=s.req.param("teamId"),r=await Q(t);return r?s.json({success:!0,data:{labels:r.labels||[],team:{id:r.id,name:r.name,key:r.key}}}):s.json({success:!1,error:"Team config not found"},{status:404})}catch(e){return console.error("[Linear] Get labels error:",e),s.json({success:!1,error:"Failed to fetch team labels"},{status:500})}});A.get("/linear/teams/:teamId/members",async s=>{try{let e=s.get("user"),t=s.req.param("teamId"),r=await Q(t);return r?s.json({success:!0,data:{members:r.members||[],team:{id:r.id,name:r.name,key:r.key}}}):s.json({success:!1,error:"Team config not found"},{status:404})}catch(e){return console.error("[Linear] Get members error:",e),s.json({success:!1,error:"Failed to fetch team members"},{status:500})}});A.get("/linear/teams/:teamId/projects",async s=>{try{let e=s.get("user"),t=s.req.param("teamId"),r=await Q(t);return r?s.json({success:!0,data:{projects:r.projects||[],team:{id:r.id,name:r.name,key:r.key}}}):s.json({success:!1,error:"Team config not found"},{status:404})}catch(e){return console.error("[Linear] Get projects error:",e),s.json({success:!1,error:"Failed to fetch team projects"},{status:500})}});A.post("/linear/issues/:issueId/upload",async s=>{try{let e=s.req.param("issueId"),t=s.req.header("Content-Type"),a=(await s.req.formData()).getAll("files");if(!a||a.length===0)return console.error("[Linear Routes] No files in formData"),s.json({success:!1,error:"No files provided"},{status:400});let o=a.filter(c=>c instanceof File);if(o.length===0)return console.error("[Linear Routes] No valid File objects found"),s.json({success:!1,error:"No valid files found"},{status:400});let n=await De(e,o);return!n||n.length===0?(console.error("[Linear Routes] No attachments returned from service"),s.json({success:!1,error:"Failed to upload any files"},{status:500})):s.json({success:!0,data:{attachments:n,count:n.length}})}catch(e){return console.error("[Linear Routes] File upload error:",e),console.error("[Linear Routes] Error stack:",e instanceof Error?e.stack:"No stack"),s.json({success:!1,error:e instanceof Error?e.message:"Failed to upload files"},{status:500})}});V();import{Hono as ms}from"hono";import{createClient as Oe}from"@supabase/supabase-js";var te=new ms;te.use("*",E);te.post("/linear/cleanup-orphaned-mappings",async s=>{try{let e=s.get("user"),t=s.get("role"),r=s.get("isSuperAdmin");if(!["superadmin","admin"].includes(t)&&!r)return s.json({success:!1,error:"Unauthorized. Only admins can cleanup orphaned mappings."},{status:403});let a=Oe(process.env.SUPABASE_URL,process.env.SUPABASE_SERVICE_ROLE_KEY),{data:o,error:n}=await a.from("kv_store_7f0d90fb").select("value").eq("key","linear_teams:all").single();if(n||!o?.value)return s.json({success:!1,error:"Could not load teams data. Please sync teams first."},{status:500});let c=typeof o.value=="string"?JSON.parse(o.value):o.value,i=new Set((c.teams||[]).map(f=>f.id)),{data:u,error:m}=await a.from("kv_store_7f0d90fb").select("key, value").like("key","customer_teams:%");if(m)return s.json({success:!1,error:"Failed to load customer mappings"},{status:500});if(!u||u.length===0)return s.json({success:!0,message:"No customer mappings found",data:{customersChecked:0,orphanedRemoved:0,customersUpdated:0}});let d=0,g=0,h=[];for(let f of u){let y=f.key.replace("customer_teams:",""),p=Array.isArray(f.value)?f.value:[],v=p.filter(I=>i.has(I)),$=p.filter(I=>!i.has(I));$.length>0&&(await a.from("kv_store_7f0d90fb").update({value:v}).eq("key",`customer_teams:${y}`),d+=$.length,g++,h.push({customerId:y,removed:$,remaining:v.length}))}return s.json({success:!0,message:`Cleanup complete! Removed ${d} orphaned team assignments from ${g} customers`,data:{customersChecked:u.length,orphanedRemoved:d,customersUpdated:g,validTeamsCount:i.size,details:h}})}catch(e){return console.error("[Linear Cleanup] Error:",e),s.json({success:!1,error:"Failed to cleanup orphaned mappings",message:e instanceof Error?e.message:"Unknown error"},{status:500})}});te.get("/linear/validate-mappings",async s=>{try{let e=s.get("user"),t=s.get("role"),r=s.get("isSuperAdmin");if(!["superadmin","admin","client_manager"].includes(t)&&!r)return s.json({success:!1,error:"Unauthorized. Only admins can validate mappings."},{status:403});let a=Oe(process.env.SUPABASE_URL,process.env.SUPABASE_SERVICE_ROLE_KEY),{data:o,error:n}=await a.from("kv_store_7f0d90fb").select("value").eq("key","linear_teams:all").single();if(n||!o?.value)return s.json({success:!1,error:"Could not load teams data. Please sync teams first."},{status:500});let c=typeof o.value=="string"?JSON.parse(o.value):o.value,i=new Set((c.teams||[]).map(h=>h.id)),u=new Map((c.teams||[]).map(h=>[h.id,h])),{data:m}=await a.from("kv_store_7f0d90fb").select("key, value").like("key","customer_teams:%");if(!m||m.length===0)return s.json({success:!0,message:"No customer mappings found",data:{validTeamsCount:i.size,customersChecked:0,customersWithOrphans:0,totalOrphaned:0,issues:[]}});let d=[],g=0;for(let h of m){let f=h.key.replace("customer_teams:",""),y=Array.isArray(h.value)?h.value:[],p=[];for(let v of y)if(!i.has(v)){let $=u.get(v);p.push({teamId:v,note:$?`Team "${$.name}" no longer exists`:"Unknown team (deleted from Linear)"}),g++}p.length>0&&d.push({customerId:f,orphanedTeams:p,validTeamsCount:y.length-p.length})}return s.json({success:!0,message:g>0?`Found ${g} orphaned team assignments in ${d.length} customers. Use cleanup endpoint to remove them.`:"All customer-team mappings are valid",data:{validTeamsCount:i.size,customersChecked:m.length,customersWithOrphans:d.length,totalOrphaned:g,issues:d}})}catch(e){return console.error("[Linear Validate] Error:",e),s.json({success:!1,error:"Failed to validate mappings",message:e instanceof Error?e.message:"Unknown error"},{status:500})}});V();import{Hono as ls}from"hono";var x=new ls;x.use("*",E);x.get("/issues/team/:teamId",async s=>{try{let e=s.get("user"),t=s.req.param("teamId");if(!(await _.checkUserTeamAccess(e.id,t)).success)return s.json({success:!1,error:"Access denied to this team"},{status:403});let a=await de(t);return a.success?s.json({success:!0,data:a.data}):s.json({success:!1,error:a.error},{status:500})}catch(e){return console.error("[Issues] Get team issues error:",e),s.json({success:!1,error:"Failed to fetch team issues"},{status:500})}});x.get("/issues/team/:teamId/by-state",async s=>{try{let e=s.get("user"),t=s.req.param("teamId");if(!(await _.checkUserTeamAccess(e.id,t)).success)return s.json({success:!1,error:"Access denied to this team"},{status:403});let a=await J(t);return a?s.json({success:!0,data:a.data}):s.json({success:!1,error:"Failed to fetch issues by state"},{status:500})}catch(e){return console.error("[Issues] Get issues by state error:",e),s.json({success:!1,error:"Failed to fetch issues by state"},{status:500})}});x.get("/issues/:issueId",async s=>{try{let e=s.get("user"),t=s.req.param("issueId"),r=await ce(t);if(!r)return s.json({success:!1,error:"Issue not found"},{status:404});let a={success:!0,data:{issue:r}};return s.json(a)}catch(e){return console.error("[Issues] Get issue error:",e),s.json({success:!1,error:"Failed to fetch issue"},{status:500})}});x.put("/issues/:issueId/state",async s=>{try{let e=s.get("user"),t=s.req.param("issueId"),r=await s.req.json(),{stateId:a}=r;if(!a)return s.json({success:!1,error:"stateId is required"},{status:400});let o=await ue(t,a);return o.success?s.json({success:!0,data:o.data,message:"Issue state updated successfully"}):s.json({success:!1,error:o.error},{status:500})}catch(e){return console.error("[Issues] Update issue state error:",e),s.json({success:!1,error:"Failed to update issue state"},{status:500})}});x.post("/issues/create",async s=>{try{let e=s.get("user"),t=await s.req.json(),{teamId:r,title:a,description:o,priority:n,stateId:c,assigneeId:i,labelIds:u,cycleId:m}=t;if(!r||!a)return s.json({success:!1,error:"teamId and title are required"},{status:400});if(!(await _.checkUserTeamAccess(e.id,r)).success)return s.json({success:!1,error:"Access denied to this team"},{status:403});let g=await le({teamId:r,title:a,description:o,priority:n,stateId:c,assigneeId:i,labelIds:u,cycleId:m});return s.json({success:!0,data:g.data})}catch(e){return console.error("[Issues] Create issue error:",e),s.json({success:!1,error:"Failed to create issue"},{status:500})}});x.post("/issues/:parentIssueId/sub-issues",async s=>{try{let e=s.get("user"),t=s.req.param("parentIssueId"),r=await s.req.json(),{title:a,description:o}=r;if(!a)return s.json({success:!1,error:"title is required"},{status:400});let n=await me(t,a,o);return s.json({success:!0,data:n})}catch(e){return console.error("[Issues] Create sub-issue error:",e),s.json({success:!1,error:"Failed to create sub-issue"},{status:500})}});x.post("/issues/cache/invalidate",async s=>{try{let e=s.get("user"),t=await s.req.json(),{teamId:r}=t,a=await ge(r);return s.json({success:!0,message:"Cache invalidated successfully"})}catch(e){return console.error("[Issues] Invalidate cache error:",e),s.json({success:!1,error:"Failed to invalidate cache"},{status:500})}});x.get("/issues/cache/stats",async s=>{try{let e=s.get("user"),t=s.get("role");if(t!=="admin"&&t!=="superadmin")return s.json({success:!1,error:"Admin access required"},{status:403});let r=await fe();return s.json({success:!0,data:r.data})}catch(e){return console.error("[Issues] Get cache stats error:",e),s.json({success:!1,error:"Failed to fetch cache stats"},{status:500})}});M();V();import{Hono as ds}from"hono";var B=new ds;async function pe(s){try{return(await Y()).includes(s.toLowerCase().trim())}catch(e){return console.error("[SuperadminRoutes] Error checking superadmin status:",e),!1}}B.post("/superadmin/initialize",async s=>{try{let e=await l("superadmin:emails");if(e&&Array.isArray(e)&&e.length>0)return console.warn("[SuperadminRoutes] Initialization attempt when list already exists"),s.json({success:!1,error:"Superadmin list already initialized"},{status:400});let t=await s.req.json(),{emails:r}=t;if(!r||!Array.isArray(r)||r.length===0)return s.json({success:!1,error:"Invalid email list"},{status:400});let o=r.map(c=>c.toLowerCase().trim()).filter(c=>c.includes("@"));if(o.length===0)return s.json({success:!1,error:"No valid emails provided"},{status:400});await w("superadmin:emails",o),await w("superadmin:settings",{enableDynamicSuperadmins:!0,requireMFA:!1,maxSuperadmins:10,allowSelfRemoval:!1});let n=`audit:superadmin:initialize:${Date.now()}`;return await w(n,{action:"superadmin_initialized",emails:o,timestamp:new Date().toISOString(),count:o.length}),s.json({success:!0,data:{superadmins:o,count:o.length}})}catch(e){return console.error("[SuperadminRoutes] Error initializing:",e),s.json({success:!1,error:"Failed to initialize superadmin list"},{status:500})}});B.use("*",E);B.get("/superadmin/check",async s=>{try{let t=(s.get("user").email||"").toLowerCase().trim(),r=await pe(t);return s.json({success:!0,data:{isSuperAdmin:r,email:t}})}catch(e){return console.error("[SuperadminRoutes] Error checking superadmin status:",e),s.json({success:!1,error:"Failed to check superadmin status"},{status:500})}});B.get("/superadmin/list",async s=>{try{let t=(s.get("user").email||"").toLowerCase().trim(),r=await Y();return r.includes(t)?s.json({success:!0,data:{superadmins:r,count:r.length,isSuperAdmin:!0},timestamp:new Date().toISOString()}):s.json({success:!0,data:{superadmins:[],count:0,isSuperAdmin:!1}})}catch(e){return console.error("[SuperadminRoutes] Error fetching list:",e),s.json({success:!1,error:"Failed to fetch superadmin list"},{status:500})}});B.post("/superadmin/add",async s=>{try{let e=s.get("user");if(!await pe(e.email||""))return console.warn(`[SuperadminRoutes] Unauthorized add attempt by ${e.email}`),s.json({success:!1,error:"Superadmin access required"},{status:403});let r=await s.req.json(),{email:a,reason:o}=r;if(!a||typeof a!="string"||!a.includes("@"))return s.json({success:!1,error:"Invalid email address"},{status:400});let n=a.toLowerCase().trim(),c=await l("superadmin:emails")||[];if(c.includes(n))return s.json({success:!1,error:"Email already in superadmin list"},{status:400});let i=[...c,n];await w("superadmin:emails",i);let u=`audit:superadmin:add:${Date.now()}`;return await w(u,{action:"superadmin_added",email:n,addedBy:e.email,timestamp:new Date().toISOString(),ip:s.req.header("x-forwarded-for")||"unknown",userAgent:s.req.header("user-agent"),reason:o||null}),await re(["system:superadmins:cache","system:superadmin:audit:cache"]),s.json({success:!0,data:{email:n,addedBy:e.email,timestamp:new Date().toISOString()}})}catch(e){return console.error("[SuperadminRoutes] Error adding superadmin:",e),s.json({success:!1,error:"Failed to add superadmin"},{status:500})}});B.delete("/superadmin/remove/:email",async s=>{try{let e=s.get("user");if(!await pe(e.email||""))return console.warn(`[SuperadminRoutes] Unauthorized remove attempt by ${e.email}`),s.json({success:!1,error:"Superadmin access required"},{status:403});let r=decodeURIComponent(s.req.param("email")).toLowerCase().trim();if(r===e.email?.toLowerCase())return console.warn(`[SuperadminRoutes] Self-removal attempt by ${e.email}`),s.json({success:!1,error:"Cannot remove yourself from superadmin list"},{status:400});let a=await l("superadmin:emails")||[];if(!a.includes(r))return s.json({success:!1,error:"Email not in superadmin list"},{status:404});if(a.length===1)return console.warn(`[SuperadminRoutes] Attempt to remove last superadmin by ${e.email}`),s.json({success:!1,error:"Cannot remove last superadmin"},{status:400});let o=a.filter(c=>c!==r);await w("superadmin:emails",o);let n=`audit:superadmin:remove:${Date.now()}`;return await w(n,{action:"superadmin_removed",email:r,removedBy:e.email,timestamp:new Date().toISOString(),ip:s.req.header("x-forwarded-for")||"unknown",userAgent:s.req.header("user-agent")}),await re(["system:superadmins:cache","system:superadmin:audit:cache"]),s.json({success:!0,data:{email:r,removedBy:e.email,timestamp:new Date().toISOString()}})}catch(e){return console.error("[SuperadminRoutes] Error removing superadmin:",e),s.json({success:!1,error:"Failed to remove superadmin"},{status:500})}});B.get("/superadmin/audit",async s=>{try{let e=s.get("user");if(!await pe(e.email||""))return console.warn(`[SuperadminRoutes] Unauthorized audit access by ${e.email}`),s.json({success:!1,error:"Superadmin access required"},{status:403});let r="system:superadmin:audit:cache",a=await l(r);if(a&&typeof a=="object"&&"logs"in a&&"timestamp"in a){let u=Date.now()-new Date(a.timestamp).getTime(),m=300*1e3;if(u<m)return s.json({success:!0,data:{logs:a.logs,count:a.logs.length,cached:!0}})}let o=await S("audit:superadmin:");if(!o||o.length===0)return s.json({success:!0,data:{logs:[],count:0}});let c=(await $e(o)).filter(u=>u!==null).sort((u,m)=>new Date(m.timestamp).getTime()-new Date(u.timestamp).getTime()),i=c.slice(0,100);return await w(r,{logs:i,timestamp:new Date().toISOString(),ttl:300*1e3}),s.json({success:!0,data:{logs:i,count:i.length,total:c.length,cached:!1}})}catch(e){return console.error("[SuperadminRoutes] Error fetching audit:",e),s.json({success:!1,error:"Failed to fetch audit trail"},{status:500})}});var L=new gs,ys=["http://localhost:5173","http://localhost:3000","http://127.0.0.1:5173","http://127.0.0.1:3000","https://fwltshzniolrekqhtpgv.supabase.co","https://dashboard.teifi.work","https://portal-seven-alpha.vercel.app",...process.env.VERCEL_URL?[`https://${process.env.VERCEL_URL}`]:[],...process.env.NEXT_PUBLIC_VERCEL_URL?[`https://${process.env.NEXT_PUBLIC_VERCEL_URL}`]:[]].filter(Boolean);L.use("*",fs({origin:s=>!s||ys.includes(s)?s:(console.warn("[CORS] Rejected origin:",s),null),allowMethods:["GET","POST","PUT","DELETE","PATCH","OPTIONS"],allowHeaders:["Content-Type","Authorization","X-CSRF-Token"],exposeHeaders:["Content-Length"],maxAge:86400,credentials:!0}));L.use("*",ps(console.log));var K="/api";L.route(K,F);L.route(K,k);L.route(K,z);L.route(K,P);L.route(K,A);L.route(K,te);L.route(K,x);L.route(K,B);L.post("/api/debug/clear-ownership-cache",async s=>{try{let{createClient:e}=await import("@supabase/supabase-js"),t=e(process.env.SUPABASE_URL,process.env.SUPABASE_SERVICE_ROLE_KEY),{error:r}=await t.from("kv_store_7f0d90fb").delete().eq("key","team_ownership_map:all");return r?(console.error("[Debug] Error clearing ownership cache:",r),s.json({success:!1,error:r.message},{status:500})):(console.log("[Debug] Ownership cache cleared successfully"),s.json({success:!0,message:"Ownership cache cleared",timestamp:new Date().toISOString()}))}catch(e){return console.error("[Debug] Unexpected error:",e),s.json({success:!1,error:e instanceof Error?e.message:"Unknown error"},{status:500})}});L.get("/api/debug/ownership-data",async s=>{try{let{createClient:e}=await import("@supabase/supabase-js"),t=e(process.env.SUPABASE_URL,process.env.SUPABASE_SERVICE_ROLE_KEY),{data:r,error:a}=await t.from("kv_store_7f0d90fb").select("key, value").like("key","team:%:customer");if(a)return s.json({success:!1,error:a.message},{status:500});let{data:o}=await t.from("kv_store_7f0d90fb").select("key, value").eq("key","team_ownership_map:all").single(),n={};if(r)for(let c of r){let i=c.key.replace("team:","").replace(":customer","");n[i]=c.value}return s.json({success:!0,data:{directMappings:r?.length||0,ownershipMap:n,cacheExists:!!o,cacheAge:o?.value?.timestamp?Date.now()-o.value.timestamp:null,rawData:r},timestamp:new Date().toISOString()})}catch(e){return console.error("[Debug] Error inspecting ownership data:",e),s.json({success:!1,error:e instanceof Error?e.message:"Unknown error"},{status:500})}});L.get("/",s=>s.json({name:"Teifi Digital Client Portal API",version:"2.0.0",status:"operational",architecture:"Clean & Modular",endpoints:{system:"/api/health",admin:"/api/admin/stats",teams:"/api/teams/my-teams",linear:"/api/linear/test",issues:"/api/issues/team/:teamId",superadmin:"/api/superadmin/list"},documentation:"https://github.com/teifi-digital/client-portal",timestamp:new Date().toISOString()}));L.all("*",s=>s.json({success:!1,error:"Endpoint not found",path:s.req.path,method:s.req.method,available_prefixes:[]},{status:404}));var xe=L;if(process.env.VERCEL!=="1"){let s=parseInt(process.env.PORT||"3001",10);console.log("Starting Teifi Digital Client Portal Server..."),console.log(`Server listening on port ${s}`),hs({fetch:L.fetch,port:s},e=>{console.log(`Server ready at http://localhost:${e.port}`)})}var jt=ws(xe);export{jt as default};
